Compiling Program: C:\DataFlex Projects\Centros\AppSrc\oLogginDataBase.src
Memory Available: 8848842752
1>//**************************************************************
1>// ManagedConnectionLoginProject.tpl for Spanish translated by Moose Software (www.moose-software.com) 
1>// 09/10/2020 Revised for DataFlex 20.0 by Moose Software
1>// 31/01/2022 Revised for DataFlex 20.1 by Moose Software
1>//*************************************************************************************
1>
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.x64.pkd    (C:\Program Files\DataFlex 25.0\Pkg\windows.x64.pkd)
8304>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cApplication.pkg)
8304>>>Use Windows.pkg
8304>>>
8304>>>Use LanguageText.pkg
8304>>>Use WinUser.pkg
8304>>>Use WinShell.pkg
8304>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cWorkspace.pkg)
8304>>>>>Use VdfBase.pkg
8304>>>>>Use tWinStructs.pkg
8304>>>>>Use LanguageText.pkg
8304>>>>>Use WinShell.pkg // Shell API functions
8304>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files\DataFlex 25.0\Pkg\seq_chnl.pkg)
8304>>>>>>>Use LanguageText.pkg
8304>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files\DataFlex 25.0\Pkg\errornum.inc)
8304>>>>>>>>    
8304>>>>>>>>
8304>>>>>>>>
8304>>>>>>>
8304>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
8304>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
8304>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
8304>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
8304>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
8304>>>>>>>// so that programs that use direct_input/output
8304>>>>>>>// w/o specifying a channel will work.
8304>>>>>>>Enum_List
8304>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
8304>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
8304>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
8304>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
8304>>>>>>>End_Enum_List
8304>>>>>>>
8304>>>>>>>Enum_List
8304>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
8304>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
8304>>>>>>>End_Enum_List
8304>>>>>>>
8304>>>>>>>Global_Variable Integer Seq$Channel$Error$Mode
8304>>>>>>>
8304>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer iMode
8306>>>>>>>    Move iMode to Seq$Channel$Error$Mode
8307>>>>>>>End_Procedure
8308>>>>>>>
8308>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
8310>>>>>>>    Function_Return Seq$Channel$Error$Mode
8311>>>>>>>End_Function
8312>>>>>>>
8312>>>>>>>Global_Variable Integer[DF_SEQ_CHANNEL_MAX] giSeqChannelList
8312>>>>>>>// initialize array
8312>>>>>>>For WindowIndex from 0 to (DF_SEQ_CHANNEL_MAX-1)
8318>>>>>>>>
8318>>>>>>>    Move 0 to giSeqChannelList[WindowIndex]
8319>>>>>>>Loop
8320>>>>>>>>
8320>>>>>>>
8320>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
8321>>>>>>>
8321>>>>>>>Function Seq_Channel_Mode Global Integer iChannel Returns Integer
8323>>>>>>>    Function_Return giSeqChannelList[iChannel]
8324>>>>>>>End_Function
8325>>>>>>>
8325>>>>>>>Procedure Set Seq_Channel_Mode Global Integer iChannel Integer iMode
8327>>>>>>>    Move iMode to giSeqChannelList[iChannel]
8328>>>>>>>End_Procedure
8329>>>>>>>
8329>>>>>>>Function Seq_New_Channel Global Returns Integer
8331>>>>>>>    Integer iObject iChannel
8331>>>>>>>    
8331>>>>>>>    Move DF_SEQ_START_CHANNEL to iChannel
8332>>>>>>>    
8332>>>>>>>    While (iChannel < DF_SEQ_CHANNEL_MAX)
8336>>>>>>>        If (Seq_Channel_Mode(iChannel) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8338>>>>>>>            Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OPEN
8339>>>>>>>            Function_Return iChannel
8340>>>>>>>        End
8340>>>>>>>>
8340>>>>>>>        
8340>>>>>>>        Increment iChannel
8341>>>>>>>    Loop
8342>>>>>>>>
8342>>>>>>>    
8342>>>>>>>    // wrap back to beginning
8342>>>>>>>    Move 0 to iChannel
8343>>>>>>>    
8343>>>>>>>    While (iChannel < DF_SEQ_START_CHANNEL)
8347>>>>>>>        If (Seq_Channel_Mode(iChannel) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8349>>>>>>>            Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OPEN
8350>>>>>>>            Function_Return iChannel
8351>>>>>>>        End
8351>>>>>>>>
8351>>>>>>>        
8351>>>>>>>        Increment iChannel
8352>>>>>>>    Loop
8353>>>>>>>>
8353>>>>>>>    
8353>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
8354>>>>>>>End_Function
8355>>>>>>>
8355>>>>>>>Procedure Seq_Release_Channel Global Integer iChannel
8357>>>>>>>    If ((iChannel >= DF_SEQ_CHANNEL_MIN) and (iChannel <= DF_SEQ_CHANNEL_MAX)) Begin
8359>>>>>>>        Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_CLOSED
8360>>>>>>>    End
8360>>>>>>>>
8360>>>>>>>End_Procedure
8361>>>>>>>
8361>>>>>>>Function Seq_Open_Input_Channel Global String sChannel Returns Integer
8363>>>>>>>    Integer iChannel
8363>>>>>>>    
8363>>>>>>>    Move (Seq_New_Channel()) to iChannel
8364>>>>>>>    
8364>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8366>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8368>>>>>>>            Error DFERR_CANT_OPEN_INPUT_FILE (sChannel + ":" *C_$NoOpenChannels)
8369>>>>>>>>
8369>>>>>>>        End
8369>>>>>>>>
8369>>>>>>>        Function_Return iChannel
8370>>>>>>>    End
8370>>>>>>>>
8370>>>>>>>    
8370>>>>>>>    Move False to Err
8371>>>>>>>    Direct_Input channel iChannel sChannel
8373>>>>>>>    
8373>>>>>>>    If (Err) Begin
8375>>>>>>>        Send Seq_Release_Channel iChannel
8376>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8377>>>>>>>    End
8377>>>>>>>>
8377>>>>>>>    
8377>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_INPUT
8378>>>>>>>    
8378>>>>>>>    Function_Return iChannel
8379>>>>>>>End_Function
8380>>>>>>>
8380>>>>>>>Function Seq_Open_Output_Channel Global String sChannel Returns Integer
8382>>>>>>>    Integer iChannel
8382>>>>>>>    
8382>>>>>>>    Move (Seq_New_Channel()) to iChannel
8383>>>>>>>    
8383>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8385>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8387>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (sChannel + ":" *C_$ChannelNotAvailable)
8388>>>>>>>>
8388>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to iChannel
8389>>>>>>>        End
8389>>>>>>>>
8389>>>>>>>        
8389>>>>>>>        Function_Return iChannel
8390>>>>>>>    End
8390>>>>>>>>
8390>>>>>>>    
8390>>>>>>>    Move False to Err
8391>>>>>>>    Direct_Output channel iChannel sChannel
8393>>>>>>>    
8393>>>>>>>    If (Err) Begin
8395>>>>>>>        Send Seq_Release_Channel iChannel
8396>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8397>>>>>>>    End
8397>>>>>>>>
8397>>>>>>>    
8397>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OUTPUT
8398>>>>>>>    
8398>>>>>>>    Function_Return iChannel
8399>>>>>>>End_Function
8400>>>>>>>
8400>>>>>>>Function Seq_Append_Output_Channel Global String sChannel Returns Integer
8402>>>>>>>    Integer iChannel
8402>>>>>>>    
8402>>>>>>>    Move (Seq_New_Channel()) to iChannel
8403>>>>>>>    
8403>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8405>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8407>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (sChannel + ":" *C_$ChannelNotAvailable)
8408>>>>>>>>
8408>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to iChannel
8409>>>>>>>        End
8409>>>>>>>>
8409>>>>>>>        
8409>>>>>>>        Function_Return iChannel
8410>>>>>>>    End
8410>>>>>>>>
8410>>>>>>>    
8410>>>>>>>    Move False to Err
8411>>>>>>>    Append_Output channel iChannel sChannel
8413>>>>>>>    
8413>>>>>>>    If (Err) Begin
8415>>>>>>>        Send Seq_Release_Channel iChannel
8416>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8417>>>>>>>    End
8417>>>>>>>>
8417>>>>>>>    
8417>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OUTPUT
8418>>>>>>>    
8418>>>>>>>    Function_Return iChannel
8419>>>>>>>End_Function
8420>>>>>>>
8420>>>>>>>Procedure Seq_Close_Channel Global Integer iChannel
8422>>>>>>>    Integer iMode
8422>>>>>>>    
8422>>>>>>>    If ((iChannel >= DF_SEQ_CHANNEL_MIN) and (iChannel <= DF_SEQ_CHANNEL_MAX)) Begin
8424>>>>>>>        Move (Seq_Channel_Mode(iChannel)) to iMode
8425>>>>>>>        
8425>>>>>>>        If (iMode = DF_SEQ_CHANNEL_MODE_OUTPUT) Begin
8427>>>>>>>            Close_Output channel iChannel
8429>>>>>>>        End
8429>>>>>>>>
8429>>>>>>>        Else If (iMode = DF_SEQ_CHANNEL_MODE_INPUT) Begin
8432>>>>>>>            Close_Input channel iChannel
8434>>>>>>>        End
8434>>>>>>>>
8434>>>>>>>        // If channel not open, release it! No (fatal) Error.
8434>>>>>>>        Send Seq_Release_Channel iChannel
8435>>>>>>>    End
8435>>>>>>>>
8435>>>>>>>End_Procedure
8436>>>>>Use GlobalFunctionsProcedures.pkg
8436>>>>>
8436>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
8436>>>>>Register_Function VdfSystemDfPath   Returns String
8436>>>>>Register_Function VdfSystemMakePath Returns String
8436>>>>>
8436>>>>>Enum_List
8436>>>>>    Define wsWorkspaceOpened       // WS opened ok
8436>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
8436>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
8436>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
8436>>>>>    Define wsFileListEmpty         // The FileList entry was empty
8436>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
8436>>>>>End_Enum_List
8436>>>>>
8436>>>>>
8436>>>>>Define INVALID_HANDLE_VALUE for -1
8436>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
8436>>>>>
8436>>>>>
8436>>>>>// Wide version
8436>>>>>External_Function winFindFirstFileW "FindFirstFileW" Kernel32.dll ;    WString wFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8437>>>>>
8437>>>>>// Wrapper Function winFindFirstFile
8437>>>>>Function winFindFirstFile Global ;    String  sFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8439>>>>>    
8439>>>>>    Handle  hResult
8439>>>>>    Integer iVoid iFilenameSize iAltFilenameSize
8439>>>>>    Integer iSizeOfStructWithoutStrings
8439>>>>>    String  sFileName sAlternateFileName
8439>>>>>    WString wFileName wAlternateFileName
8439>>>>>    Pointer pWFD
8439>>>>>    tWin32FindDataW tWFD
8439>>>>>    tWin32FindDataW tWFD
8439>>>>>    
8439>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8439>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8439>>>>>
8439>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8440>>>>>    Move (AddressOf(tWFD)) to pWFD
8441>>>>>    
8441>>>>>    // Call the function
8441>>>>>    Move (winFindFirstFileW (sFileSpec, pWFD)) to hResult
8442>>>>>
8442>>>>>    // Copy the struct contents back to the incoming one.
8442>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8443>>>>>    
8443>>>>>    // But do the strings separately and convert them to UTF8
8443>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8444>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8445>>>>>    
8445>>>>>    // Extend string with 0 to the maximum number of characters
8445>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8448>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8451>>>>>        
8451>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8452>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8453>>>>>    
8453>>>>>    Function_Return hResult
8454>>>>>End_Function
8455>>>>>
8455>>>>>// When used directly, be sure to use WString types (UTF16).
8455>>>>>External_Function winFindNextFileW "FindNextFileW" Kernel32.dll ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8456>>>>>
8456>>>>>// Wrapper Function winFindNextFile
8456>>>>>Function winFindNextFile Global ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8458>>>>>    
8458>>>>>    Integer iResult iVoid iFilenameSize iAltFilenameSize
8458>>>>>    Integer iSizeOfStructWithoutStrings
8458>>>>>    String  sFileName sAlternateFileName
8458>>>>>    WString wFileName wAlternateFileName
8458>>>>>    Pointer pWFD
8458>>>>>    tWin32FindDataW tWFD
8458>>>>>    tWin32FindDataW tWFD
8458>>>>>
8458>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8458>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8458>>>>>
8458>>>>>    // Copy the struct to a local struct that can be modified to UTF-16.
8458>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8459>>>>>    Move (AddressOf(tWFD)) to pWFD
8460>>>>>    Move (MemCopy(pWFD, lpsWin32FindData, iSizeOfStructWithoutStrings)) to iVoid
8461>>>>>    // But do the strings separately and convert them to wide strings (UTF16).
8461>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings)) to wFileName
8462>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH)) to wAlternateFileName
8463>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings, AddressOf(wFileName), SizeOfString(wFileName)*2)) to iVoid
8464>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2), AddressOf(wAlternateFileName), SizeOfString(wAlternateFileName)*2)) to iVoid
8465>>>>>    
8465>>>>>    // Call the function
8465>>>>>    Move (winFindNextFileW (hFindFile, pWFD)) to iResult  
8466>>>>>
8466>>>>>    // Copy the struct contents back to the incoming one.
8466>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8467>>>>>    
8467>>>>>    // But do the strings separately and convert them to UTF8
8467>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8468>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8469>>>>>    
8469>>>>>    // Extend string with 0 to the maximum number of characters
8469>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8472>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8475>>>>>        
8475>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8476>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8477>>>>>    
8477>>>>>    Function_Return iResult
8478>>>>>End_Function
8479>>>>>
8479>>>>>
8479>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
8480>>>>>
8480>>>>>Function DoesFileExist Global String sFilename Returns Boolean
8482>>>>>    tWin32FindDataW Win32FindData
8482>>>>>    tWin32FindDataW Win32FindData
8482>>>>>    String sMask
8482>>>>>    Integer iVoid
8482>>>>>    Handle hFileFind
8482>>>>>    
8482>>>>>    Move (winFindFirstFileW(sFilename, AddressOf(Win32FindData))) to hFileFind
8483>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
8485>>>>>        Move (winFindClose(hFileFind)) to iVoid
8486>>>>>    End
8486>>>>>>
8486>>>>>    
8486>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
8487>>>>>End_Function
8488>>>>>
8488>>>>>
8488>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cIniFile.pkg)
8488>>>>>>>Use Dll.pkg
8488>>>>>>>Use errornum.inc
8488>>>>>>>Use LanguageText.pkg
8488>>>>>>>Use GlobalFunctionsProcedures.pkg
8488>>>>>>>Use seq_chnl.pkg
8488>>>>>>>Use CharTranslate.pkg
8488>>>>>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cCharTranslate.pkg)
8488>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files\DataFlex 25.0\Pkg\Variant.pkg)
8488>>>>>>>>>>>Use ui
8488>>>>>>>>>>>Use errornum.inc
8488>>>>>>>>>>>
8488>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
8488>>>>>>>>>>>
8488>>>>>>>>>>>
8488>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
8489>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
8490>>>>>>>>>>>
8490>>>>>>>>>>>//  Returns the variant type
8490>>>>>>>>>>>Function VariantType Global Variant vVal Returns Integer
8492>>>>>>>>>>>    Function_Return (DeRefW(AddressOf(vVal),0))
8493>>>>>>>>>>>End_Function
8494>>>>>>>>>>>
8494>>>>>>>>>>>
8494>>>>>>>>>>>// Returns the character length of the variant string. 
8494>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
8496>>>>>>>>>>>    Integer iLen iType
8496>>>>>>>>>>>
8496>>>>>>>>>>>    Move (VariantType(bStr)) to iType
8497>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
8499>>>>>>>>>>>        Function_Return 0
8500>>>>>>>>>>>    End
8500>>>>>>>>>>>>
8500>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
8502>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
8503>>>>>>>>>>>>
8503>>>>>>>>>>>        Function_Return 0
8504>>>>>>>>>>>    End
8504>>>>>>>>>>>>
8504>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(AddressOf(bStr),8))) to iLen
8505>>>>>>>>>>>    Function_Return iLen
8506>>>>>>>>>>>End_Function
8507>>>>>>>>>>>
8507>>>>>>>>>>>
8507>>>>>>>>>>>// returns true if char string in the buffer can fit into a string.
8507>>>>>>>>>>>// Changed this to always return True, because the Max_Argument_Size limitation has been removed.
8507>>>>>>>>>>>Function ValidStringBufferLength Global Pointer pData Returns Boolean
8509>>>>>>>>>>>    Function_Return True
8510>>>>>>>>>>>End_Function
8511>>>>>>>>>>>
8511>>>>>>>>>>>
8511>>>>>>>>>Use CharTranslate.pkg
8511>>>>>>>>>Use GlobalFunctionsProcedures.pkg
8511>>>>>>>>>
8511>>>>>>>>>// special for UTF16, which is really not a code page at all
8511>>>>>>>>>Define CP_UTF16 for -1
8511>>>>>>>>>
8511>>>>>>>>>Class cCharTranslate is a cObject
8512>>>>>>>>>    
8512>>>>>>>>>    
8512>>>>>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
8512>>>>>>>>>    
8512>>>>>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
8512>>>>>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
8512>>>>>>>>>    Function Utf16FromBuffer  Pointer pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Pointer
8514>>>>>>>>>        Pointer pWideBuf
8514>>>>>>>>>        Integer iWideBufLen iStrLen
8514>>>>>>>>>        Move 0 to pWideBuf
8515>>>>>>>>>        Move 0 to iLen
8516>>>>>>>>>        If (pMultiCharBuffer) Begin
8518>>>>>>>>>            Move (CStringSize(pMultiCharBuffer)) to iStrLen
8519>>>>>>>>>            If (iStrLen) Begin
8521>>>>>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
8522>>>>>>>>>                If (iLen=0) Begin
8524>>>>>>>>>                    Function_Return 0
8525>>>>>>>>>                End
8525>>>>>>>>>>
8525>>>>>>>>>            End
8525>>>>>>>>>>
8525>>>>>>>>>        End
8525>>>>>>>>>>
8525>>>>>>>>>        Function_Return pWideBuf
8526>>>>>>>>>    End_Function
8527>>>>>>>>>    
8527>>>>>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Pointer
8529>>>>>>>>>        Pointer pValue
8529>>>>>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to pValue
8530>>>>>>>>>        Function_Return pValue
8531>>>>>>>>>    End_Function
8532>>>>>>>>>    
8532>>>>>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
8532>>>>>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
8532>>>>>>>>>    Function Utf16ToBuffer Pointer pWideBuf Integer eCharType Integer iLen Returns Pointer
8534>>>>>>>>>        Pointer pRetBuf
8534>>>>>>>>>        Integer iRetBufLen
8534>>>>>>>>>        Move 0 to pRetBuf
8535>>>>>>>>>        If (pWideBuf and iLen) Begin
8537>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
8538>>>>>>>>>            If (iRetBufLen=0) Begin
8540>>>>>>>>>                Function_Return 0
8541>>>>>>>>>            End
8541>>>>>>>>>>
8541>>>>>>>>>        End
8541>>>>>>>>>>
8541>>>>>>>>>        Function_Return pRetBuf
8542>>>>>>>>>    End_Function
8543>>>>>>>>>    
8543>>>>>>>>>    Function Utf16ToStr Pointer pWideBuf Integer eCharType Integer iLen Returns String
8545>>>>>>>>>        String sValue
8545>>>>>>>>>        Pointer pValue
8545>>>>>>>>>        Boolean bOk
8545>>>>>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to pValue
8546>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8548>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8549>>>>>>>>>>
8549>>>>>>>>>        End
8549>>>>>>>>>>
8549>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8550>>>>>>>>>        Move (Free(pValue)) to bOk
8551>>>>>>>>>        Function_Return sValue
8552>>>>>>>>>    End_Function
8553>>>>>>>>>    
8553>>>>>>>>>    
8553>>>>>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
8553>>>>>>>>>    
8553>>>>>>>>>    Function Utf8FromBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8555>>>>>>>>>        Pointer pWideBuf
8555>>>>>>>>>        Pointer pUtf8Buf
8555>>>>>>>>>        Integer iLen iMultiBufLen
8555>>>>>>>>>        Boolean bOk
8555>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
8556>>>>>>>>>        If (iLen=0) Begin
8558>>>>>>>>>            Function_Return 0
8559>>>>>>>>>        End
8559>>>>>>>>>>
8559>>>>>>>>>        Move 0 to pUtf8Buf
8560>>>>>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
8561>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8562>>>>>>>>>        Function_Return pUtf8Buf
8563>>>>>>>>>    End_Function
8564>>>>>>>>>    
8564>>>>>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Pointer
8566>>>>>>>>>        Pointer pValue
8566>>>>>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to pValue
8567>>>>>>>>>        Function_Return pValue
8568>>>>>>>>>    End_Function
8569>>>>>>>>>    
8569>>>>>>>>>    Function Utf8ToBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8571>>>>>>>>>        Pointer pRetBuf pWideBuf
8571>>>>>>>>>        Integer iWideBufLen
8571>>>>>>>>>        Integer iRetBufLen
8571>>>>>>>>>        Boolean bOk
8571>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
8572>>>>>>>>>        If (iWideBufLen=0) Begin
8574>>>>>>>>>            Function_Return 0
8575>>>>>>>>>        End
8575>>>>>>>>>>
8575>>>>>>>>>        Move 0 to pRetBuf
8576>>>>>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
8577>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8578>>>>>>>>>        Function_Return pRetBuf
8579>>>>>>>>>    End_Function
8580>>>>>>>>>    
8580>>>>>>>>>    Function Utf8ToStr Pointer pWideBuf Integer eCharType Returns String
8582>>>>>>>>>        String sValue
8582>>>>>>>>>        Pointer pValue
8582>>>>>>>>>        Boolean bOk
8582>>>>>>>>>        Get Utf8ToBuffer pWideBuf eCharType to pValue
8583>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8585>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8586>>>>>>>>>>
8586>>>>>>>>>        End
8586>>>>>>>>>>
8586>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8587>>>>>>>>>        Move (Free(pValue)) to bOk
8588>>>>>>>>>        Function_Return sValue
8589>>>>>>>>>    End_Function
8590>>>>>>>>>    
8590>>>>>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
8590>>>>>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
8590>>>>>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
8590>>>>>>>>>    
8590>>>>>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
8590>>>>>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Pointer
8592>>>>>>>>>        Pointer pBSTR pRetStr
8592>>>>>>>>>        Integer iLen iBufLen
8592>>>>>>>>>        Boolean bOk
8592>>>>>>>>>        Move 0 to pRetStr
8593>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8594>>>>>>>>>        If (iLen) Begin
8596>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8597>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8598>>>>>>>>>        End
8598>>>>>>>>>>
8598>>>>>>>>>        Function_Return pRetStr
8599>>>>>>>>>    End_Function
8600>>>>>>>>>    
8600>>>>>>>>>    // Create string from variant string. data buffer is encoded by eCharType
8600>>>>>>>>>    
8600>>>>>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
8602>>>>>>>>>        String sValue
8602>>>>>>>>>        Pointer pValue
8602>>>>>>>>>        Boolean bOk
8602>>>>>>>>>        Get VariantStrToBuffer vValue eCharType to pValue
8603>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8605>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8606>>>>>>>>>>
8606>>>>>>>>>        End
8606>>>>>>>>>>
8606>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8607>>>>>>>>>        Move (Free(pValue)) to bOk
8608>>>>>>>>>        Function_Return sValue
8609>>>>>>>>>    End_Function
8610>>>>>>>>>    
8610>>>>>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
8610>>>>>>>>>    
8610>>>>>>>>>    Function VariantStrFromBuffer Pointer pSource Integer eCodeType Returns Variant
8612>>>>>>>>>        Variant vValue
8612>>>>>>>>>        Pointer pvValue
8612>>>>>>>>>        Boolean bOk
8612>>>>>>>>>        Pointer pWStr
8612>>>>>>>>>        Move "" to vValue
8613>>>>>>>>>        If (pSource) Begin
8615>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8615>>>>>>>>>            Move 0 to pWStr
8616>>>>>>>>>            //Convert the Ansi string to Unicode
8616>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, pSource, CStringSize(pSource), AddressOf(pWStr))) to bOk
8617>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8617>>>>>>>>>            Move 0 to vValue
8618>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8619>>>>>>>>>            //Change the Variant type to VT_BSTR
8619>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8620>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8620>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8621>>>>>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8621>>>>>>>>>            Move (Free(pWStr)) to bOk
8622>>>>>>>>>        End
8622>>>>>>>>>>
8622>>>>>>>>>        Function_Return vValue
8623>>>>>>>>>    End_Function
8624>>>>>>>>>    
8624>>>>>>>>>    // Create variant string from data string. data string is encoded by eCharType
8624>>>>>>>>>    
8624>>>>>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
8626>>>>>>>>>        Variant vValue
8626>>>>>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
8627>>>>>>>>>        Function_Return vValue
8628>>>>>>>>>    End_Function
8629>>>>>>>>>    
8629>>>>>>>>>    // Create buffer of utf16 data from variant.
8629>>>>>>>>>    // Returns newly created memory address and length (by reference)
8629>>>>>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Pointer
8631>>>>>>>>>        Pointer pBSTR pRetStr
8631>>>>>>>>>        Boolean bOk
8631>>>>>>>>>        Move 0 to pRetStr
8632>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8633>>>>>>>>>        If (iLen) Begin
8635>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8636>>>>>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
8637>>>>>>>>>            Move (MemCopy(pRetStr,pBSTR,(iLen+1 * 2))) to bOk
8638>>>>>>>>>        End
8638>>>>>>>>>>
8638>>>>>>>>>        Function_Return pRetStr
8639>>>>>>>>>    End_Function
8640>>>>>>>>>    
8640>>>>>>>>>    // Create variant from buffer of utf16 data
8640>>>>>>>>>    Function VariantStrFromUTF16 Pointer pSource Returns Variant
8642>>>>>>>>>        Variant vValue
8642>>>>>>>>>        Pointer pvValue
8642>>>>>>>>>        Boolean bOk
8642>>>>>>>>>        Move "" to vValue
8643>>>>>>>>>        If (pSource) Begin
8645>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8645>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8645>>>>>>>>>            Move 0 to vValue
8646>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8647>>>>>>>>>            //Change the Variant type to VT_BSTR
8647>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8648>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8648>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pSource))) to bOk
8649>>>>>>>>>        End
8649>>>>>>>>>>
8649>>>>>>>>>        Function_Return vValue
8650>>>>>>>>>    End_Function
8651>>>>>>>>>    
8651>>>>>>>>>    // Create Uchar array from variant string.
8651>>>>>>>>>    // Data buffer is encoded by eCharType
8651>>>>>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
8653>>>>>>>>>        Pointer pBSTR pRetStr
8653>>>>>>>>>        Integer iLen iBufLen
8653>>>>>>>>>        Boolean bOk
8653>>>>>>>>>        UChar[] UC1
8654>>>>>>>>>        Move 0 to pRetStr
8655>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8656>>>>>>>>>        If (iLen) Begin
8658>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8659>>>>>>>>>            If (eCharType=CP_UTF16) Begin
8661>>>>>>>>>                Move (iLen*2) to iBufLen
8662>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8663>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pBSTR,iBufLen)) to bOk
8664>>>>>>>>>            End
8664>>>>>>>>>>
8664>>>>>>>>>            Else Begin
8665>>>>>>>>>                Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8666>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8667>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
8668>>>>>>>>>                Move (Free(pRetStr)) to bOk
8669>>>>>>>>>            End
8669>>>>>>>>>>
8669>>>>>>>>>        End
8669>>>>>>>>>>
8669>>>>>>>>>        Function_Return UC1
8670>>>>>>>>>    End_Function
8671>>>>>>>>>    
8671>>>>>>>>>    // Create variant string from UChar array. data is encoded by eCharType
8671>>>>>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
8673>>>>>>>>>        Variant vValue
8673>>>>>>>>>        Pointer pvValue
8673>>>>>>>>>        Boolean bOk
8673>>>>>>>>>        Pointer pWStr
8673>>>>>>>>>        Move "" to vValue
8674>>>>>>>>>        
8674>>>>>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8674>>>>>>>>>        Move 0 to pWStr
8675>>>>>>>>>        //Convert the Ansi string to Unicode
8675>>>>>>>>>        If (eCodeType=CP_UTF16) Begin
8677>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8678>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8679>>>>>>>>>            Move (AddressOf(ucSource)) to pWStr
8680>>>>>>>>>        End
8680>>>>>>>>>>
8680>>>>>>>>>        Else Begin
8681>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, AddressOf(ucSource), SizeOfArray(ucSource), AddressOf(pWStr))) to bOk
8682>>>>>>>>>        End
8682>>>>>>>>>>
8682>>>>>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8682>>>>>>>>>        Move 0 to vValue
8683>>>>>>>>>        Move (AddressOf(vValue)) to pvValue
8684>>>>>>>>>        //Change the Variant type to VT_BSTR
8684>>>>>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8685>>>>>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8685>>>>>>>>>        Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8686>>>>>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8686>>>>>>>>>        If (eCodeType<>CP_UTF16) Begin
8688>>>>>>>>>            Move (Free(pWStr)) to bOk
8689>>>>>>>>>        End
8689>>>>>>>>>>
8689>>>>>>>>>        Function_Return vValue
8690>>>>>>>>>    End_Function
8691>>>>>>>>>    
8691>>>>>>>>>    
8691>>>>>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
8691>>>>>>>>>    // a new UChar array with to-encoding
8691>>>>>>>>>    
8691>>>>>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
8693>>>>>>>>>        Pointer pFromBuf pToBuf
8693>>>>>>>>>        Integer iBytes iChars
8693>>>>>>>>>        Boolean bOk
8693>>>>>>>>>        
8693>>>>>>>>>        Move (SizeOfArray(UCharData)) to iBytes
8694>>>>>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
8696>>>>>>>>>            Function_Return UCharData
8697>>>>>>>>>        End
8697>>>>>>>>>>
8697>>>>>>>>>        
8697>>>>>>>>>        If (iFromCP<>CP_UTF16) Begin
8699>>>>>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
8700>>>>>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to pFromBuf
8701>>>>>>>>>        End
8701>>>>>>>>>>
8701>>>>>>>>>        Else Begin
8702>>>>>>>>>            Move (iBytes/2) to iChars // if from is utf16
8703>>>>>>>>>        End
8703>>>>>>>>>>
8703>>>>>>>>>        
8703>>>>>>>>>        If (iToCP<>CP_UTF16) Begin
8705>>>>>>>>>            If (iFromCP=CP_UTF16) Begin
8707>>>>>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to pToBuf
8708>>>>>>>>>            End
8708>>>>>>>>>>
8708>>>>>>>>>            Else Begin
8709>>>>>>>>>                Get Utf16ToBuffer pFromBuf iToCP iChars to pToBuf
8710>>>>>>>>>                Move (Free(pFromBuf)) to bOk
8711>>>>>>>>>            End
8711>>>>>>>>>>
8711>>>>>>>>>            Move (CStringSize(pToBuf)) to iBytes
8712>>>>>>>>>        End
8712>>>>>>>>>>
8712>>>>>>>>>        Else Begin
8713>>>>>>>>>            Move (iChars*2) to iBytes
8714>>>>>>>>>            Move pFromBuf to pToBuf
8715>>>>>>>>>        End
8715>>>>>>>>>>
8715>>>>>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
8716>>>>>>>>>        Move (MemCopy(AddressOf(UCharData),pToBuf,iBytes)) to bOk
8717>>>>>>>>>        Move (Free(pToBuf)) to bOk
8718>>>>>>>>>        Function_Return UCharData
8719>>>>>>>>>    End_Function
8720>>>>>>>>>    
8720>>>>>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and
8720>>>>>>>>>    // Variant strings. Binary data is always buffer
8720>>>>>>>>>    
8720>>>>>>>>>    Function Base64EncodeToStr Pointer pBinaryData Integer iBinaryLen Returns String
8722>>>>>>>>>        Pointer pBase64
8722>>>>>>>>>        String sResult
8722>>>>>>>>>        Integer iVoid
8722>>>>>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
8723>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
8724>>>>>>>>>        Move (Free(pBase64)) to iVoid
8725>>>>>>>>>        Function_Return sResult
8726>>>>>>>>>    End_Function
8727>>>>>>>>>    
8727>>>>>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Pointer
8729>>>>>>>>>        Pointer pBinaryData
8729>>>>>>>>>        String sBinary
8729>>>>>>>>>        Integer iVoid
8729>>>>>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
8730>>>>>>>>>        Function_Return pBinaryData
8731>>>>>>>>>    End_Function
8732>>>>>>>>>    
8732>>>>>>>>>    Function Base64EncodeToVariantStr Pointer pBinaryData Integer iBinaryLen Returns Variant
8734>>>>>>>>>        Pointer pBase64
8734>>>>>>>>>        Variant vVar
8734>>>>>>>>>        Integer iBase64Len iVoid
8734>>>>>>>>>        If (pBinaryData and iBinaryLen) Begin
8736>>>>>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to pBase64
8737>>>>>>>>>            Get  VariantStrFromBuffer pBase64 CP_ACP to vVar
8738>>>>>>>>>            Move (Free(pBase64)) to iVoid
8739>>>>>>>>>        End
8739>>>>>>>>>>
8739>>>>>>>>>        Function_Return vVar
8740>>>>>>>>>    End_Function
8741>>>>>>>>>    
8741>>>>>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Pointer
8743>>>>>>>>>        Pointer pBase64 pBinaryData
8743>>>>>>>>>        Integer iVoid
8743>>>>>>>>>        Move 0 to iBinaryLen
8744>>>>>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to pBase64
8745>>>>>>>>>        If (pBase64) Begin
8747>>>>>>>>>            Move (Base64Decode(pBase64,&iBinaryLen)) to pBinaryData
8748>>>>>>>>>            Move (Free(pBase64)) to iVoid
8749>>>>>>>>>        End
8749>>>>>>>>>>
8749>>>>>>>>>        Function_Return pBinaryData
8750>>>>>>>>>    End_Function
8751>>>>>>>>>    
8751>>>>>>>>>    // base 64 Encode from Uchar array to a Uchar array
8751>>>>>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
8753>>>>>>>>>        Pointer pBase64
8753>>>>>>>>>        Integer iLen
8753>>>>>>>>>        Boolean bOk
8753>>>>>>>>>        
8753>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8754>>>>>>>>>        If (iLen) Begin
8756>>>>>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to pBase64
8757>>>>>>>>>            Move (CStringSize(pBase64)) to iLen
8758>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8759>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pBase64,iLen)) to bOk
8760>>>>>>>>>            Move (Free(pBase64)) to bOk
8761>>>>>>>>>        End
8761>>>>>>>>>>
8761>>>>>>>>>        Function_Return UCharData
8762>>>>>>>>>    End_Function
8763>>>>>>>>>    
8763>>>>>>>>>    // base 64 Decode from Uchar array to a Uchar array
8763>>>>>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
8765>>>>>>>>>        Pointer pData
8765>>>>>>>>>        Integer iLen
8765>>>>>>>>>        Boolean bOk
8765>>>>>>>>>        
8765>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8766>>>>>>>>>        If (iLen) Begin
8768>>>>>>>>>            Move 0 to UCharData[iLen]
8769>>>>>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to pData
8770>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8771>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pData,iLen)) to bOk
8772>>>>>>>>>            Move (Free(pData)) to bOk
8773>>>>>>>>>        End
8773>>>>>>>>>>
8773>>>>>>>>>        Function_Return UCharData
8774>>>>>>>>>    End_Function
8775>>>>>>>>>    
8775>>>>>>>>>End_Class
8776>>>>>>>>>
8776>>>>>>>>>
8776>>>>>>>
8776>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
8776>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
8776>>>>>>>
8776>>>>>>>
8776>>>>>>>External_Function WritePrivateProfileStringW "WritePrivateProfileStringW" Kernel32.dll ;    WString sSection ;    WString sKeyName ;    WString sValue ;    WString sFileName ;    Returns Integer
8777>>>>>>>
8777>>>>>>>
8777>>>>>>>// When called directly, be sure to use WString types.
8777>>>>>>>External_Function GetPrivateProfileStringW "GetPrivateProfileStringW" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    WString lpFileName ;    Returns Integer
8778>>>>>>>
8778>>>>>>>External_Function WritePrivateProfileStringA "WritePrivateProfileStringA" Kernel32.dll ;    String sSection ;    String sKeyName ;    String sValue ;    String sFileName ;    Returns Integer
8779>>>>>>>    
8779>>>>>>>// When called directly, be sure to use String types.
8779>>>>>>>External_Function GetPrivateProfileStringA "GetPrivateProfileStringA" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    String lpFileName ;    Returns Integer
8780>>>>>>>    
8780>>>>>>>// Wrapper redirecting direct access to the wide for backwards compatibility (parameters will be auto converted)
8780>>>>>>>Define WritePrivateProfileString for WritePrivateProfileStringW
8780>>>>>>>    
8780>>>>>>>
8780>>>>>>>// Wrapper Function GetPrivateProfileString for backwards compatibility
8780>>>>>>>Function GetPrivateProfileString Global ;    Pointer pSection ;    Pointer pKeyName ;    Pointer pDefault ;    Pointer lpsValue ;    Integer nSize ;    String  sFileName ;    Returns Integer
8782>>>>>>>    
8782>>>>>>>    Integer iResult
8782>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8782>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8782>>>>>>>
8782>>>>>>>    Send StringToWide pSection (&uwSection)
8783>>>>>>>    Send StringToWide pKeyName (&uwKeyName)
8784>>>>>>>    Send StringToWide pDefault (&uwDefault)    
8785>>>>>>>    Send StringToWide (AddressOf(sFileName)) (&uwFileName)
8786>>>>>>>                           
8786>>>>>>>    Send WideSetBuffer lpsValue (AddressOf(nSize)) (&uwValue) 
8787>>>>>>>       
8787>>>>>>>    Move (GetPrivateProfileStringW (uwSection.lpUText, uwKeyName.lpUText, uwDefault.lpUText, uwValue.lpUText, nSize, uwFileName.lpUText)) to iResult
8788>>>>>>>        
8788>>>>>>>    Send WideToStringSized (&uwValue) lpsValue iResult      // iResult is number of characters
8789>>>>>>>    
8789>>>>>>>    Function_Return iResult
8790>>>>>>>End_Function
8791>>>>>>> 
8791>>>>>>>
8791>>>>>>>Class cIniFile is a cObject
8792>>>>>>>    Procedure Construct_Object
8794>>>>>>>        Forward Send Construct_Object
8796>>>>>>>        
8796>>>>>>>        
8796>>>>>>>        // Set to false to use the narrow windows API's to access the ini files. This allows UTF-8 data to be written
8796>>>>>>>        // and read (except if the file is stored as UTF-16) but has the downside of not supporting unicode file paths.
8796>>>>>>>        Property Boolean pbWideAPI True
8797>>>>>>>        
8797>>>>>>>        // Set to true to save the ini file as UTF-16LE (with a BOM). This allows unicode data to be saved properly
8797>>>>>>>        // using the wide API's. Note that pbWideAPI should be true to use this property. Existing ini files will be
8797>>>>>>>        // converted on first write (WriteString).
8797>>>>>>>        Property Boolean pbStoreAsUTF16 False
8798>>>>>>>        
8798>>>>>>>        Property String psPrivate_FileName ""
8799>>>>>>>        Property Boolean pbPrivate_FirstWrite True
8800>>>>>>>    End_Procedure
8801>>>>>>>    
8801>>>>>>>    Procedure Set psFileName String sVal
8803>>>>>>>        Set pbPrivate_FirstWrite to True
8804>>>>>>>        Set psPrivate_FileName to sVal
8805>>>>>>>    End_Procedure
8806>>>>>>>    
8806>>>>>>>    Function psFileName Returns String
8808>>>>>>>        Function_Return (psPrivate_FileName(Self))
8809>>>>>>>    End_Function
8810>>>>>>>    
8810>>>>>>>    Procedure InitFile
8812>>>>>>>        Boolean bExists bHasBom
8812>>>>>>>        Integer iChnl
8812>>>>>>>        UChar[] ucData
8813>>>>>>>        Handle hoTranslate
8813>>>>>>>        
8813>>>>>>>        If (pbPrivate_FirstWrite(Self) and pbStoreAsUTF16(Self) and pbWideAPI(Self)) Begin
8815>>>>>>>            File_Exist (psPrivate_FileName(Self)) bExists
8816>>>>>>>            If (not(bExists)) Begin
8818>>>>>>>                //  Create the file with a UTF-16 BOM so
8818>>>>>>>                Move (Seq_New_Channel()) to iChnl
8819>>>>>>>                If (iChnl >= 0) Begin
8821>>>>>>>                    Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8823>>>>>>>                    Write channel iChnl C_BOM_UTF16LE
8825>>>>>>>                    Close_Output channel iChnl
8827>>>>>>>                    Send Seq_Release_Channel iChnl
8828>>>>>>>                End
8828>>>>>>>>
8828>>>>>>>                Else If (iChnl = -1) Begin
8831>>>>>>>                    Error DFErr_Program "I/O Channel Error"
8832>>>>>>>>
8832>>>>>>>                End
8832>>>>>>>>
8832>>>>>>>                Else If (iChnl = -2) Begin
8835>>>>>>>                    Error DFErr_Program "No I/O Channel Available"
8836>>>>>>>>
8836>>>>>>>                End
8836>>>>>>>>
8836>>>>>>>            End
8836>>>>>>>>
8836>>>>>>>            Else Begin
8837>>>>>>>                //  Check for BOM
8837>>>>>>>                Move (Seq_New_Channel()) to iChnl
8838>>>>>>>                If (iChnl >= 0) Begin
8840>>>>>>>                    Direct_Input channel iChnl ("binary:" + psPrivate_FileName(Self))
8842>>>>>>>                    Read_Block channel iChnl ucData 2
8844>>>>>>>                    
8844>>>>>>>                    Move (SizeOfArray(ucData) >= 2 and ucData[0] = C_BOM_UTF16LEc1 and ucData[1] = C_BOM_UTF16LEc2) to bHasBom
8845>>>>>>>                    
8845>>>>>>>                    //  If no BOM we'll have to read the entire file to convert it
8845>>>>>>>                    If (not(bHasBom)) Begin
8847>>>>>>>                        Set_Channel_Position iChnl to 0
8848>>>>>>>>
8848>>>>>>>                        Read_Block ucData -1
8849>>>>>>>                    End
8849>>>>>>>>
8849>>>>>>>    
8849>>>>>>>                    Close_Input channel iChnl
8851>>>>>>>                    
8851>>>>>>>                    If (not(bHasBom)) Begin
8853>>>>>>>                        //  Convert thedata
8853>>>>>>>                        Get Create (RefClass(cCharTranslate)) to hoTranslate
8854>>>>>>>                        Get ConvertUCharArray of hoTranslate ucData CP_OEMCP CP_UTF16 to ucData
8855>>>>>>>                        
8855>>>>>>>                        //  Write out the UTF 16 file with BOM
8855>>>>>>>                        Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8857>>>>>>>                        Write channel iChnl C_BOM_UTF16LE
8859>>>>>>>                        
8859>>>>>>>                        Write channel iChnl ucData
8861>>>>>>>                        
8861>>>>>>>                        Close_Output channel iChnl
8863>>>>>>>                        
8863>>>>>>>                        Send Destroy of hoTranslate
8864>>>>>>>                    End
8864>>>>>>>>
8864>>>>>>>                    
8864>>>>>>>                    Send Seq_Release_Channel iChnl
8865>>>>>>>                End
8865>>>>>>>>
8865>>>>>>>                Else If (iChnl = -1) Begin
8868>>>>>>>                    Error DFErr_Program "I/O Channel Error"
8869>>>>>>>>
8869>>>>>>>                End
8869>>>>>>>>
8869>>>>>>>                Else If (iChnl = -2) Begin
8872>>>>>>>                    Error DFErr_Program "No I/O Channel Available"
8873>>>>>>>>
8873>>>>>>>                End
8873>>>>>>>>
8873>>>>>>>            End
8873>>>>>>>>
8873>>>>>>>            
8873>>>>>>>            Set pbPrivate_FirstWrite to False
8874>>>>>>>        End
8874>>>>>>>>
8874>>>>>>>    End_Procedure
8875>>>>>>>    
8875>>>>>>>    Procedure WriteString String sSection String sKey String sValue
8877>>>>>>>        Boolean bSuccess
8877>>>>>>>        String sFileName
8877>>>>>>>        
8877>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8879>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8880>>>>>>>>
8880>>>>>>>            Procedure_Return
8881>>>>>>>        End
8881>>>>>>>>
8881>>>>>>>        
8881>>>>>>>        Send InitFile
8882>>>>>>>        
8882>>>>>>>        // All parameters are Strings and are converted to WString upon invoking the external function.
8882>>>>>>>        If (pbWideAPI(Self)) Begin
8884>>>>>>>            Move (WritePrivateProfileStringW(sSection, sKey, sValue, psPrivate_FileName(Self))) to bSuccess
8885>>>>>>>        End
8885>>>>>>>>
8885>>>>>>>        Else Begin
8886>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8887>>>>>>>            Move (WritePrivateProfileStringA(sSection, sKey, sValue, sFilename)) to bSuccess 
8888>>>>>>>        End
8888>>>>>>>>
8888>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
8891>>>>>>>    End_Procedure
8892>>>>>>>    
8892>>>>>>>    
8892>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
8894>>>>>>>        Integer iNumChars iSizeValue
8894>>>>>>>        WString wValue wFileName wSection wKey wDefault
8894>>>>>>>        String sFileName sValue
8894>>>>>>>        
8894>>>>>>>        Move 2047 to iSizeValue
8895>>>>>>>        Move (Repeat(" ", iSizeValue)) to sValue
8896>>>>>>>        
8896>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8898>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8899>>>>>>>>
8899>>>>>>>            Function_Return ''
8900>>>>>>>        End
8900>>>>>>>>
8900>>>>>>>        
8900>>>>>>>        If (pbWideAPI(Self)) Begin
8902>>>>>>>            Move sSection to wSection
8903>>>>>>>            Move sKey to wKey
8904>>>>>>>            Move sDefault to wDefault
8905>>>>>>>            Move sValue to wValue
8906>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), AddressOf(wKey), AddressOf(wDefault), AddressOf(wValue), iSizeValue, psPrivate_FileName(Self))) to iNumChars
8907>>>>>>>            Move wValue to sValue
8908>>>>>>>        End
8908>>>>>>>>
8908>>>>>>>        Else Begin
8909>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8910>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, sFileName)) to iNumChars
8911>>>>>>>        End
8911>>>>>>>>
8911>>>>>>>        
8911>>>>>>>        Function_Return  (CString(sValue))
8912>>>>>>>    End_Function
8913>>>>>>>    
8913>>>>>>>    Function SectionExists String sSection Returns Boolean
8915>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
8915>>>>>>>        Handle hoKeys
8915>>>>>>>        Integer icKey iKey
8915>>>>>>>        
8915>>>>>>>        Get Create U_ARRAY to hoKeys
8916>>>>>>>        Send ReadSection sSection hoKeys
8917>>>>>>>        Get Item_Count of hoKeys to icKey
8918>>>>>>>        Send Destroy of hoKeys
8919>>>>>>>        
8919>>>>>>>        Function_Return (icKey >0)
8920>>>>>>>    End_Function
8921>>>>>>>    
8921>>>>>>>    Procedure ReadSection WString wSection Handle hoArray
8923>>>>>>>        Integer iNumChars iSizeValue iPos
8923>>>>>>>        Pointer lpsKeys
8923>>>>>>>        WString wKeys wKey
8923>>>>>>>        String  sSection sKeys sKey
8923>>>>>>>        
8923>>>>>>>        Move 16384 to iSizeValue
8924>>>>>>>        
8924>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8926>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8927>>>>>>>>
8927>>>>>>>            Procedure_Return
8928>>>>>>>        End
8928>>>>>>>>
8928>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8928>>>>>>>        If (pbWideAPI(Self)) Begin
8930>>>>>>>            Move (Repeat(character(0),  iSizeValue)) to wKeys        
8931>>>>>>>            Move (AddressOf(wKeys)) to lpsKeys
8932>>>>>>>            
8932>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), 0, 0, lpsKeys, Length(wKeys), psPrivate_FileName(Self))) to iNumChars
8933>>>>>>>            If (iNumChars >0) Begin
8935>>>>>>>                Repeat
8935>>>>>>>>
8935>>>>>>>                    Move (Pos(Character(0),wKeys)) to iPos
8936>>>>>>>                    If (iPos >1) Begin
8938>>>>>>>                        Move (Left(wKeys,iPos -1))  to wKey
8939>>>>>>>                        Move (Right(wKeys,Length(wKeys) - iPos)) to wKeys
8940>>>>>>>                        Set Value of hoArray (Item_Count(hoArray)) to wKey
8941>>>>>>>                    End
8941>>>>>>>>
8941>>>>>>>                Until (iPos <=1)
8943>>>>>>>            End
8943>>>>>>>>
8943>>>>>>>        End
8943>>>>>>>>
8943>>>>>>>        Else Begin
8944>>>>>>>            Move wSection to sSection            
8945>>>>>>>            Move (Repeat(character(0),  iSizeValue)) to sKeys        
8946>>>>>>>            Move (AddressOf(sKeys)) to lpsKeys
8947>>>>>>>        
8947>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), psPrivate_FileName(Self))) to iNumChars
8948>>>>>>>            If (iNumChars >0) Begin
8950>>>>>>>                Repeat
8950>>>>>>>>
8950>>>>>>>                    Move (Pos(Character(0),sKeys)) to iPos
8951>>>>>>>                    If (iPos >1) Begin
8953>>>>>>>                        Move (Left(sKeys,iPos -1))  to sKey
8954>>>>>>>                        Move (Right(sKeys,Length(sKeys) - iPos)) to sKeys
8955>>>>>>>                        Set Value of hoArray (Item_Count(hoArray)) to sKey
8956>>>>>>>                    End
8956>>>>>>>>
8956>>>>>>>                Until (iPos <=1)
8958>>>>>>>            End
8958>>>>>>>>
8958>>>>>>>        End
8958>>>>>>>>
8958>>>>>>>    End_Procedure
8959>>>>>>>    
8959>>>>>>>    Procedure ReadSections Handle hoArray
8961>>>>>>>        Integer iNumChars iSizeValue iPos
8961>>>>>>>        Pointer lpwSections
8961>>>>>>>        WString wSections
8961>>>>>>>        String sSection
8961>>>>>>>        
8961>>>>>>>        Move 16384 to iSizeValue
8962>>>>>>>        
8962>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wSections
8963>>>>>>>        Move (AddressOf(wSections)) to lpwSections
8964>>>>>>>        
8964>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8966>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8967>>>>>>>>
8967>>>>>>>            Procedure_Return
8968>>>>>>>        End
8968>>>>>>>>
8968>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8968>>>>>>>        Move (GetPrivateProfileStringW(0, 0, 0, lpwSections, Length(wSections), psPrivate_FileName(Self))) to iNumChars
8969>>>>>>>        If (iNumChars >0) Begin
8971>>>>>>>            Repeat
8971>>>>>>>>
8971>>>>>>>                Move (Pos(Character(0),wSections)) to iPos
8972>>>>>>>                If (iPos >1) Begin
8974>>>>>>>                    Move (Left(wSections,iPos -1)) to sSection
8975>>>>>>>                    Move (Right(wSections, Length(wSections) - iPos)) to wSections
8976>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to sSection
8977>>>>>>>                End
8977>>>>>>>>
8977>>>>>>>            Until (iPos <=1)
8979>>>>>>>        End
8979>>>>>>>>
8979>>>>>>>        
8979>>>>>>>    End_Procedure
8980>>>>>>>    
8980>>>>>>>    Procedure DeleteSection String sSection
8982>>>>>>>        
8982>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8984>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8985>>>>>>>>
8985>>>>>>>            Procedure_Return
8986>>>>>>>        End
8986>>>>>>>>
8986>>>>>>>        If (WritePrivateProfileString(sSection, "", "", psPrivate_FileName(Self)) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
8989>>>>>>>    End_Procedure
8990>>>>>>>    
8990>>>>>>>    Procedure DeleteKey String sSection String sKey
8992>>>>>>>        Integer iVoid
8992>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8994>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8995>>>>>>>>
8995>>>>>>>            Procedure_Return
8996>>>>>>>        End
8996>>>>>>>>
8996>>>>>>>        Move (WritePrivateProfileString(sSection, sKey, "", psPrivate_FileName(Self))) to iVoid
8997>>>>>>>    End_Procedure
8998>>>>>>>    
8998>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
9000>>>>>>>        Handle hoKeys
9000>>>>>>>        Integer iKey
9000>>>>>>>        Boolean bExists
9000>>>>>>>        
9000>>>>>>>        Move (False) to bExists
9001>>>>>>>        
9001>>>>>>>        Move (Uppercase(sKey)) to sKey
9002>>>>>>>        
9002>>>>>>>        Get Create U_ARRAY to hoKeys
9003>>>>>>>        
9003>>>>>>>        Send ReadSection sSection hoKeys
9004>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
9010>>>>>>>>
9010>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
9012>>>>>>>                Move (True) to bExists
9013>>>>>>>            End
9013>>>>>>>>
9013>>>>>>>        Loop
9014>>>>>>>>
9014>>>>>>>        
9014>>>>>>>        Send Destroy of hoKeys
9015>>>>>>>        
9015>>>>>>>        Function_Return bExists
9016>>>>>>>    End_Function
9017>>>>>>>    
9017>>>>>>>End_Class
9018>>>>>
9018>>>>>Class cWorkspace is a cObject
9019>>>>>    
9019>>>>>    Procedure Construct_Object
9021>>>>>        Forward Send Construct_Object
9023>>>>>        
9023>>>>>        
9023>>>>>        Property String psAppSrcPath
9024>>>>>        Property String psBitmapPath
9025>>>>>        Property String psDataPath
9026>>>>>        Property String psDdSrcPath
9027>>>>>        Property String psDescription
9028>>>>>        Property String psFileList
9029>>>>>        Property String psHelpPath
9030>>>>>        Property String psHome
9031>>>>>        Property String psIdeSrcPath
9032>>>>>        Property String psProgramPath
9033>>>>>        Property String psAppHtmlPath
9034>>>>>        Property String psWorkspaceName
9035>>>>>        Property String psWorkspaceWSFile
9036>>>>>        Property String psConnectionIni
9037>>>>>        
9037>>>>>        Property String psSystemDfPath // took from the Registry!
9038>>>>>        Property String psSystemMakePath // took from the Registry!
9039>>>>>        Property String psDfPath        // Calculated
9040>>>>>        
9040>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
9041>>>>>        
9041>>>>>    End_Procedure
9042>>>>>    
9042>>>>>    Function FullPathNames String sShortPathNames Returns String
9044>>>>>        String sFileName
9044>>>>>        String sFullPathNames 
9044>>>>>        WString sFullPathName sShortPathName
9044>>>>>        Pointer lpsFilePart
9044>>>>>        Integer icChar // the number of characters returned
9044>>>>>        Integer iPos
9044>>>>>        
9044>>>>>        Move (Pos(";", sShortPathNames)) to iPos
9045>>>>>        While (length(sShortPathNames) >0)
9049>>>>>            If (iPos =0) Begin
9051>>>>>                Move sShortPathNames to sShortPathName
9052>>>>>                Move "" to sShortPathNames
9053>>>>>            End
9053>>>>>>
9053>>>>>            Else Begin // multiple paths
9054>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
9055>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
9056>>>>>            End
9056>>>>>>
9056>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
9057>>>>>            Move -1 to lpsFilePart
9058>>>>>            Move (GetFullPathNameW(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
9059>>>>>            Append sFullPathNames (CString(sFullPathName))
9060>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
9063>>>>>            Move (Pos(";", sShortPathNames)) to iPos
9064>>>>>        Loop
9065>>>>>>
9065>>>>>        
9065>>>>>        Function_Return sFullPathNames
9066>>>>>    End_Function
9067>>>>>    
9067>>>>>    Function GetApplicationPath Returns String
9069>>>>>        // Returns the path of the Application (no trailing "\")
9069>>>>>        WString wApplicationFileName 
9069>>>>>        Boolean bRemoved
9069>>>>>        Integer iNumChars
9069>>>>>        String sFilename sPath
9069>>>>>        
9069>>>>>        Move (Repeat(Character(0), 1024)) to wApplicationFileName
9070>>>>>        Move (GetModuleFileNameW(0, AddressOf(wApplicationFileName), 1024)) to iNumChars
9071>>>>>        Move (CString(wApplicationFileName)) to wApplicationFileName
9072>>>>>        
9072>>>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
9073>>>>>        Move (CString(wApplicationFileName)) to sPath
9074>>>>>        
9074>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
9077>>>>>        Function_Return sPath
9078>>>>>    End_Function
9079>>>>>    
9079>>>>>    Procedure DoClearPaths
9081>>>>>        // Call this prior to changing from one WorkspAce to another
9081>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
9081>>>>>        Set psHome           to ""
9082>>>>>        Set psAppSrcPath     to ""
9083>>>>>        Set psBitmapPath     to ""
9084>>>>>        Set psDataPath       to ""
9085>>>>>        Set psDdSrcPath      to ""
9086>>>>>        Set psDescription    to ""
9087>>>>>        Set psFileList       to ""
9088>>>>>        Set psHelpPath       to ""
9089>>>>>        Set psIdeSrcPath     to ""
9090>>>>>        Set psAppHtmlPath    to ""
9091>>>>>        Set psProgramPath    to ""
9092>>>>>        Set psWorkspaceName  to ""
9093>>>>>        Set psSystemDfPath   to ""
9094>>>>>        Set psSystemMakePath to ""
9095>>>>>        Set psWorkspaceWSFile to ""
9096>>>>>        Set psConnectionIni to ""
9097>>>>>    End_Procedure
9098>>>>>    
9098>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
9100>>>>>        WString wApplicationStartPath
9100>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
9100>>>>>        Boolean bRemoved
9100>>>>>        Handle hoIniFile
9100>>>>>        Boolean bSuccess // call succeeded?
9100>>>>>        String sOldDirectory
9100>>>>>        String sSystemDfPath sSystemMakePath
9100>>>>>        Boolean bExist // does the WS file exist?
9100>>>>>        Boolean bChangingWorkspace
9100>>>>>        
9100>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
9100>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
9100>>>>>        
9100>>>>>        Set psWorkspaceWSFile to ""
9101>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
9104>>>>>        
9104>>>>>        // Append extension if not supplied...
9104>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
9106>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
9107>>>>>        End
9107>>>>>>
9107>>>>>        
9107>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
9108>>>>>        
9108>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
9110>>>>>            // Set the properties to the paths of the Workspace
9110>>>>>            // Find the WS file (with program)...
9110>>>>>            Get GetApplicationPath to wApplicationStartPath
9111>>>>>            
9111>>>>>            Move sWorkspaceFile to sWsName
9112>>>>>            Move (wApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
9113>>>>>        End
9113>>>>>>
9113>>>>>        Else Begin
9114>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
9115>>>>>            
9115>>>>>            Move sWorkspaceFile to wApplicationStartPath
9116>>>>>            Move (PathRemoveFileSpecW(AddressOf(wApplicationStartPath))) to bRemoved
9117>>>>>        End
9117>>>>>>
9117>>>>>        
9117>>>>>        // Ensure that the file can be found...
9117>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
9117>>>>>        // [JVH] Turn off support for
9117>>>>>        // Ansi extended characters in workspace until we can
9117>>>>>        // resolve all open issues
9117>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
9118>>>>>        File_Exist sWorkspaceFile bExist
9119>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
9122>>>>>        
9122>>>>>        Get psHome           to sHome
9123>>>>>        Get psAppSrcPath     to sAppSrcPath
9124>>>>>        Get psAppHtmlPath    to sAppHtmlPath
9125>>>>>        Get psBitmapPath     to sBitmapPath
9126>>>>>        Get psDataPath       to sDataPath
9127>>>>>        Get psDdSrcPath      to sDdSrcPath
9128>>>>>        Get psDescription    to sDescription
9129>>>>>        Get psFileList       to sFileList
9130>>>>>        Get psHelpPath       to sHelpPath
9131>>>>>        Get psIdeSrcPath     to sIdeSrcPath
9132>>>>>        Get psProgramPath    to sProgramPath
9133>>>>>        Get psSystemDfPath   to sSystemDfPath
9134>>>>>        Get psSystemMakePath to sSystemMakePath
9135>>>>>        Get psWorkspaceName  to sWorkspaceName
9136>>>>>        Get psConnectionIni to sConnectionIni
9137>>>>>        
9137>>>>>        Get_Current_Directory to sOldDirectory
9138>>>>>        // Note- this conversion is temporarily rolled back
9138>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(wApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
9138>>>>>        Move (SetCurrentDirectory(CString(wApplicationStartPath))) to bSuccess
9139>>>>>        
9139>>>>>        Get Create U_cIniFile to hoIniFile
9140>>>>>        Set pbWideAPI of hoIniFile to False
9141>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
9142>>>>>        
9142>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
9145>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
9148>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
9151>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
9154>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
9157>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
9160>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
9163>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
9166>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
9169>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
9172>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
9175>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
9178>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
9181>>>>>        
9181>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
9184>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
9187>>>>>        
9187>>>>>        Set psHome          to (FullPathNames(Self, sHome))
9188>>>>>        
9188>>>>>        // Set CWD to Home...
9188>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
9189>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
9190>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
9191>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
9192>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
9193>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
9194>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
9195>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
9196>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
9197>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
9198>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
9199>>>>>        
9199>>>>>        Set psWorkspaceName to sWorkspaceName
9200>>>>>        Set psDescription   to sDescription
9201>>>>>        
9201>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
9202>>>>>        
9202>>>>>        // Restore CWD...
9202>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
9203>>>>>        
9203>>>>>        // Check for error conditions:
9203>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
9203>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
9206>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
9209>>>>>        
9209>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
9210>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
9213>>>>>        
9213>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
9216>>>>>        
9216>>>>>        Send DoAssignPaths // set psDfPath
9217>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
9218>>>>>        Set pbWorkspaceOpened to True
9219>>>>>        
9219>>>>>        Function_Return wsWorkspaceOpened
9220>>>>>    End_Function
9221>>>>>    
9221>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
9223>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
9223>>>>>        
9223>>>>>        Handle hoSections hoIniFile
9223>>>>>        Integer iWorkspace eOpened
9223>>>>>        String sWorkspaceName sPath
9223>>>>>        String sVdfRootDir
9223>>>>>        
9223>>>>>        Get Create U_Array    to hoSections
9224>>>>>        Get Create U_cIniFile to hoIniFile
9225>>>>>        
9225>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9228>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9231>>>>>        
9231>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9232>>>>>        
9232>>>>>        Send ReadSections of hoIniFile hoSections
9233>>>>>        
9233>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
9239>>>>>>
9239>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
9240>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
9242>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
9243>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
9246>>>>>                
9246>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
9247>>>>>                Send Destroy of hoSections
9248>>>>>                Send Destroy of hoIniFile
9249>>>>>                Function_Return eOpened
9250>>>>>            End
9250>>>>>>
9250>>>>>        Loop
9251>>>>>>
9251>>>>>        
9251>>>>>        Send Destroy of hoSections
9252>>>>>        Send Destroy of hoIniFile
9253>>>>>        Function_Return wsWorkspaceNotFound
9254>>>>>    End_Function
9255>>>>>    
9255>>>>>    Function IsRegistered String sWorkspace Returns Boolean
9257>>>>>        Boolean bRegistered
9257>>>>>        Handle hoIniFile
9257>>>>>        String sVdfRootDir
9257>>>>>        
9257>>>>>        Get Create U_cIniFile to hoIniFile
9258>>>>>        
9258>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9261>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9264>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9265>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
9266>>>>>        
9266>>>>>        Send Destroy of hoIniFile
9267>>>>>        
9267>>>>>        Function_Return bRegistered
9268>>>>>    End_Function
9269>>>>>    
9269>>>>>    Function VdfSystemDfPath Returns String
9271>>>>>        String sSystemDfPath
9271>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
9274>>>>>        
9274>>>>>        Function_Return sSystemDfPath
9275>>>>>    End_Function
9276>>>>>    
9276>>>>>    Function VdfSystemMakePath Returns String
9278>>>>>        String sSystemMakePath
9278>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
9281>>>>>        
9281>>>>>        Function_Return sSystemMakePath
9282>>>>>    End_Function
9283>>>>>    
9283>>>>>    Procedure DoAssignPaths
9285>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
9285>>>>>        
9285>>>>>        Get psDataPath     to sDataPath
9286>>>>>        Get psBitmapPath   to sBitmapPath
9287>>>>>        Get psHelpPath     to sHelpPath
9288>>>>>        Get psProgramPath  to sProgramPath
9289>>>>>        Get psSystemDfPath to sSystemDfPath
9290>>>>>        
9290>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
9291>>>>>        
9291>>>>>    End_Procedure
9292>>>>>    
9292>>>>>    Procedure DoSetPaths
9294>>>>>        // [JVH] must convert paths to Ansi before setting these values
9294>>>>>        // Note- this conversion is temporarily rolled back
9294>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
9294>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
9294>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
9297>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
9300>>>>>    End_Procedure
9301>>>>>    
9301>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
9303>>>>>        String sPath
9303>>>>>        
9303>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
9306>>>>>        Else Begin
9307>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
9308>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
9309>>>>>            Send hmGeneric to hoCallBack ""
9310>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
9311>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
9312>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
9313>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
9314>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
9315>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
9316>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
9317>>>>>        End
9317>>>>>>
9317>>>>>    End_Procedure
9318>>>>>    
9318>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
9320>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
9320>>>>>        // returns a corresponding message string.
9320>>>>>        String sError
9320>>>>>        
9320>>>>>        Case Begin
9320>>>>>            Case (eErrorCode = wsWorkspaceOpened)
9322>>>>>                Move C_$NoErrors to sError
9323>>>>>                Case Break
9324>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
9327>>>>>                Move C_$NoWsName to sError
9328>>>>>                Case Break
9329>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
9332>>>>>                Move C_$NoWsFileFound to sError
9333>>>>>                Case Break
9334>>>>>            Case (eErrorCode = wsDataPathEmpty)
9337>>>>>                Move C_$NoWsDataPath to sError
9338>>>>>                Case Break
9339>>>>>            Case (eErrorCode = wsFileListEmpty)
9342>>>>>                Move C_$NoWsFileList to sError
9343>>>>>                Case Break
9344>>>>>            Case (eErrorCode = wsFileListNotExist)
9347>>>>>                Move C_$NoFileListCfg to sError
9348>>>>>                Case Break
9349>>>>>            Case Else
9349>>>>>                Move C_$UnknownError to sError
9350>>>>>                Case Break
9351>>>>>        Case End
9351>>>>>        
9351>>>>>        Function_Return (sError-".")
9352>>>>>    End_Function
9353>>>>>    
9353>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
9355>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
9355>>>>>        String sVdfRootDir
9355>>>>>        Handle hoIniFile
9355>>>>>        String sPath
9355>>>>>        String sFileName
9355>>>>>        String sWorkspacePath
9355>>>>>        
9355>>>>>        Move "" to sFileName
9356>>>>>        
9356>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9359>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9362>>>>>        
9362>>>>>        Get Create U_cIniFile to hoIniFile
9363>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9364>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
9365>>>>>        If (sWorkspacePath <>"") Begin
9367>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
9370>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
9371>>>>>        End
9371>>>>>>
9371>>>>>        Send Destroy of hoIniFile
9372>>>>>        
9372>>>>>        Function_Return sFileName
9373>>>>>    End_Function
9374>>>>>    
9374>>>>>    Function CountOfPaths String sPaths Returns Integer
9376>>>>>        // Returns the number of paths defined in a string of paths
9376>>>>>        Integer iChar icChar icPath
9376>>>>>        
9376>>>>>        If (sPaths ="") ;            Function_Return 0
9379>>>>>        
9379>>>>>        Move (Length(sPaths) -1) to icChar
9380>>>>>        For iChar from 1 to icChar
9386>>>>>>
9386>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
9389>>>>>        Loop
9390>>>>>>
9390>>>>>        
9390>>>>>        Function_Return (icPath +1)
9391>>>>>    End_Function
9392>>>>>    
9392>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
9394>>>>>        // Returns the path at the 1-based index of passed paths.
9394>>>>>        // If the path contains a trailing "\", it will be removed
9394>>>>>        Integer iChar icPath iPath iPos
9394>>>>>        String sPath
9394>>>>>        
9394>>>>>        Move (sPaths +";") to sPaths
9395>>>>>        For iPath from 1 to iIndex
9401>>>>>>
9401>>>>>            Move (Pos(";", sPaths)) to iPos
9402>>>>>            If iPos Begin
9404>>>>>                Move (Left(sPaths, iPos -1)) to sPath
9405>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
9408>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
9409>>>>>            End
9409>>>>>>
9409>>>>>            Else ;                Function_Return "" // index past number of paths
9411>>>>>        Loop
9412>>>>>>
9412>>>>>        
9412>>>>>        Function_Return sPath
9413>>>>>    End_Function
9414>>>>>    
9414>>>>>End_Class
9415>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cCommandLine.pkg)
9415>>>>>Use VDFBase.pkg
9415>>>>>
9415>>>>>Class cCommandLine is a cObject
9416>>>>>    
9416>>>>>    Procedure Construct_Object
9418>>>>>        Forward Send Construct_Object
9420>>>>>        
9420>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
9421>>>>>    End_Procedure
9422>>>>>    
9422>>>>>    Procedure Private_DoCreateArgsArray
9424>>>>>        // creates the array for holding the arguments. Created upon demand only!
9424>>>>>        Integer icArg
9424>>>>>        String sArg
9424>>>>>        
9424>>>>>        Object oArgs is an Array
9426>>>>>            Delegate Set phoArgs to Self
9428>>>>>            Repeat
9428>>>>>>
9428>>>>>                CmdLine sArg
9429>>>>>>
9429>>>>>                If (sArg <> "") Begin
9431>>>>>                    Increment icArg
9432>>>>>                    Set Value  (icArg -1) to sArg
9433>>>>>                End
9433>>>>>>
9433>>>>>            Until (sArg = "")
9435>>>>>        End_Object
9436>>>>>    End_Procedure
9437>>>>>    
9437>>>>>    Function CountOfArgs Returns Integer
9439>>>>>        //Returns the number of arguments passed
9439>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9442>>>>>        Function_Return (Item_Count(phoArgs(Self)))
9443>>>>>    End_Function
9444>>>>>    
9444>>>>>    Function Argument Integer iIndex Returns String
9446>>>>>        //Returns the one-based argument string
9446>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9449>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
9450>>>>>    End_Function
9451>>>>>    
9451>>>>>End_Class
9452>>>>>
9452>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cRegistry.pkg)
9452>>>>>Use Dll.pkg
9452>>>>>Use RegistryAPI.pkg
9452>>>>>Use tWinStructs.pkg
9452>>>>>
9452>>>>>Enum_List // Registry Data types
9452>>>>>    Define rdString
9452>>>>>    Define rdDword
9452>>>>>    Define rdBinary
9452>>>>>    Define rdUnknown
9452>>>>>End_Enum_List
9452>>>>>
9452>>>>>
9452>>>>>Class cRegistry is a cObject
9453>>>>>    Procedure Construct_Object
9455>>>>>        Forward Send Construct_Object
9457>>>>>        
9457>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
9458>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
9459>>>>>        Property Handle phCurrentKey
9460>>>>>        Property Boolean pbLazyWrite True
9461>>>>>    End_Procedure
9462>>>>>    
9462>>>>>    Function CountOfSubkeys Returns Integer
9464>>>>>        Integer dwCountOfSubkeys
9464>>>>>        Integer iError
9464>>>>>        String sError
9464>>>>>        
9464>>>>>        Move 0 to dwCountOfSubkeys
9465>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
9466>>>>>        If iError Begin
9468>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9469>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9470>>>>>>
9470>>>>>        End
9470>>>>>>
9470>>>>>        Function_Return dwCountOfSubkeys
9471>>>>>    End_Function
9472>>>>>    
9472>>>>>    Function CountOfValues Returns Integer
9474>>>>>        Integer dwCountOfValues
9474>>>>>        Integer iError
9474>>>>>        String sError
9474>>>>>        
9474>>>>>        Move 0 to dwCountOfValues
9475>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
9476>>>>>        If iError Begin
9478>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9479>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9480>>>>>>
9480>>>>>        End
9480>>>>>>
9480>>>>>        
9480>>>>>        Function_Return dwCountOfValues
9481>>>>>    End_Function
9482>>>>>    
9482>>>>>    Function LongestSubkeyLength Returns Integer
9484>>>>>        Integer dwLongestSubkeyLength
9484>>>>>        Integer iError
9484>>>>>        String sError
9484>>>>>        
9484>>>>>        Move 0 to dwLongestSubkeyLength
9485>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
9486>>>>>        If iError Begin
9488>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9489>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9490>>>>>>
9490>>>>>        End
9490>>>>>>
9490>>>>>        
9490>>>>>        Function_Return dwLongestSubkeyLength
9491>>>>>    End_Function
9492>>>>>    
9492>>>>>    Function LongestValueLength Returns Integer
9494>>>>>        Integer dwLongestValueLength
9494>>>>>        Integer iError
9494>>>>>        String sError
9494>>>>>        
9494>>>>>        Move 0 to dwLongestValueLength
9495>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
9496>>>>>        If iError Begin
9498>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9499>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9500>>>>>>
9500>>>>>        End
9500>>>>>>
9500>>>>>        
9500>>>>>        Function_Return dwLongestValueLength
9501>>>>>    End_Function
9502>>>>>    
9502>>>>>    Function LongestDataLength Returns Integer
9504>>>>>        Integer dwLongestDataLength
9504>>>>>        Integer iError
9504>>>>>        String sError
9504>>>>>        
9504>>>>>        Move 0 to dwLongestDataLength
9505>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
9506>>>>>        If iError Begin
9508>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9509>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9510>>>>>>
9510>>>>>        End
9510>>>>>>
9510>>>>>        
9510>>>>>        Function_Return dwLongestDataLength
9511>>>>>    End_Function
9512>>>>>    
9512>>>>>    Function ValueType String sValueName Returns Integer
9514>>>>>        Integer dwType
9514>>>>>        Integer iError eType
9514>>>>>        String sError
9514>>>>>        
9514>>>>>        Move 0 to dwType
9515>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwType), 0, 0)) to iError
9516>>>>>        If iError Begin
9518>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9519>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9520>>>>>>
9520>>>>>        End
9520>>>>>>
9520>>>>>        
9520>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
9523>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
9527>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
9531>>>>>        Else ;            Move rdUnknown to eType
9533>>>>>        
9533>>>>>        Function_Return eType
9534>>>>>    End_Function
9535>>>>>    
9535>>>>>    Function ValueLength String sValueName Returns Integer
9537>>>>>        Integer dwSize
9537>>>>>        Integer iError
9537>>>>>        String sError
9537>>>>>        
9537>>>>>        Move 0 to dwSize
9538>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, 0, 0, AddressOf(dwSize))) to iError
9539>>>>>        If iError Begin
9541>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9542>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9543>>>>>>
9543>>>>>        End
9543>>>>>>
9543>>>>>        
9543>>>>>        Function_Return dwSize
9544>>>>>    End_Function
9545>>>>>    
9545>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
9547>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
9547>>>>>        Handle hKey hKeyOpened
9547>>>>>        Integer iError
9547>>>>>        String sError
9547>>>>>        
9547>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9548>>>>>        
9548>>>>>        Get phRootKey to hKey
9549>>>>>        
9549>>>>>        Move (RegCreateKeyEx(hKey, sKeyName, 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
9550>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9553>>>>>        Else Begin
9554>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9555>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9556>>>>>>
9556>>>>>        End
9556>>>>>>
9556>>>>>        Function_Return iError
9557>>>>>    End_Function
9558>>>>>    
9558>>>>>    Procedure CloseKey
9560>>>>>        Integer iError
9560>>>>>        Handle hKey
9560>>>>>        
9560>>>>>        Get phCurrentKey to hKey
9561>>>>>        
9561>>>>>        If (hKey <>0) Begin
9563>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
9566>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
9568>>>>>            
9568>>>>>            Set phCurrentKey to 0
9569>>>>>        End
9569>>>>>>
9569>>>>>    End_Procedure
9570>>>>>    
9570>>>>>    Function OpenKey String sKeyName Returns Boolean
9572>>>>>        Handle hKey hKeyOpened
9572>>>>>        Integer iError
9572>>>>>        
9572>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9573>>>>>        
9573>>>>>        Get phRootKey to hKey
9574>>>>>        Move (RegOpenKeyEx(hKey, sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9575>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9578>>>>>        
9578>>>>>        Function_Return (iError=0)
9579>>>>>    End_Function
9580>>>>>    
9580>>>>>    Procedure WriteInteger WString sValue Integer iValueData
9582>>>>>        Handle hKey
9582>>>>>        Integer iError
9582>>>>>        Integer iData
9582>>>>>        String sError
9582>>>>>        
9582>>>>>        Move iValueData to iData
9583>>>>>        Get phCurrentKey to hKey
9584>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(iData), SizeOfType(Integer))) to iError
9585>>>>>        If iError Begin
9587>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9588>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9589>>>>>>
9589>>>>>        End
9589>>>>>>
9589>>>>>    End_Procedure
9590>>>>>    
9590>>>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9590>>>>>    Procedure WriteDword String sValue Integer iValueData
9592>>>>>        Send WriteInteger of Self sValue iValueData
9593>>>>>    End_Procedure
9594>>>>>    
9594>>>>>    Procedure WriteUInt WString sValue UInteger uValueData
9596>>>>>        Handle hKey
9596>>>>>        Integer iError
9596>>>>>        UInteger uData
9596>>>>>        String sError
9596>>>>>        
9596>>>>>        Move uValueData to uData
9597>>>>>        Get phCurrentKey to hKey
9598>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(uData), SizeOfType(UInteger))) to iError
9599>>>>>        If iError Begin
9601>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9602>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9603>>>>>>
9603>>>>>        End
9603>>>>>>
9603>>>>>    End_Procedure
9604>>>>>
9604>>>>>    Procedure WriteString WString sValue WString wValueData
9606>>>>>        Handle hKey
9606>>>>>        Integer iError cbData
9606>>>>>        String sError
9606>>>>>        
9606>>>>>        If (wValueData = "") Begin
9608>>>>>            Move (Character(0)) to wValueData
9609>>>>>            Move 1 to cbData
9610>>>>>        End
9610>>>>>>
9610>>>>>        Else Begin
9611>>>>>            Move ((SizeOfWString(wValueData) +1)*2) to cbData
9612>>>>>        End
9612>>>>>>
9612>>>>>        Get phCurrentKey to hKey
9613>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_SZ, AddressOf(wValueData), cbData)) to iError
9614>>>>>        If iError Begin
9616>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9617>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9618>>>>>>
9618>>>>>        End
9618>>>>>>
9618>>>>>    End_Procedure
9619>>>>>    
9619>>>>>    Procedure WriteBinary WString sValue Pointer pValueData Integer iDataLength
9621>>>>>        Handle hKey
9621>>>>>        Integer iError
9621>>>>>        String sError
9621>>>>>        
9621>>>>>        Get phCurrentKey to hKey
9622>>>>>        Move (RegSetValueExw(hKey, sValue, 0, REG_BINARY, pValueData, iDataLength)) to iError
9623>>>>>        If iError Begin
9625>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9626>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9627>>>>>>
9627>>>>>        End
9627>>>>>>
9627>>>>>    End_Procedure
9628>>>>>    
9628>>>>>    Function ReadInteger WString sValueName Returns Integer
9630>>>>>        Handle hKey
9630>>>>>        Integer iError
9630>>>>>        Integer iValueData iValueDataLength
9630>>>>>        String sError
9630>>>>>        
9630>>>>>        Move 0           to iValueData
9631>>>>>        Move (SizeOfType(Integer)) to iValueDataLength
9632>>>>>        
9632>>>>>        Get phCurrentKey to hKey
9633>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(iValueData), AddressOf(iValueDataLength))) to iError
9634>>>>>        If iError Begin
9636>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9637>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9638>>>>>>
9638>>>>>        End
9638>>>>>>
9638>>>>>        
9638>>>>>        Function_Return iValueData
9639>>>>>    End_Function
9640>>>>>    
9640>>>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9640>>>>>    Function ReadDword String sValueName Returns Integer
9642>>>>>        Function_Return (ReadInteger(Self, sValueName))
9643>>>>>    End_Function
9644>>>>>
9644>>>>>    Function ReadUInt WString sValueName Returns UInteger
9646>>>>>        Handle hKey
9646>>>>>        Integer iError
9646>>>>>        UInteger uValueData uValueDataLength
9646>>>>>        String sError
9646>>>>>        
9646>>>>>        Move 0           to uValueData
9647>>>>>        Move (SizeOfType(UInteger)) to uValueDataLength
9648>>>>>        
9648>>>>>        Get phCurrentKey to hKey
9649>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(uValueData), AddressOf(uValueDataLength))) to iError
9650>>>>>        If iError Begin
9652>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9653>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9654>>>>>>
9654>>>>>        End
9654>>>>>>
9654>>>>>        
9654>>>>>        Function_Return uValueData
9655>>>>>    End_Function
9656>>>>>    
9656>>>>>    Function ReadString String sValueName Returns String
9658>>>>>        Handle hKey
9658>>>>>        Integer iError
9658>>>>>        WString wValueData
9658>>>>>        DWord dwValueDataLength dwType
9658>>>>>        Pointer lpsValueData
9658>>>>>        String sError
9658>>>>>        
9658>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to wValueData
9659>>>>>        Move (AddressOf(wValueData)) to lpsValueData
9660>>>>>        
9660>>>>>        Move (SizeOfWString(wValueData)) to dwValueDataLength
9661>>>>>        
9661>>>>>        Move REG_SZ to dwType
9662>>>>>        
9662>>>>>        Get phCurrentKey to hKey
9663>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, (AddressOf(dwType)), lpsValueData, AddressOf(dwValueDataLength))) to iError
9664>>>>>        If iError Begin
9666>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9667>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9668>>>>>>
9668>>>>>        End
9668>>>>>>
9668>>>>>        
9668>>>>>        Function_Return (CString(wValueData))
9669>>>>>    End_Function
9670>>>>>    
9670>>>>>    Function ReadBinary String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9672>>>>>        Handle hKey
9672>>>>>        Integer iError
9672>>>>>        String sError
9672>>>>>        
9672>>>>>        Get phCurrentKey to hKey
9673>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, pValueData, AddressOf(iDataLength))) to iError
9674>>>>>        If iError Begin
9676>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9677>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9678>>>>>>
9678>>>>>        End
9678>>>>>>
9678>>>>>        
9678>>>>>        Function_Return (iDataLength >0)
9679>>>>>    End_Function
9680>>>>>    
9680>>>>>    
9680>>>>>    // Private....
9680>>>>>    Function GetBaseKey Returns Handle
9682>>>>>        Handle hBaseKey
9682>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
9685>>>>>        Else ;            Get phCurrentKey to hBaseKey
9687>>>>>        
9687>>>>>        Function_Return hBaseKey
9688>>>>>    End_Function
9689>>>>>    
9689>>>>>    Function GetKey String sKeyName Returns Handle
9691>>>>>        Handle hKeyOpened
9691>>>>>        Integer iError
9691>>>>>        
9691>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
9692>>>>>        
9692>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9693>>>>>        
9693>>>>>        If (iError =0) ;            Function_Return hKeyOpened
9696>>>>>        Else ;            Function_Return 0
9698>>>>>    End_Function
9699>>>>>    
9699>>>>>    // Public
9699>>>>>    Function KeyExists String sKeyName Returns Boolean
9701>>>>>        Handle hKey
9701>>>>>        Integer iVoid
9701>>>>>        
9701>>>>>        If (Trim(sKeyName) = "") ;            Function_Return False
9704>>>>>        
9704>>>>>        Get GetKey sKeyName to hKey
9705>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
9708>>>>>        Function_Return (hKey <>0)
9709>>>>>    End_Function
9710>>>>>    
9710>>>>>    Function ValueExists String sValueName Returns Boolean
9712>>>>>        // Determines whether a Value exists for the currently-opened Key.
9712>>>>>        Integer iError
9712>>>>>        DWord dwDataType
9712>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
9713>>>>>        
9713>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwDataType), 0, 0)) to iError
9714>>>>>        
9714>>>>>        Function_Return (iError=0)
9715>>>>>    End_Function
9716>>>>>    
9716>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
9718>>>>>        
9718>>>>>            If (Trim(sKeyName) = "") ;            Function_Return False
9721>>>>>        
9721>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), sKeyName) =0)
9722>>>>>    End_Function
9723>>>>>    
9723>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
9725>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), sValueName) =0)
9726>>>>>    End_Function
9727>>>>>    
9727>>>>>    Function Subkeys Returns String[]
9729>>>>>        Integer iError
9729>>>>>        Integer icValue iLongestSubkey
9729>>>>>        Handle hKey
9729>>>>>        DWord dwSubkeyNameLength
9729>>>>>        String sSubkeyName sFileTime
9729>>>>>        Pointer lpsSubkeyName
9729>>>>>        String[] aResult
9730>>>>>        tWinFileTime fileTime
9730>>>>>        tWinFileTime fileTime
9730>>>>>
9730>>>>>        Get LongestSubkeyLength to iLongestSubkey
9731>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
9732>>>>>        Move (AddressOf(sSubkeyName)) to lpsSubkeyName
9733>>>>>
9733>>>>>        Get phCurrentKey to hKey
9734>>>>>        Repeat
9734>>>>>>
9734>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9735>>>>>
9735>>>>>            Move (RegEnumKeyEx(hKey, icValue, lpsSubkeyName, AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(fileTime))) to iError
9736>>>>>            If (iError =0) Begin
9738>>>>>                Move (CString(sSubkeyName)) to aResult[icValue]
9739>>>>>                Increment icValue
9740>>>>>            End
9740>>>>>>
9740>>>>>        Until (iError)
9742>>>>>        Function_Return aResult
9743>>>>>    End_Function
9744>>>>>    
9744>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
9746>>>>>        Integer iError
9746>>>>>        Integer icValue iLongestSubkey
9746>>>>>        Handle hKey
9746>>>>>        DWord dwSubkeyNameLength
9746>>>>>        WString wSubkeyName
9746>>>>>        tWinFileTime FileTime
9746>>>>>        tWinFileTime FileTime
9746>>>>>        
9746>>>>>        Get LongestSubkeyLength to iLongestSubkey
9747>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to wSubkeyName
9748>>>>>        
9748>>>>>        Get phCurrentKey to hKey
9749>>>>>        Repeat
9749>>>>>>
9749>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9750>>>>>            
9750>>>>>            Move (RegEnumKeyExW(hKey, icValue, AddressOf(wSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
9751>>>>>            If (iError =0) Begin
9753>>>>>                Increment icValue
9754>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wSubkeyName))
9755>>>>>            End
9755>>>>>>
9755>>>>>        Until (iError)
9757>>>>>        Function_Return icValue
9758>>>>>        
9758>>>>>    End_Function
9759>>>>>    
9759>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
9761>>>>>        Integer iError
9761>>>>>        Integer icValue iLongestValue
9761>>>>>        Handle hKey
9761>>>>>        DWord dwValueNameLength
9761>>>>>        WString wValueName 
9761>>>>>        String sValueNameSize
9761>>>>>        Pointer lpsValueName
9761>>>>>        
9761>>>>>        Get LongestValueLength to iLongestValue
9762>>>>>        Move (Repeat(character(0), iLongestValue +1)) to wValueName
9763>>>>>        Move (AddressOf(wValueName)) to lpsValueName
9764>>>>>        
9764>>>>>        Get phCurrentKey to hKey
9765>>>>>        Repeat
9765>>>>>>
9765>>>>>            Move (iLongestValue +1) to dwValueNameLength
9766>>>>>            Move (RegEnumValueW(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
9767>>>>>            If (iError =0) Begin
9769>>>>>                Increment icValue
9770>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wValueName))
9771>>>>>            End
9771>>>>>>
9771>>>>>        Until (iError)
9773>>>>>        Function_Return icValue
9774>>>>>        
9774>>>>>    End_Function
9775>>>>>    
9775>>>>>End_Class
9776>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cVersionInfo.pkg)
9776>>>>>Use VdfBase.pkg
9776>>>>>Use DLL.pkg
9776>>>>>Use tWinStructs.pkg
9776>>>>>Use WinKern.pkg
9776>>>>>
9776>>>>>Define VS_FF_DEBUG         for |CI$00000001
9776>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
9776>>>>>Define VS_FF_PATCHED       for |CI$00000004
9776>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
9776>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
9776>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
9776>>>>>
9776>>>>>// Note: String pointer lpFilename must refer to WString type.
9776>>>>>External_Function GetFileVersionInfoSizeW "GetFileVersionInfoSizeW" version.dll ;    Pointer lpFilename ;    Pointer lpdwHandle ;    Returns DWord
9777>>>>>    
9777>>>>>// Wrapper Function GetFileVersionInfoSize (when using strings)
9777>>>>>Function GetFileVersionInfoSize Global ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
9779>>>>>    
9779>>>>>    DWord  dwResult
9779>>>>>    UWide  uwFileName
9779>>>>>    UWide  uwFileName
9779>>>>>
9779>>>>>    Send StringToWide aFilename (&uwFileName)
9780>>>>>    
9780>>>>>    Move (GetFileVersionInfoSizeW (uwFileName.lpUText, lpdwHandle)) to dwResult        
9781>>>>>    Function_Return dwResult
9782>>>>>End_Function
9783>>>>>
9783>>>>>// Note: String pointers should be referring to WString items.
9783>>>>>External_Function GetFileVersionInfoW "GetFileVersionInfoW" version.dll ;    Pointer lpFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer lpData ;    Returns Integer
9784>>>>>    
9784>>>>>// Wrapper Function GetFileVersionInfo (when using strings)
9784>>>>>Function GetFileVersionInfo Global ;    Pointer aFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer pData ;    Returns Integer
9786>>>>>    
9786>>>>>    Integer iResult
9786>>>>>    UWide   uwFileName
9786>>>>>    UWide   uwFileName
9786>>>>>
9786>>>>>    Send StringToWide aFilename (&uwFileName)
9787>>>>>    
9787>>>>>    Move (GetFileVersionInfoW (uwFileName.lpUText, dwHandle, dwLen, pData)) to iResult
9788>>>>>    Function_Return iResult
9789>>>>>End_Function    
9790>>>>>
9790>>>>>// Note: String pointers should be referring to WString items.
9790>>>>>External_Function VerQueryValueW "VerQueryValueW" version.dll ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9791>>>>>
9791>>>>>// Wrapper Function VerQueryValue (when using strings)
9791>>>>>Function VerQueryValue Global ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9793>>>>>    
9793>>>>>    Integer iResult
9793>>>>>    UWide   uwSubBlock
9793>>>>>    UWide   uwSubBlock
9793>>>>>    
9793>>>>>    Send StringToWide pSubBlock (&uwSubBlock)
9794>>>>>    
9794>>>>>    Move (VerQueryValueW (pBlock, uwSubBlock.lpUText, paBuffer, puLen)) to iResult        
9795>>>>>    
9795>>>>>    Function_Return iResult
9796>>>>>End_Function
9797>>>>>
9797>>>>>
9797>>>>>Class cVersionInfo is a cObject
9798>>>>>    Procedure Construct_Object
9800>>>>>        Forward Send Construct_Object
9802>>>>>        
9802>>>>>        
9802>>>>>        Property Integer piVersionMajor
9803>>>>>        Property Integer piVersionMinor
9804>>>>>        Property Integer piVersionRelease
9805>>>>>        Property Integer piVersionBuild
9806>>>>>        
9806>>>>>        Property Boolean pbIncluded
9807>>>>>        Property Boolean pbSpecialBuild
9808>>>>>        Property Boolean pbPrivateBuild
9809>>>>>        
9809>>>>>    End_Procedure
9810>>>>>    
9810>>>>>    Procedure DoCreate WString sFileName
9812>>>>>        DWord dwHandle
9812>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
9812>>>>>        WString sData
9812>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9812>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9812>>>>>        WString sSubBlock
9812>>>>>        Pointer pVsFixedFileInfo
9812>>>>>        
9812>>>>>        Move 0 to pVsFixedFileInfo
9813>>>>>        Move 0 to dwHandle
9814>>>>>        Move 0 to iVerSize
9815>>>>>        
9815>>>>>        Move (GetFileVersionInfoSizeW(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
9816>>>>>        Set pbIncluded to (iInfoSize <>0)
9817>>>>>        
9817>>>>>        If (pbIncluded(Self)) Begin
9819>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
9820>>>>>            Move (GetFileVersionInfoW(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
9821>>>>>            
9821>>>>>            If (iSuccess <>0) Begin
9823>>>>>                Move "\" to sSubBlock
9824>>>>>                If (VerQueryValueW(AddressOf(sData), AddressOf(sSubBlock), AddressOf(pVsFixedFileInfo), AddressOf(iVerSize))) Begin
9826>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), pVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
9827>>>>>                    
9827>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
9828>>>>>                    Set piVersionMajor to (Hi(iVersion))
9829>>>>>                    Set piVersionMinor to (Low(iVersion))
9830>>>>>                    
9830>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
9831>>>>>                    Set piVersionRelease to (Hi(iVersion))
9832>>>>>                    Set piVersionBuild   to (Low(iVersion))
9833>>>>>                    
9833>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
9834>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
9835>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
9836>>>>>                End
9836>>>>>>
9836>>>>>            End
9836>>>>>>
9836>>>>>            
9836>>>>>        End
9836>>>>>>
9836>>>>>    End_Procedure
9837>>>>>    
9837>>>>>End_Class
9838>>>Use GlobalFunctionsProcedures.pkg
9838>>>Use tWinStructs.pkg
9838>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
9838>>>
9838>>>Register_Function phoWorkspace Returns Handle
9838>>>Register_Function phoCommandLine Returns Handle
9838>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
9838>>>Register_Function GetApplicationName Returns String
9838>>>Register_Function GetApplicationFileName Returns String
9838>>>
9838>>>Register_Function Statusbar_State Returns Integer
9838>>>Register_Function Toolbar_State Returns Integer
9838>>>Register_Procedure Set Statusbar_State
9838>>>Register_Procedure Set Toolbar_State
9838>>>
9838>>>
9838>>>Class cApplication is a cObject
9839>>>    Procedure Construct_Object
9841>>>        Forward Send Construct_Object
9843>>>        
9843>>>        Move Self to ghoApplication
9844>>>        
9844>>>        Property Handle phoVersionInfo
9845>>>        Property Handle phoWorkspace
9846>>>        Property Handle phoCommandLine
9847>>>        Property Handle phoMainPanel       // main panel will set this for us.
9848>>>        Property String psHelpFile         // type of file is determined by peHelpType
9849>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
9850>>>        
9850>>>        Property String psCompany "Data Access Worldwide"
9851>>>        Property String psProduct "DataFlex Applications"
9852>>>        Property String psVersion C_DFVersion
9853>>>        Property String psProgram (Module_Name(desktop))
9854>>>        
9854>>>        // set to '' to stop the auto open workspace behavior
9854>>>        Property String psAutoOpenWorkspace 'Config.ws'
9855>>>        
9855>>>        
9855>>>        Property Boolean pbPreserveEnvironment True
9856>>>        
9856>>>        Object oCommandLine is a cCommandLine
9858>>>            Delegate Set phoCommandLine to Self
9860>>>        End_Object
9861>>>        
9861>>>        Object oWorkspace is a cWorkspace
9863>>>            Delegate Set phoWorkspace to Self
9865>>>        End_Object
9866>>>        
9866>>>        Object oVersionInfo is a cVersionInfo
9868>>>            Delegate Set phoVersionInfo to Self
9870>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
9871>>>        End_Object
9872>>>        
9872>>>        Set pbUseWindowsFont to True
9873>>>        
9873>>>    End_Procedure
9874>>>    
9874>>>    Procedure Destroy_Object
9876>>>        If (ghoApplication=Self) Begin
9878>>>            Move 0 to ghoApplication
9879>>>        End
9879>>>>
9879>>>        Forward Send Destroy_Object
9881>>>    End_Procedure
9882>>>    
9882>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
9882>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
9882>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
9884>>>        Move bNext to gbKEnterNext
9885>>>    End_Procedure
9886>>>    
9886>>>    Function pbEnterKeyAsTabKey Returns Boolean
9888>>>        Function_Return gbKEnterNext
9889>>>    End_Function
9890>>>    
9890>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
9892>>>// not used with webapp
9892>>>        Handle hoRegistry hoCommandBars
9892>>>        Handle hMonitor
9892>>>        Integer iError cxy
9892>>>        tWinWindowPlacement WindowPlacement
9892>>>        tWinWindowPlacement WindowPlacement
9892>>>        String sKey
9892>>>        Boolean bSuccess
9892>>>        String sObjectName
9892>>>        
9892>>>        If (pbPreserveEnvironment(Self)) Begin
9894>>>            Get Create U_cRegistry to hoRegistry
9895>>>            Set pfAccessRights of hoRegistry to KEY_READ
9896>>>            
9896>>>            Get RegistryKeyString to sKey
9897>>>            
9897>>>            If (bProgram = False) Begin
9899>>>                Move (sKey +"\WINDOWS") to sKey
9900>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9901>>>                Move (sKey +"\" +sObjectName) to sKey
9902>>>            End
9902>>>>
9902>>>            Else ;                Move (sKey + "\Preferences") to sKey
9904>>>            
9904>>>            Get OpenKey of hoRegistry sKey to bSuccess
9905>>>            
9905>>>            If bSuccess Begin
9907>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
9909>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
9910>>>                    If bSuccess Begin
9912>>>                        // Do not restore size if the window is not resizable
9912>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
9914>>>                            // restore always works with outer size
9914>>>                            Get GuiWindowSize     of hoContainer to cxy
9915>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
9916>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
9917>>>                        End
9917>>>>
9917>>>                        
9917>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
9917>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
9917>>>                        If (bProgram) Begin
9919>>>                            // Test the top left point
9919>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
9920>>>                            
9920>>>                            If (hMonitor = 0) Begin
9922>>>                                // test the bottom right point
9922>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
9923>>>                            End
9923>>>>
9923>>>                            
9923>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
9923>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
9923>>>                            If (hMonitor = 0) Begin
9925>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
9926>>>                            End
9926>>>>
9926>>>                        End
9926>>>>
9926>>>                        
9926>>>                        // Set the placement
9926>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9927>>>                    End
9927>>>>
9927>>>                End
9927>>>>
9927>>>                If bProgram Begin
9929>>>                    Get phoCommandBars of hoContainer to hoCommandBars
9930>>>                    If not hoCommandBars Begin
9932>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
9935>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
9938>>>                    End
9938>>>>
9938>>>                End
9938>>>>
9938>>>                
9938>>>                Send CloseKey of hoRegistry
9939>>>            End
9939>>>>
9939>>>            
9939>>>            Send Destroy of hoRegistry
9940>>>        End
9940>>>>
9940>>>    End_Procedure
9941>>>    
9941>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
9943>>>// not used with webapp
9943>>>        Handle hoRegistry
9943>>>        Integer iError
9943>>>        tWinWindowPlacement WindowPlacement
9943>>>        tWinWindowPlacement WindowPlacement
9943>>>        String sKey
9943>>>        Boolean bSuccess
9943>>>        Integer eShowCmd
9943>>>        String sObjectName
9943>>>        
9943>>>        If (pbPreserveEnvironment(Self)) Begin
9945>>>            Get Create U_cRegistry to hoRegistry
9946>>>            Get RegistryKeyString to sKey
9947>>>            
9947>>>            If (bProgram = False) Begin
9949>>>                Move (sKey +"\WINDOWS") to sKey
9950>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9951>>>                Move (sKey +"\" +sObjectName) to sKey
9952>>>            End
9952>>>>
9952>>>            Else ;                Move (sKey +"\Preferences") to sKey
9954>>>            
9954>>>            Get CreateKey of hoRegistry sKey to iError
9955>>>            If (iError = 0) Begin
9957>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
9958>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9959>>>                If bSuccess Begin
9961>>>                    // if minimized, assume restored, as we don't want to restart minimized!
9961>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
9963>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
9964>>>                    End
9964>>>>
9964>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
9965>>>                End
9965>>>>
9965>>>                
9965>>>                If bProgram Begin
9967>>>                    Send WriteInteger of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
9968>>>                    Send WriteInteger of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
9969>>>                End
9969>>>>
9969>>>                
9969>>>                
9969>>>                Send CloseKey of hoRegistry
9970>>>            End
9970>>>>
9970>>>            
9970>>>            Send Destroy of hoRegistry
9971>>>        End
9971>>>>
9971>>>    End_Procedure
9972>>>    
9972>>>    
9972>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
9974>>>        Integer ixySize ixSize iySize
9974>>>        Integer ixOffset iyOffset
9974>>>        
9974>>>        // first calculate the offset needed to move onto the main monitor at 0,0
9974>>>        Move (0 - WindowPos.left) to ixOffset
9975>>>        Move (0 - WindowPos.top) to iyOffset
9976>>>        
9976>>>        Move 0 to WindowPos.left
9977>>>        Move 0 to WindowPos.top
9978>>>        
9978>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
9979>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
9980>>>        
9980>>>        // also make sure that the size of the window is <= the size of the main monitor
9980>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
9981>>>        Move (low(ixySize))      to ixSize
9982>>>        Move (hi(ixySize))       to iySize
9983>>>        
9983>>>        Move (ixSize min WindowPos.right) to WindowPos.right
9984>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
9985>>>    End_Procedure
9986>>>    
9986>>>    
9986>>>    Function RegistryKeyString Returns String
9988>>>        String sCompany sProduct sVersion sProgram
9988>>>        
9988>>>        Get psCompany to sCompany
9989>>>        Get psProduct to sProduct
9990>>>        Get psVersion to sVersion
9991>>>        Get psProgram to sProgram
9992>>>        
9992>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
9995>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
9998>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
10001>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
10004>>>        
10004>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
10005>>>    End_Function
10006>>>    
10006>>>    Procedure WriteString String sSubKey String sValueName String sValueData
10008>>>        String sKey
10008>>>        Handle hoRegistry
10008>>>        Integer iError
10008>>>        
10008>>>        Get Create U_cRegistry to hoRegistry
10009>>>        Get RegistryKeyString to sKey
10010>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10013>>>        Get CreateKey of hoRegistry sKey to iError
10014>>>        If (iError = 0) Begin
10016>>>            Send WriteString of hoRegistry sValueName sValueData
10017>>>            Send CloseKey of hoRegistry
10018>>>        End
10018>>>>
10018>>>        
10018>>>        Send Destroy of hoRegistry
10019>>>    End_Procedure
10020>>>    
10020>>>    Procedure WriteInteger String sSubKey String sValueName Integer iValueData
10022>>>        String sKey
10022>>>        Handle hoRegistry
10022>>>        Integer iError
10022>>>        
10022>>>        Get Create U_cRegistry to hoRegistry
10023>>>        Get RegistryKeyString to sKey
10024>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10027>>>        Get CreateKey of hoRegistry sKey to iError
10028>>>        If (iError = 0) Begin
10030>>>            Send WriteInteger of hoRegistry sValueName iValueData
10031>>>            Send CloseKey of hoRegistry
10032>>>        End
10032>>>>
10032>>>        
10032>>>        Send Destroy of hoRegistry
10033>>>    End_Procedure
10034>>>    
10034>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
10034>>>    Procedure WriteDword String sSubKey String sValueName Integer iValueData
10036>>>        Send WriteInteger of Self sSubKey sValueName iValueData 
10037>>>    End_Procedure
10038>>>    
10038>>>    Procedure WriteUInteger String sSubKey String sValueName UInteger uValueData
10040>>>        String sKey
10040>>>        Handle hoRegistry
10040>>>        Integer iError
10040>>>        
10040>>>        Get Create U_cRegistry to hoRegistry
10041>>>        Get RegistryKeyString to sKey
10042>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10045>>>        Get CreateKey of hoRegistry sKey to iError
10046>>>        If (iError = 0) Begin
10048>>>            Send WriteUInt of hoRegistry sValueName uValueData
10049>>>            Send CloseKey of hoRegistry
10050>>>        End
10050>>>>
10050>>>        
10050>>>        Send Destroy of hoRegistry
10051>>>    End_Procedure
10052>>>
10052>>>    Procedure WriteBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength
10054>>>        String sKey
10054>>>        Handle hoRegistry
10054>>>        Integer iError
10054>>>        
10054>>>        Get Create U_cRegistry to hoRegistry
10055>>>        Get RegistryKeyString to sKey
10056>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10059>>>        Get CreateKey of hoRegistry sKey to iError
10060>>>        If (iError = 0) Begin
10062>>>            Send WriteBinary of hoRegistry sValueName pValueData iDataLength
10063>>>            Send CloseKey of hoRegistry
10064>>>        End
10064>>>>
10064>>>        
10064>>>        Send Destroy of hoRegistry
10065>>>    End_Procedure
10066>>>    
10066>>>    // returns true if both sub-key and value exists.
10066>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
10068>>>        String sKey
10068>>>        Handle hoRegistry
10068>>>        Boolean bOK
10068>>>        Get Create U_cRegistry to hoRegistry
10069>>>        Get RegistryKeyString to sKey
10070>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10073>>>        Get OpenKey of hoRegistry sKey to bOk
10074>>>        If (bOK) Begin
10076>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
10077>>>            Send CloseKey of hoRegistry
10078>>>        End
10078>>>>
10078>>>        Send Destroy of hoRegistry
10079>>>        Function_Return bOk
10080>>>    End_Function
10081>>>    
10081>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
10083>>>        String sKey sData
10083>>>        Handle hoRegistry
10083>>>        Boolean bOK
10083>>>        
10083>>>        Move sDefault to sData
10084>>>        Get Create U_cRegistry to hoRegistry
10085>>>        Get RegistryKeyString to sKey
10086>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10089>>>        Get OpenKey of hoRegistry sKey to bOk
10090>>>        If (bOK) Begin
10092>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
10095>>>            Send CloseKey of hoRegistry
10096>>>        End
10096>>>>
10096>>>        
10096>>>        Send Destroy of hoRegistry
10097>>>        Function_Return sData
10098>>>    End_Function
10099>>>    
10099>>>    Function ReadInteger String sSubKey String sValueName Integer iDefault Returns Integer
10101>>>        String sKey
10101>>>        Integer iData
10101>>>        Handle hoRegistry
10101>>>        Boolean bOK
10101>>>        
10101>>>        Move iDefault to iData
10102>>>        Get Create U_cRegistry to hoRegistry
10103>>>        Get RegistryKeyString to sKey
10104>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10107>>>        Get OpenKey of hoRegistry sKey to bOk
10108>>>        If bOK Begin
10110>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadInteger of hoRegistry sValueName to iData
10113>>>            Send CloseKey of hoRegistry
10114>>>        End
10114>>>>
10114>>>        
10114>>>        Send Destroy of hoRegistry
10115>>>        Function_Return iData
10116>>>    End_Function
10117>>>
10117>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
10117>>>    Function ReadDword String sSubKey String sValueName Integer iDefault Returns Integer
10119>>>        Function_Return (ReadInteger(Self, sSubKey, sValueName, iDefault))
10120>>>    End_Function
10121>>>    
10121>>>    Function ReadUInt String sSubKey String sValueName UInteger uDefault Returns UInteger
10123>>>        String sKey
10123>>>        UInteger uData
10123>>>        Handle hoRegistry
10123>>>        Boolean bOK
10123>>>        
10123>>>        Move uDefault to uData
10124>>>        Get Create U_cRegistry to hoRegistry
10125>>>        Get RegistryKeyString to sKey
10126>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10129>>>        Get OpenKey of hoRegistry sKey to bOk
10130>>>        If bOK Begin
10132>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadUInt of hoRegistry sValueName to uData
10135>>>            Send CloseKey of hoRegistry
10136>>>        End
10136>>>>
10136>>>        
10136>>>        Send Destroy of hoRegistry
10137>>>        Function_Return uData
10138>>>    End_Function
10139>>>    
10139>>>    Function ReadBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength Returns Boolean
10141>>>        String sKey
10141>>>        Handle hoRegistry
10141>>>        Boolean bOK bSuccess
10141>>>        
10141>>>        Get Create U_cRegistry to hoRegistry
10142>>>        Get RegistryKeyString to sKey
10143>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10146>>>        Get OpenKey of hoRegistry sKey to bOk
10147>>>        If bOK Begin
10149>>>            Get ReadBinary of hoRegistry sValueName pValueData iDataLength to bSuccess
10150>>>            Send CloseKey of hoRegistry
10151>>>        End
10151>>>>
10151>>>        
10151>>>        Send Destroy of hoRegistry
10152>>>        Function_Return bSuccess
10153>>>    End_Function
10154>>>    
10154>>>    Procedure DoOpenWorkspace String sWorkspace
10156>>>        // Tries to open in this order:
10156>>>        // 1) if absolute path, use that; otherwise
10156>>>        // 2) try to open in the path of the EXE; otherwise
10156>>>        // 3) load it via the Registered list
10156>>>        
10156>>>        Integer eOpened
10156>>>        String sError sWSFile
10156>>>        Handle hoWorkspace
10156>>>        Boolean bChangingWorkspace
10156>>>        
10156>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
10156>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
10156>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
10156>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
10156>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
10156>>>        // that there should be no automatic opening of a worskpace.
10156>>>        Set psAutoOpenWorkspace to ""
10157>>>        
10157>>>        Get phoWorkspace to hoWorkspace
10158>>>        
10158>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
10159>>>        If (bChangingWorkspace and ghoConnection) Begin
10161>>>            Send AutoDisconnect
10162>>>        End
10162>>>>
10162>>>        
10162>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
10163>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
10165>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
10167>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
10168>>>            End
10168>>>>
10168>>>        End
10168>>>>
10168>>>        If (eOpened <> wsWorkspaceOpened) Begin
10170>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
10171>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
10172>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
10173>>>>
10173>>>            Abort
10174>>>>
10174>>>        End
10174>>>>
10174>>>        Else Begin
10175>>>            Send AutoConnect
10176>>>            Send OnWorkspaceOpened
10177>>>        End
10177>>>>
10177>>>    End_Procedure
10178>>>    
10178>>>    Procedure AutoConnect
10180>>>        If (ghoConnection) Begin
10182>>>            Send AutoConnect of ghoConnection
10183>>>        End
10183>>>>
10183>>>    End_Procedure
10184>>>    
10184>>>    Procedure AutoDisconnect
10186>>>        If (ghoConnection) Begin
10188>>>            Send AutoDisconnect of ghoConnection
10189>>>        End
10189>>>>
10189>>>    End_Procedure
10190>>>    
10190>>>    // send after a workspace is successfully opened and connected
10190>>>    Procedure OnWorkspaceOpened
10192>>>    End_Procedure
10193>>>    
10193>>>    Procedure OnCreate
10195>>>        // Event called when the Application object is ready to be used
10195>>>        // to open a Workspace, etc.
10195>>>    End_Procedure
10196>>>    
10196>>>    Procedure End_Construct_Object
10198>>>        String sName
10198>>>        Forward Send End_Construct_Object
10200>>>        Send OnCreate
10201>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
10201>>>        Get psAutoOpenWorkspace to sName
10202>>>        If (sName<>"") Begin
10204>>>            Send DoOpenWorkspace sName
10205>>>        End
10205>>>>
10205>>>    End_Procedure
10206>>>    
10206>>>    Function GetApplicationFileName Returns String
10208>>>        // Returns the filename from Windows
10208>>>        Integer iNumChars
10208>>>        WString wFilename
10208>>>                
10208>>>        Move (Repeat(Character(0), 1024)) to wFilename
10209>>>        Move (GetModuleFileNameW(0, AddressOf(wFilename), 1024)) to iNumChars
10210>>>        
10210>>>        Function_Return (CString(wFilename))
10211>>>    End_Function
10212>>>    
10212>>>    Function GetApplicationPath Returns String
10214>>>        // Returns the path of the Application (no trailing "\")
10214>>>        WString wApplicationFileName 
10214>>>        String sPath
10214>>>        Boolean bRemoved
10214>>>        
10214>>>        Get GetApplicationFileName  to wApplicationFileName
10215>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
10216>>>        Move (CString(wApplicationFileName)) to sPath
10217>>>        
10217>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
10220>>>        Function_Return sPath
10221>>>    End_Function
10222>>>    
10222>>>    Function GetApplicationName Returns String
10224>>>        // Returns the name of the Application (without its Path or Extension)
10224>>>        String sApplicationFileName 
10224>>>        WString wApplicationName
10224>>>        Boolean bRemoved
10224>>>        Integer iVoid
10224>>>        
10224>>>        Get GetApplicationFileName to sApplicationFileName
10225>>>        Move (ExtractFileName(sApplicationFileName)) to wApplicationName
10226>>>        Move (PathRemoveExtensionW(AddressOf(wApplicationName))) to iVoid
10227>>>        Function_Return (CString(wApplicationName))
10228>>>    End_Function
10229>>>    
10229>>>    Function DFRootPath Returns String
10231>>>        String sRoot
10231>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
10234>>>        // Ensure it does not contain a trailing "\"
10234>>>        If (Right(sRoot,1) = "\") Begin
10236>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
10237>>>        End
10237>>>>
10237>>>        Function_Return sRoot
10238>>>    End_Function
10239>>>    
10239>>>    Function DFBinPath Returns String
10241>>>        String sRoot
10241>>>        Get DFRootPath to sRoot
10242>>>        If (sRoot<>"") Begin
10244>>>            Move (sRoot+"\bin") to sRoot
10245>>>        End
10245>>>>
10245>>>        Else Begin
10246>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
10246>>>            // bin path must be the same as the application path.
10246>>>            Get GetApplicationPath to sRoot
10247>>>        End
10247>>>>
10247>>>        Function_Return sRoot
10248>>>    End_Function
10249>>>    
10249>>>    // this just directs to the desktop property. If you are using an application object you are
10249>>>    // encouraged to set this here.
10249>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
10251>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
10252>>>    End_Procedure
10253>>>    
10253>>>    Function pbUseWindowsFont Returns Boolean
10255>>>        Boolean bUseWindowsFont
10255>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
10256>>>        Function_Return bUseWindowsFont
10257>>>    End_Function
10258>>>    
10258>>>    // this just directs to the desktop property. If you are using an application object you are
10258>>>    // encouraged to set this here.
10258>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
10260>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
10261>>>    End_Procedure
10262>>>    
10262>>>    Function pbLegacyDialogRatio Returns Boolean
10264>>>        Boolean bLegacy
10264>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
10265>>>        Function_Return bLegacy
10266>>>    End_Function
10267>>>End_Class
10268>>>
10268>>>
10268>Use cConnection.pkg
Including file: cConnection.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cConnection.pkg)
10268>>>Use vdfbase.pkg // Windows.pkg
10268>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cli.pkg)
10268>>>>>//                                                              
10268>>>>>//   CLI specific functionality. There are several connectivity kits     
10268>>>>>//   based on  SQL/92 CLI. Those are:                                    
10268>>>>>//    - ODBC_DRV  The Data Access CK for ODBC                            
10268>>>>>//    - DB2_DRV   The Data Access CK for DB2                             
10268>>>>>//    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            
10268>>>>>//                                                                       
10268>>>>>//   This package defines the common functionality for all CLI based     
10268>>>>>//   drivers.                                                            
10268>>>>>
10268>>>>>Define DF_FILE_TABLE_CHARACTER_FORMAT   for 601
10268>>>>>Define DF_FILE_MAX_ROWS_FETCHED         for 602
10268>>>>>Define DF_FILE_PRIMARY_INDEX_TRIGGER    for 604      // Replaced by DF_FILE_GENERATE_RECORD_ID_METHOD !
10268>>>>>Define DF_FILE_TRANSLATE_OEM_TO_ANSI    for 606      // Deprecated !!! Only defined for decent error reporting
10268>>>>>Define DF_FILE_REFIND_AFTER_SAVE        for 608
10268>>>>>Define DF_FILE_TABLE_NAME               for 609
10268>>>>>Define DF_FILE_GET_RID_AFTER_CREATE     for 610
10268>>>>>Define DF_FILE_SQL_FILTER               for 611
10268>>>>>Define DF_FILE_USE_DUMMY_ZERO_DATE      for 612
10268>>>>>Define DF_FILE_GENERATE_RECORD_ID_METHOD for 614
10268>>>>>Define DF_FILE_DUMMY_UPDATE_COLUMN      for 616
10268>>>>>Define DF_FILE_FETCH_ALL_COLUMNS        for 620
10268>>>>>Define DF_FILE_DATABASE_ID              for 622
10268>>>>>Define DF_FILE_SQL_FILTER_ACTIVE        for 624
10268>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS     for 626
10268>>>>>Define DF_FILE_BLOCK_SIZE               for 628
10268>>>>>Define DF_FILE_JIT_BINDING              for 630
10268>>>>>Define DF_FILE_FINDCACHE_HITS           for 632
10268>>>>>Define DF_FILE_FINDCACHE_TIMEOUTS       for 634
10268>>>>>Define DF_FILE_SQL_FILTER_EQ            for 636
10268>>>>>Define DF_FILE_RESTRUCTURE_INT_ONLY     for 638
10268>>>>>Define DF_FILE_ALLOWED_STRUCTURE_CHANGES for 640
10268>>>>>
10268>>>>>Define DF_FIELD_STORE_TIME              for 702
10268>>>>>Define DF_FIELD_TIME                    for 703
10268>>>>>Define DF_FIELD_IS_NULL                 for 704
10268>>>>>Define DF_FIELD_NULL_ALLOWED            for 706
10268>>>>>Define DF_FIELD_DEFAULT_VALUE           for 707
10268>>>>>Define DF_FIELD_FETCH_STATE             for 708
10268>>>>>Define DF_FIELD_READ_ONLY               for 710
10268>>>>>Define DF_FIELD_NATIVE_TYPE_NAME        for 711
10268>>>>>Define DF_FIELD_NATIVE_TYPE             for 712
10268>>>>>Define DF_FIELD_NO_OEM_ANSI_TRANSLATE   for 714
10268>>>>>Define DF_SQL_RELATION_COLUMN           for 716
10268>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA   for 717
10268>>>>>Define DF_FIELD_NATIVE_SIZE             for 718
10268>>>>>Define DF_SQL_RELATION_RELATED_TABLE    for 719
10268>>>>>Define DF_SQL_RELATION_RELATED_COLUMN   for 721
10268>>>>>Define DF_FIELD_IS_IDENTITY             for 722
10268>>>>>Define DF_FIELD_SQL_COLUMN_NAME         for 723
10268>>>>>
10268>>>>>Define DF_INDEX_NAME                    for 801
10268>>>>>Define DF_INDEX_UNIQUE                  for 802
10268>>>>>Define DF_INDEX_ON_BACKEND              for 804
10268>>>>>
10268>>>>>Define DF_INDEX_CLUSTERED               for 806
10268>>>>>Define DF_INDEX_SQL_PRIMARY_KEY         for 808
10268>>>>>Define DF_INDEX_SQL_TYPE                for 810
10268>>>>>Define DF_INDEX_NUMBER                  for 812
10268>>>>>
10268>>>>>Define DF_DATABASE_LOCK_STATE                    for 1001
10268>>>>>Define DF_DATABASE_ID                            for 1002
10268>>>>>Define DF_DATABASE_MYSQLTABLETYPE                for 1003
10268>>>>>Define DF_DATABASE_NUMBER_TYPES                  for 1004
10268>>>>>Define DF_DATABASE_TYPE_NAME                     for 1005
10268>>>>>Define DF_DATABASE_TYPE_ID                       for 1006
10268>>>>>Define DF_DATABASE_TYPE_CREATE_PARAMS            for 1007
10268>>>>>Define DF_DATABASE_TYPE_AUTOINC                  for 1008
10268>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_ASCII         for 1009
10268>>>>>Define DF_DATABASE_TYPE_UNSIGNED                 for 1010
10268>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_NUMERIC       for 1011
10268>>>>>Define DF_DATABASE_TYPE_MAXSIZE                  for 1012
10268>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATE          for 1013
10268>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_ASCII        for 1014
10268>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_TEXT          for 1015
10268>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_NUMERIC      for 1016
10268>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_BINARY        for 1017
10268>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATE         for 1018
10268>>>>>Define DF_DATABASE_DUMMY_ZERO_DATE_VALUE         for 1019
10268>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_TEXT         for 1020
10268>>>>>Define DF_DATABASE_DUPREC_STATE                  for 1021
10268>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_BINARY       for 1022
10268>>>>>Define DF_DATABASE_MAX_ACTIVE_STATEMENTS         for 1024
10268>>>>>Define DF_DATABASE_DRIVER_DECIMAL_SEPARATOR      for 1026
10268>>>>>Define DF_DATABASE_DRIVER_THOUSANDS_SEPARATOR    for 1028
10268>>>>>
10268>>>>>Define DF_DATABASE_DRIVER_DATE_FORMAT            for 1030
10268>>>>>Define DF_DATABASE_DRIVER_DATE_SEPARATOR         for 1032
10268>>>>>Define DF_DATABASE_IGNORE_UCASE_SUPPORT          for 1034
10268>>>>>Define DF_DATABASE_INDEX_CREATE                  for 1036
10268>>>>>Define DF_DATABASE_INDEX_DROP                    for 1038
10268>>>>>Define DF_DATABASE_INDEX_ASC                     for 1040
10268>>>>>Define DF_DATABASE_INDEX_DESC                    for 1042
10268>>>>>Define DF_DATABASE_COLUMN_CREATE_DEFAULTCLAUSE   for 1044
10268>>>>>Define DF_DATABASE_DUPREC_ERRORNUMBER            for 1046
10268>>>>>Define DF_DATABASE_USE_IDENTITY_TYPE             for 1048
10268>>>>>Define DF_DATABASE_NUMBER_NATIVE_LOCKERRORS      for 1050
10268>>>>>Define DF_DATABASE_NATIVE_LOCKERROR              for 1052
10268>>>>>Define DF_DATABASE_DEFAULT_MAX_ROWS              for 1054
10268>>>>>Define DF_DATABASE_IGNORE_WARNINGS               for 1056
10268>>>>>Define DF_DATABASE_USE_DF_LOCKERROR              for 1058
10268>>>>>Define DF_DATABASE_FIND_CACHE_TIMEOUT            for 1060
10268>>>>>Define DF_DATABASE_JIT_TRESHOLD                  for 1062
10268>>>>>Define DF_DATABASE_TRUNCATE_BINARY_ZEROES        for 1064
10268>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATETIME      for 1065
10268>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATETIME     for 1066
10268>>>>>Define DF_DATABASE_MAP_DFDATE_TO_ODBCTYPE         for 1068
10268>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_ODBCTYPE     for 1070
10268>>>>>Define DF_DATABASE_MAP_DFASCII_TO_ODBCTYPE        for 1072
10268>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_ODBCTYPE         for 1074
10268>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_ODBCTYPE       for 1076
10268>>>>>Define DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1078
10268>>>>>
10268>>>>>Define DF_DATABASE_MAP_DFDATE_TO_SQLTYPE         for 1069
10268>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_SQLTYPE     for 1071
10268>>>>>Define DF_DATABASE_MAP_DFASCII_TO_SQLTYPE        for 1073
10268>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_SQLTYPE         for 1075
10268>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_SQLTYPE       for 1077
10268>>>>>Define DF_DATABASE_DEFAULT_DATABASE              for 1079
10268>>>>>Define DF_DATABASE_TRIM_VARCHAR_VALUES           for 1084
10268>>>>>Define DF_DATABASE_IDENTIFIER_QUOTE              for 1085
10268>>>>>Define DF_DATABASE_ODBC_DRIVER_NAME              for 1087
10268>>>>>
10268>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_ASCII           for 1101
10268>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_ASCII          for 1102
10268>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_NUMERIC         for 1103
10268>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_NUMERIC        for 1104
10268>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATE            for 1105
10268>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATE           for 1106
10268>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_TEXT            for 1107
10268>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_TEXT           for 1108
10268>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_BINARY          for 1109
10268>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_BINARY         for 1110
10268>>>>>Define DF_DRIVER_DUMMY_ZERO_DATE_VALUE           for 1111
10268>>>>>Define DF_DRIVER_MAX_ACTIVE_STATEMENTS           for 1112
10268>>>>>Define DF_DRIVER_CACHE_PATH                      for 1113
10268>>>>>Define DF_DRIVER_DRIVER_DECIMAL_SEPARATOR        for 1114
10268>>>>>Define DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT  for 1115
10268>>>>>Define DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR      for 1116
10268>>>>>Define DF_DRIVER_APPLICATION_CHARACTER_FORMAT    for 1117
10268>>>>>Define DF_DRIVER_DRIVER_DATE_FORMAT              for 1118
10268>>>>>Define DF_DRIVER_LAST_ERROR_TEXT                 for 1119
10268>>>>>Define DF_DRIVER_DRIVER_DATE_SEPARATOR           for 1120
10268>>>>>Define DF_DRIVER_CONNECTION_ID                   for 1121
10268>>>>>Define DF_DRIVER_IGNORE_UCASE_SUPPORT            for 1122
10268>>>>>Define DF_DRIVER_CONNECTION_ID_STRING            for 1123
10268>>>>>Define DF_DRIVER_IGNORE_WARNINGS                 for 1124
10268>>>>>Define DF_DRIVER_USE_DF_LOCKERROR                for 1126
10268>>>>>Define DF_DRIVER_FIND_CACHE_TIMEOUT              for 1128
10268>>>>>Define DF_DRIVER_JIT_TRESHOLD                    for 1130
10268>>>>>Define DF_DRIVER_TRUNCATE_BINARY_ZEROES          for 1132
10268>>>>>Define DF_DRIVER_ERROR_DEBUG_MODE                for 1134
10268>>>>>Define DF_DRIVER_USE_CACHE                       for 1136
10268>>>>>Define DF_DRIVER_REPORT_CACHE_ERRORS             for 1138
10268>>>>>Define DF_DRIVER_USE_CACHE_EXPIRATION            for 1140
10268>>>>>Define DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE     for 1142
10268>>>>>Define DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING  for 1144
10268>>>>>Define DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS     for 1146
10268>>>>>Define DF_DRIVER_SILENT_LOGIN                    for 1148
10268>>>>>Define DF_DRIVER_DEFAULT_MAP_TO_RECNUM           for 1150
10268>>>>>Define DF_DRIVER_CONNECTION_ID_OPTIONS           for 1152
10268>>>>>Define DF_DRIVER_NUMBER_CONNECTION_IDS           for 1154
10268>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATETIME        for 1155
10268>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATETIME       for 1156
10268>>>>>Define DF_DRIVER_MATCH_CLIENT_SERVER_VERSION     for 1158
10268>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_VERSION        for 1160
10268>>>>>Define DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE          for 1168
10268>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE      for 1170
10268>>>>>Define DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE         for 1172
10268>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE          for 1174
10268>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE        for 1176
10268>>>>>Define DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1178
10268>>>>>Define DF_DRIVER_LOGIN_ON_OPEN                   for 1180
10268>>>>>Define DF_DRIVER_MINIMUM_CLIENT_VERSION          for 1182
10268>>>>>Define DF_DRIVER_TRIM_VARCHAR_VALUES             for 1184
10268>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_DRIVER_NAME    for 1187 
10268>>>>>
10268>>>>>Define DF_DRIVER_MAP_DFDATE_TO_SQLTYPE           for 1169
10268>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE       for 1171
10268>>>>>Define DF_DRIVER_MAP_DFASCII_TO_SQLTYPE          for 1173
10268>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE           for 1175
10268>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE         for 1177
10268>>>>>
10268>>>>>
10268>>>>>// Replacement for logical column number that indicates all columns
10268>>>>>Define DF_ALL_COLUMNS for -1
10268>>>>>
10268>>>>>// Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
10268>>>>>Define RIM_NONE            for 0
10268>>>>>Define RIM_IDENTITY_COLUMN for 1
10268>>>>>Define RIM_DISPENSER_TABLE for 2
10268>>>>>Define RIM_EXTERNAL        for 3
10268>>>>>
10268>>>>>// Possible DF_FIELD_READ_ONLY values
10268>>>>>Define RO_NO            for 0
10268>>>>>Define RO_IGNORECHANGE  for 1
10268>>>>>Define RO_ACCEPTCHANGE  for 2
10268>>>>>Define RO_ERRORONCHANGE for 3
10268>>>>>
10268>>>>>
10268>>>>>// Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
10268>>>>>Define MAP_DF_TO_SQL_TYPE_UNKNOWN    for 0
10268>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2000    for 3
10268>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2005    for 4
10268>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2008    for 5
10268>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2012    for 6
10268>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_LEGACY  for 7
10268>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_10      for 8
10268>>>>>Define MAP_DF_TO_SQL_TYPE_ODBC_SCHEMA for 9
10268>>>>>Define MAP_DF_TO_SQL_TYPE_UNICODE     for 11
10268>>>>>
10268>>>>>
10268>>>>>// Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values are defined in Mssqldrv.pkg
10268>>>>>
10268>>>>>// Possible SQL Column type values
10268>>>>>//      SQL Server specific types defined in mssqldrv.pkg
10268>>>>>//      DB2 specific typesm defined in db2_drv.pkg
10268>>>>>
10268>>>>>Define SQL_UNKNOWN_TYPE   for    0
10268>>>>>Define SQL_CHAR           for    1
10268>>>>>Define SQL_NUMERIC        for    2
10268>>>>>Define SQL_DECIMAL        for    3
10268>>>>>Define SQL_INTEGER        for    4
10268>>>>>Define SQL_SMALLINT       for    5
10268>>>>>Define SQL_FLOAT          for    6
10268>>>>>Define SQL_REAL           for    7
10268>>>>>Define SQL_DOUBLE         for    8
10268>>>>>Define SQL_DATETIME       for    9
10268>>>>>Define SQL_VARCHAR        for   12
10268>>>>>Define SQL_TYPE_DATE      for   91
10268>>>>>Define SQL_TYPE_TIME      for   92
10268>>>>>Define SQL_TYPE_TIMESTAMP for   93
10268>>>>>
10268>>>>>Define SQL_DATE           for    9
10268>>>>>Define SQL_INTERVAL       for   10
10268>>>>>Define SQL_TIME           for   10
10268>>>>>Define SQL_TIMESTAMP      for   11
10268>>>>>Define SQL_LONGVARCHAR    for  (-1)
10268>>>>>Define SQL_BINARY         for  (-2)
10268>>>>>Define SQL_VARBINARY      for  (-3)
10268>>>>>Define SQL_LONGVARBINARY  for  (-4)
10268>>>>>Define SQL_BIGINT         for  (-5)
10268>>>>>Define SQL_TINYINT        for  (-6)
10268>>>>>Define SQL_BIT            for  (-7)
10268>>>>>Define SQL_WCHAR          for  (-8)
10268>>>>>Define SQL_WVARCHAR       for  (-9)
10268>>>>>Define SQL_WLONGVARCHAR   for (-10)
10268>>>>>Define SQL_GUID           for (-11)
10268>>>>>
10268>>>>>// Possible DF_INDEX_SQL_TYPE values
10268>>>>>Define DF_INDEX_CLIENT      for  1
10268>>>>>Define DF_INDEX_SERVER      for  2
10268>>>>>Define DF_INDEX_SERVER_ONLY for  3
10268>>>>>Define DF_INDEX_TEMPORARY   for  4
10268>>>>>
10268>>>>>// Possible DF_FILE_ALLOWED_STRUCTURE_CHANGES values
10268>>>>>Define ALL_TABLE_CHANGES_ALLOWED            for  0
10268>>>>>Define ONLY_TABLE_INT_FILE_CHANGES_ALLOWED  for  1
10268>>>>>Define NO_TABLE_CHANGES_ALLOWED             for  2
10268>>>>>
10268>>>>>// Driver level attributes
10268>>>>>Define DRVR_TOKEN_BASE                       for 1000
10268>>>>>Define DRVR_ATTRIBUTE_START                  for (DRVR_TOKEN_BASE + 19)
10268>>>>>Define DRVR_DEFAULT_NULLABLE_ASCII           for (DRVR_ATTRIBUTE_START)
10268>>>>>Define DRVR_DEFAULT_NULLABLE_NUMERIC         for (DRVR_ATTRIBUTE_START +  1)
10268>>>>>Define DRVR_DEFAULT_NULLABLE_DATE            for (DRVR_ATTRIBUTE_START +  2)
10268>>>>>Define DRVR_DEFAULT_NULLABLE_TEXT            for (DRVR_ATTRIBUTE_START +  3)
10268>>>>>Define DRVR_DEFAULT_NULLABLE_BINARY          for (DRVR_ATTRIBUTE_START +  4)
10268>>>>>Define DRVR_DEFAULT_DEFAULT_ASCII            for (DRVR_ATTRIBUTE_START +  5)
10268>>>>>Define DRVR_DEFAULT_DEFAULT_NUMERIC          for (DRVR_ATTRIBUTE_START +  6)
10268>>>>>Define DRVR_DEFAULT_DEFAULT_DATE             for (DRVR_ATTRIBUTE_START +  7)
10268>>>>>Define DRVR_DEFAULT_DEFAULT_TEXT             for (DRVR_ATTRIBUTE_START +  8)
10268>>>>>Define DRVR_DEFAULT_DEFAULT_BINARY           for (DRVR_ATTRIBUTE_START +  9)
10268>>>>>Define DRVR_MAX_ACTIVE_STATEMENTS            for (DRVR_ATTRIBUTE_START + 10)
10268>>>>>Define DRVR_ERROR_DEBUG_MODE                 for (DRVR_ATTRIBUTE_START + 11)
10268>>>>>Define DRVR_DRIVER_DECIMAL_SEPARATOR         for (DRVR_ATTRIBUTE_START + 12)
10268>>>>>Define DRVR_DRIVER_THOUSANDS_SEPARATOR       for (DRVR_ATTRIBUTE_START + 13)
10268>>>>>Define DRVR_DRIVER_DATE_FORMAT               for (DRVR_ATTRIBUTE_START + 14)
10268>>>>>Define DRVR_DRIVER_DATE_SEPARATOR            for (DRVR_ATTRIBUTE_START + 15)
10268>>>>>Define DRVR_USE_CACHE                        for (DRVR_ATTRIBUTE_START + 16)
10268>>>>>Define DRVR_REPORT_CACHE_ERRORS              for (DRVR_ATTRIBUTE_START + 17)
10268>>>>>Define DRVR_CACHE_PATH                       for (DRVR_ATTRIBUTE_START + 18)
10268>>>>>Define DRVR_USE_CACHE_EXPIRATION             for (DRVR_ATTRIBUTE_START + 19)
10268>>>>>Define DRVR_DEFAULT_TABLE_CHARACTER_FORMAT   for (DRVR_ATTRIBUTE_START + 20)
10268>>>>>Define DRVR_APPLICATION_CHARACTER_FORMAT     for (DRVR_ATTRIBUTE_START + 21)
10268>>>>>Define DRVR_DUMMY_ZERO_DATE_VALUE            for (DRVR_ATTRIBUTE_START + 22)
10268>>>>>Define DRVR_DEFAULT_USE_DUMMY_ZERO_DATE      for (DRVR_ATTRIBUTE_START + 23)
10268>>>>>Define DRVR_IGNORE_UCASE_SUPPORT             for (DRVR_ATTRIBUTE_START + 24)
10268>>>>>Define DRVR_LASTERRORTEXTLENGTH              for (DRVR_ATTRIBUTE_START + 25)
10268>>>>>Define DRVR_LASTERRORTEXT                    for (DRVR_ATTRIBUTE_START + 26)
10268>>>>>Define DRVR_DEFAULTRECORDIDHIDING            for (DRVR_ATTRIBUTE_START + 35)
10268>>>>>Define DRVR_REPORTACTIVECOLUMNERRORS         for (DRVR_ATTRIBUTE_START + 36)
10268>>>>>
10268>>>>>
10268>>>>>// Error Number constants
10268>>>>>Define CLIERR_GENERAL_ERROR                       for 12289
10268>>>>>Define CLIERR_CANT_INITIALIZE                     for 12290
10268>>>>>Define CLIERR_CANT_DEINITIALIZE                   for 12291
10268>>>>>Define CLIERR_BAD_OR_NO_PRIMARY_INDEX_SPECIFIED   for 12292
10268>>>>>Define CLIERR_LOGIN_UNSUCCESSFUL                  for 12293
10268>>>>>Define CLIERR_LOGOUT_UNSUCCESSFUL                 for 12294
10268>>>>>Define CLIERR_TABLE_NOT_IN_CONNECTION             for 12295
10268>>>>>Define CLIERR_NULL_VALUE_NOT_ALLOWED              for 12296
10268>>>>>Define CLIERR_SEGMENT_NUMBER_RANGE                for 12297
10268>>>>>Define CLIERR_INDEX_NUMBER_RANGE                  for 12298
10268>>>>>Define CLIERR_LOGIN_ATTRIBUTE_MUST_BE_SET         for 12299
10268>>>>>Define CLIERR_PHYSICAL_NAME_MUST_BE_SET           for 12300
10268>>>>>Define CLIERR_INVALID_REGISTRATION_FILE           for 12301
10268>>>>>Define CLIERR_LICENSE_EXPIRED                     for 12302
10268>>>>>Define CLIERR_DEADLOCK_OR_TIMEOUT                 for 12303
10268>>>>>Define CLIERR_SQL_ERROR                           for 12304
10268>>>>>Define CLIERR_SQLINVALID_CLI_STMT_HANDLE          for 12305
10268>>>>>Define CLIERR_SQLINVALID_CLI_CONN_HANDLE          for 12306
10268>>>>>Define CLIERR_SQLINVALID_DRIVER_ID                for 12307
10268>>>>>Define CLIERR_SQLINVALID_BIND_FILE                for 12308
10268>>>>>Define CLIERR_SQLINVALID_COLUMN                   for 12309
10268>>>>>Define CLIERR_SQLINVALID_ATTRIBUTE                for 12310
10268>>>>>Define CLIERR_SQLINVALID_BUFFER                   for 12311
10268>>>>>Define CLIERR_INVALID_CONFIGURATION_KEYWORD       for 12312
10268>>>>>Define CLIERR_NOUNIQUEINDEX                       for 12313
10268>>>>>Define CLIERR_UCSEGMENT_NOT_SUPPORTED             for 12314
10268>>>>>Define CLIERR_FIELDREADONLY                       for 12315
10268>>>>>Define CLIERR_DBPROPERROR                         for 12316
10268>>>>>Define CLIERR_CANTSETRECNUMINACTIVE               for 12317
10268>>>>>Define CLIERR_CANTCHANGEINACTIVECOLUMN            for 12318
10268>>>>>Define CLIERR_FIELDISINACTIVE                     for 12319
10268>>>>>Define CLIERR_NOT_INSTALLED                       for 12320
10268>>>>>Define CLIERR_CANT_FIND_TERMLIST                  for 12321
10268>>>>>Define CLIERR_CANT_READ_TERMLIST                  for 12322
10268>>>>>Define CLIERR_MAX_USERS_EXCEEDED                  for 12323
10268>>>>>Define CLIERR_USER_COUNT_FILE_ERROR               for 12324
10268>>>>>Define CLIERR_CANT_INIT_USER_COUNT                for 12325
10268>>>>>Define CLIERR_USER_COUNT_FILE_NOT_FOUND           for 12326
10268>>>>>Define CLIERR_USER_COUNT_FILE_CANT_READ           for 12327
10268>>>>>Define CLIERR_USER_COUNT_FILE_CANT_DECRYPT        for 12328
10268>>>>>Define CLIERR_USER_COUNT_FILE_BAD_VERSION         for 12329
10268>>>>>Define CLIERR_CANTCREATE_RECNUMISZERO             for 12330
10268>>>>>Define CLIERR_CANTGETCOLUMNINFO                   for 12331
10268>>>>>Define CLIERR_INVALIDDATABASEHANDLE               for 12332
10268>>>>>Define CLIERR_TYPENUMBEROUTOFRANGE                for 12333
10268>>>>>Define CLIERR_LOCKERRORNUMBEROUTOFRANGE           for 12334
10268>>>>>Define CLIERR_CONNECTIONIDOUTOFRANGE              for 12335
10268>>>>>Define CLIERR_CONNECTIONIDNOTFOUND                for 12336
10268>>>>>Define CLIERR_RELATIONOUTOFRANGE                  for 12337
10268>>>>>Define CLIERR_NOTANEXPRESSEDITION                 for 12338
10268>>>>>Define CLIERR_INVALID_CONFIGURATION_VALUE         for 12339
10268>>>>>Define CLIERR_NOCLIENTSERVERVERSIONMATCH          for 12340
10268>>>>>Define CLIERR_CONNECTIONIDALREADYEXISTS           for 12341
10268>>>>>Define CLIERR_INVALIDCONNECTSTRINGOPENOPTION      for 12342
10268>>>>>Define CLIERR_DATABASECONNECTIONLOST              for 12343
10268>>>>>Define CLIERR_STRUCTURECHANGENOTALLOWED           for 12344
10268>>>>>Define CLIERR_MINIMUMCLIENTVERSIONNOTFOUND        for 12345
10268>>>>>
10268>>>>>
10268>>>>>// Call driver Function identifiers
10268>>>>>Define CLI_CONSTRAINT             for 10000
10268>>>>>Define CLI_SETDRIVERATTRIBUTE     for 10001
10268>>>>>Define CLI_GETDRIVERATTRIBUTE     for 10002
10268>>>>>Define CLI_BROWSECONNECT          for 10003
10268>>>>>Define CLI_DATASOURCES            for 10004
10268>>>>>Define CLI_CKREVISION             for 10005
10268>>>>>Define CLI_INITDATASOURCES        for 10006
10268>>>>>Define CLI_ENUMERATE_TABLES       for 10007
10268>>>>>Define CLI_TABLENAME              for 10008
10268>>>>>Define CLI_TABLESCHEMA            for 10009
10268>>>>>Define CLI_TABLETYPE              for 10010
10268>>>>>Define CLI_TABLECOMMENT           for 10011
10268>>>>>Define CLI_ENUMERATE_COLUMNS      for 10012
10268>>>>>Define CLI_COLUMNNAME             for 10013
10268>>>>>Define CLI_DUMPSTATUS             for 10014
10268>>>>>Define CLI_READCONFIGURATION      for 10015
10268>>>>>Define CLI_GETDBATTRIBUTE0        for 10016
10268>>>>>Define CLI_GETDBATTRIBUTE         for 10017
10268>>>>>Define CLI_GETREGNAME             for 10018
10268>>>>>Define CLI_GETSERIALNUM           for 10019
10268>>>>>Define CLI_GETMAXUSERS            for 10020
10268>>>>>Define CLI_BCP                    for 10021
10268>>>>>Define CLI_DROPINDICES            for 10022
10268>>>>>Define CLI_CREATEINDICES          for 10023
10268>>>>>Define CLI_REDIRECTCONNECTION     for 10024
10268>>>>>Define CLI_CREATECONNECTIONID     for 10025
10268>>>>>Define CLI_DELETECONNECTIONID     for 10026
10268>>>>>
10268>>>>>
10268>>>>>// Init data source types
10268>>>>>Define SQL_FETCH_ALL     for  2
10268>>>>>Define SQL_FETCH_USER    for 31
10268>>>>>Define SQL_FETCH_SYSTEM  for 32
10268>>>>>
10268>>>>>
10268>>>>>// Dummy strings used in the commands
10268>>>>>String  CLI$StrDummy 255
10268>>>>>Integer CLI$IntDummy
10268>>>>>
10268>>>>>
10268>>>>>//   Setup a constraint for a file.                                    
10268>>>>>
10268>>>>>
10268>>>>>
10268>>>>>// Set or get an attribute at driver level. These attributes, when set,
10268>>>>>// will be set for the remainder of the session or until set again. To 
10268>>>>>// permanently set driver level attributes change the driver           
10268>>>>>// configuration file.                                                 
10268>>>>>
10268>>>>>
10268>>>>>
10268>>>>>
10268>>>>>
10268>>>>>
10268>>>>>
10268>>>>>// An instance of this class can be used as a broker object to
10268>>>>>// call several CLI releated methods.                         
10268>>>>>
10268>>>>>//Class cCLIHandler is a cObject
10268>>>>>Class cCLIHandler is an Array
10269>>>>>    
10269>>>>>    Procedure Construct_Object 
10271>>>>>        Forward Send Construct_object 
10273>>>>>        
10273>>>>>        Property String  psDriverID        ""
10274>>>>>    End_Procedure
10275>>>>>    
10275>>>>>    
10275>>>>>    
10275>>>>>    // The revsion of a CLI Connectivity Kit
10275>>>>>    Function CKRevision Returns String
10277>>>>>        String  sDriverID
10277>>>>>        String  sRevision
10277>>>>>        String  sVoid
10277>>>>>        Integer iRetval
10277>>>>>        
10277>>>>>        Get psDriverID to sDriverID
10278>>>>>        If (sDRiverID <> "") Begin
10280>>>>>            Move (Repeat(" ", 255)) to sRevision
10281>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
10286>>>>>        End
10286>>>>>>
10286>>>>>        
10286>>>>>        Function_Return sRevision
10287>>>>>    End_Function
10288>>>>>    
10288>>>>>    
10288>>>>>    
10288>>>>>    // Extarct the Nth part of a a.b.c.d revsion string.
10288>>>>>    // Returns : The part version number or -1 if there is no such part number.
10288>>>>>    //
10288>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
10290>>>>>        Integer iPartRev
10290>>>>>        Integer iCurrentPart
10290>>>>>        Integer iSeparatorPos
10290>>>>>        
10290>>>>>        If (iPartNum > 4) ;            Function_Return -1
10293>>>>>        
10293>>>>>        Move 0 to iCurrentPart
10294>>>>>        Repeat
10294>>>>>>
10294>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
10295>>>>>            If (iSeparatorPos > 0) Begin
10297>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
10298>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
10299>>>>>                Increment iCurrentPart
10300>>>>>            End
10300>>>>>>
10300>>>>>            Else If (sRevision <> "") Begin
10303>>>>>                Move sRevision to iPartRev
10304>>>>>                Move "" to sRevision
10305>>>>>                Increment iCurrentPart
10306>>>>>            End
10306>>>>>>
10306>>>>>            Else ;                Move -1 to iPartRev
10308>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
10310>>>>>        
10310>>>>>        Function_Return iPartRev
10311>>>>>    End_Function
10312>>>>>    
10312>>>>>    
10312>>>>>    
10312>>>>>    // Returns the major revision of the CK
10312>>>>>    //
10312>>>>>    Function CKMajorRevision Returns Integer
10314>>>>>        Function_Return (ExtractPartFromRevision (Self, 1, CKRevision(Self)))
10315>>>>>    End_Function
10316>>>>>    
10316>>>>>    
10316>>>>>    
10316>>>>>    // Returns the minor revision of the CK
10316>>>>>    //
10316>>>>>    Function CKMinorRevision Returns Integer
10318>>>>>        Function_Return (ExtractPartFromRevision (Self, 2, CKRevision(Self)))
10319>>>>>    End_Function
10320>>>>>    
10320>>>>>    
10320>>>>>    
10320>>>>>    // Returns the release revision of the CK
10320>>>>>    //
10320>>>>>    Function CKReleaseRevision Returns Integer
10322>>>>>        Function_Return (ExtractPartFromRevision (Self, 3, CKRevision(Self)))
10323>>>>>    End_Function
10324>>>>>    
10324>>>>>    
10324>>>>>    
10324>>>>>    // Returns the major revision of the CK
10324>>>>>    //
10324>>>>>    Function CKBuildRevision Returns Integer
10326>>>>>        Function_Return (ExtractPartFromRevision (Self, 4, CKRevision(Self)))
10327>>>>>    End_Function
10328>>>>>    
10328>>>>>    
10328>>>>>    
10328>>>>>    // Determines if the CK conforms to a passed minimal revsion.
10328>>>>>    //
10328>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
10330>>>>>        If (iMajor < CKMajorRevision(Self)) ;            Function_Return (True)
10333>>>>>        Else If (iMajor = CKMajorRevision(Self)) Begin
10336>>>>>            If (iMinor < CKMinorRevision(Self)) ;                Function_Return (True)
10339>>>>>            Else If (iMinor = CKMinorRevision(Self)) Begin
10342>>>>>                If (iRelease < CKReleaseRevision(Self)) ;                    Function_Return (True)
10345>>>>>                Else If (iRelease = CKReleaseRevision(Self) and iBuild <= CKBuildRevision(Self)) ;                    Function_Return (True)
10349>>>>>            End
10349>>>>>>
10349>>>>>        End
10349>>>>>>
10349>>>>>        
10349>>>>>        Function_Return (False)
10350>>>>>    End_Function
10351>>>>>    
10351>>>>>    
10351>>>>>    
10351>>>>>    // Returns the Connectiivty Kit registration name.
10351>>>>>    //
10351>>>>>    Function RegistrationName Returns String
10353>>>>>        String  sRegistration
10353>>>>>        String  sDRiverId
10353>>>>>        String  sVoid
10353>>>>>        Integer iRetval
10353>>>>>        
10353>>>>>        Get psDriverID to sDriverID
10354>>>>>        If (sDRiverID <> "") Begin
10356>>>>>            Move (Repeat(" ", 255)) to sRegistration
10357>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
10362>>>>>        End
10362>>>>>>
10362>>>>>        
10362>>>>>        Function_Return sRegistration
10363>>>>>    End_Function
10364>>>>>    
10364>>>>>    // Returns the Connectiivty Kit serial number.
10364>>>>>    //
10364>>>>>    Function SerialNumber Returns Integer
10366>>>>>        String  sDRiverId
10366>>>>>        String  sVoid
10366>>>>>        Integer iRetval
10366>>>>>        
10366>>>>>        Get psDriverID to sDriverID
10367>>>>>        If (sDRiverID <> "") Begin
10369>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
10374>>>>>        End
10374>>>>>>
10374>>>>>        
10374>>>>>        Function_Return iRetval
10375>>>>>    End_Function
10376>>>>>    
10376>>>>>    
10376>>>>>    // Returns the Connectiivty Kit maximum number of users.
10376>>>>>    //
10376>>>>>    Function MaxUsers Returns Integer
10378>>>>>        String  sDRiverId
10378>>>>>        String  sVoid
10378>>>>>        Integer iRetval
10378>>>>>        
10378>>>>>        Get psDriverID to sDriverID
10379>>>>>        If (sDRiverID <> "") Begin
10381>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
10386>>>>>        End
10386>>>>>>
10386>>>>>        
10386>>>>>        Function_Return iRetval
10387>>>>>    End_Function
10388>>>>>    
10388>>>>>    
10388>>>>>    
10388>>>>>    // Dump the current status of the drver in the passed disk file.
10388>>>>>    //
10388>>>>>    Procedure DumpStatus String sFileName
10390>>>>>        String  sVoid
10390>>>>>        String  sDriverID
10390>>>>>        Integer iVoid
10390>>>>>        
10390>>>>>        Get psDriverID to sDriverID
10391>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
10398>>>>>    End_Procedure
10399>>>>>    
10399>>>>>    
10399>>>>>    
10399>>>>>    // Reset all driver level configurable attributes to the
10399>>>>>    // default value and then reread the configuration.
10399>>>>>    //
10399>>>>>    Procedure ReadConfiguration
10401>>>>>        String  sVoid
10401>>>>>        String  sDriverID
10401>>>>>        Integer iVoid
10401>>>>>        
10401>>>>>        Get psDriverID to sDriverID
10402>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
10409>>>>>    End_Procedure
10410>>>>>    
10410>>>>>    
10410>>>>>    
10410>>>>>    // Convert a text to the corresponding
10410>>>>>    // Generate_Record_ID_Method attribute value
10410>>>>>    //
10410>>>>>    Function TextToRIMValue String sText Returns Integer
10412>>>>>        If (sText = "None") ;            Function_Return RIM_NONE
10415>>>>>        Else If (sText = "Identity Column") ;            Function_Return RIM_IDENTITY_COLUMN
10419>>>>>        Else If (sText = "Dispenser Table") ;            Function_Return RIM_DISPENSER_TABLE
10423>>>>>        Else If (sText = "External") ;            Function_Return RIM_EXTERNAL
10427>>>>>    End_Function
10428>>>>>    
10428>>>>>    
10428>>>>>    
10428>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
10428>>>>>    // corresponding text.
10428>>>>>    //
10428>>>>>    Function RIMValueToText Integer iAttrValue Returns String
10430>>>>>        If (iAttrValue = RIM_NONE) ;            Function_Return "None"
10433>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_Return "Identity Column"
10437>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_Return "Dispenser Table"
10441>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_Return "External"
10445>>>>>    End_Function
10446>>>>>    
10446>>>>>    
10446>>>>>    
10446>>>>>    // Convert a text to the corresponding
10446>>>>>    // Generate_Record_ID_Method attribute value
10446>>>>>    //
10446>>>>>    Function TextToROValue String sText Returns Integer
10448>>>>>        If (sText = "No") ;            Function_Return RO_NO
10451>>>>>        Else If (sText = "Ignore Change") ;            Function_Return RO_IGNORECHANGE
10455>>>>>        Else If (sText = "Accept Change") ;            Function_Return RO_ACCEPTCHANGE
10459>>>>>        Else If (sText = "Error On Change") ;            Function_Return RO_ERRORONCHANGE
10463>>>>>    End_Function
10464>>>>>    
10464>>>>>    
10464>>>>>    
10464>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
10464>>>>>    // corresponding text.
10464>>>>>    //
10464>>>>>    Function ROValueToText Integer iAttrValue Returns String
10466>>>>>        If (iAttrValue = RO_NO) ;            Function_Return "No"
10469>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_Return "Ignore Change"
10473>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_Return "Accept Change"
10477>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_Return "Error On Change"
10481>>>>>    End_Function
10482>>>>>    
10482>>>>>    
10482>>>>>    
10482>>>>>    // Return the text f the last error geneated by the driver.
10482>>>>>    //
10482>>>>>    Function LastDriverError Returns String
10484>>>>>        String  sDriverID
10484>>>>>        String  sLastError
10484>>>>>        String  sLastErrorLength
10484>>>>>        Integer iLastErrorLength
10484>>>>>        Integer iVoid
10484>>>>>        
10484>>>>>        // Initialize
10484>>>>>        Move "" to sLastError
10485>>>>>        
10485>>>>>        Get psDriverID to sDriverID
10486>>>>>        If (sDriverID <> "") Begin
10488>>>>>            // Get the text of the last error
10488>>>>>            Move (Repeat(Character(" "), 14)) to sLastErrorlength
10489>>>>>            Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
10494>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) to iLastErrorLength
10495>>>>>            
10495>>>>>            If (iLastErrorLength > 0) Begin
10497>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) to sLastError
10498>>>>>                Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
10503>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) to sLastError
10504>>>>>            End
10504>>>>>>
10504>>>>>        End
10504>>>>>>
10504>>>>>        
10504>>>>>        Function_Return sLastError
10505>>>>>    End_Function
10506>>>>>    
10506>>>>>    
10506>>>>>    
10506>>>>>    // Enumerate the tables in a database
10506>>>>>    //
10506>>>>>    Function EnumerateTables String sLogin Returns Integer
10508>>>>>        String  sDriver
10508>>>>>        String  sVoid
10508>>>>>        Integer iNumTables
10508>>>>>        Integer iVoid
10508>>>>>        
10508>>>>>        Get psDriverID to sDriver
10509>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
10516>>>>>        
10516>>>>>        Function_Return iNumTables
10517>>>>>    End_Function
10518>>>>>    
10518>>>>>    
10518>>>>>    
10518>>>>>    // Returns the name of the table enumerated at the given position
10518>>>>>    //
10518>>>>>    Function TableName Integer iIndex Returns String
10520>>>>>        String  sDriver
10520>>>>>        String  sTableName
10520>>>>>        String  sVoid
10520>>>>>        Integer iVoid
10520>>>>>        
10520>>>>>        Get psDriverID to sDriver
10521>>>>>        If (sDriver <> "") Begin
10523>>>>>            Move (Repeat(" ", 255)) to sTableName
10524>>>>>            Call_Driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
10529>>>>>        End
10529>>>>>>
10529>>>>>        
10529>>>>>        Function_Return sTableName
10530>>>>>    End_Function
10531>>>>>    
10531>>>>>    
10531>>>>>    
10531>>>>>    // Returns the name of the schema of the table enumerated at the given position
10531>>>>>    //
10531>>>>>    Function SchemaName Integer iIndex Returns String
10533>>>>>        String  sDriver
10533>>>>>        String  sSchemaName
10533>>>>>        String  sVoid
10533>>>>>        Integer iVoid
10533>>>>>        
10533>>>>>        Get psDriverID to sDriver
10534>>>>>        If (sDriver <> "") Begin
10536>>>>>            Move (Repeat(" ", 255)) to sSchemaName
10537>>>>>            Call_Driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
10542>>>>>        End
10542>>>>>>
10542>>>>>        
10542>>>>>        Function_Return sSchemaName
10543>>>>>    End_Function
10544>>>>>    
10544>>>>>    // Returns the type of the table enumerated at the given position.
10544>>>>>    // Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
10544>>>>>    // "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
10544>>>>>    Function TableType Integer iIndex Returns String
10546>>>>>        String  sDriver
10546>>>>>        String  sTableType
10546>>>>>        String  sVoid
10546>>>>>        Integer iVoid
10546>>>>>        
10546>>>>>        Get psDriverID to sDriver
10547>>>>>        If (sDriver <> "") Begin
10549>>>>>            Move (Repeat(" ", 25)) to sTableType
10550>>>>>            Call_Driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
10555>>>>>        End
10555>>>>>>
10555>>>>>        
10555>>>>>        Function_Return sTableType
10556>>>>>    End_Function
10557>>>>>    
10557>>>>>    
10557>>>>>    // Returns the comment of the table enumerated at the given position
10557>>>>>    //
10557>>>>>    Function TableComment Integer iIndex Returns String
10559>>>>>        String  sDriver
10559>>>>>        String  sTableComment
10559>>>>>        String  sVoid
10559>>>>>        Integer iVoid
10559>>>>>        
10559>>>>>        Get psDriverID to sDriver
10560>>>>>        If (sDriver <> "") Begin
10562>>>>>            Move (Repeat(" ", 1024)) to sTableComment
10563>>>>>            Call_Driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
10568>>>>>        End
10568>>>>>>
10568>>>>>        
10568>>>>>        Function_Return sTableComment
10569>>>>>    End_Function
10570>>>>>    
10570>>>>>    // Enumerate the columns in a table
10570>>>>>    //
10570>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
10572>>>>>        String  sDriver
10572>>>>>        Integer iNumColumns
10572>>>>>        Integer iVoid
10572>>>>>        
10572>>>>>        Get psDriverID to sDriver
10573>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
10580>>>>>        
10580>>>>>        Function_Return iNumColumns
10581>>>>>    End_Function
10582>>>>>    
10582>>>>>    
10582>>>>>    
10582>>>>>    // Returns the name of the column enumerated at the given position
10582>>>>>    //
10582>>>>>    Function ColumnName Integer iIndex Returns String
10584>>>>>        String  sDriver
10584>>>>>        String  sColumnName
10584>>>>>        String  sVoid
10584>>>>>        Integer iVoid
10584>>>>>        
10584>>>>>        Get psDriverID to sDriver
10585>>>>>        If (sDriver <> "") Begin
10587>>>>>            Move (Repeat(" ", 255)) to sColumnName
10588>>>>>            Call_Driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
10593>>>>>        End
10593>>>>>>
10593>>>>>        
10593>>>>>        Function_Return sColumnName
10594>>>>>    End_Function
10595>>>>>    
10595>>>>>    // Convert a DataFlex date to a SQL date using the dummy zero date value.
10595>>>>>    //
10595>>>>>    Function CLIDFDateToSQLDate String sDriver Date dDFDate Returns String
10597>>>>>        
10597>>>>>        Integer iDriverIndex
10597>>>>>        
10597>>>>>        String sSQLDate
10597>>>>>        Integer iOrgDateFmt
10597>>>>>        Integer iOrgDateSep
10597>>>>>        
10597>>>>>        // Change date format to military, SQL dates are military dates
10597>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10600>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10603>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10606>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10609>>>>>        
10609>>>>>        If (Integer(dDFDate = 0)) Begin
10611>>>>>            // Return the dummy zero date
10611>>>>>            Get DriverIndex sDriver to iDriverIndex
10612>>>>>            If (iDriverIndex <> 0) Begin
10614>>>>>                Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sSQLDate
10617>>>>>            End
10617>>>>>>
10617>>>>>            Else Begin
10618>>>>>                Move '0001-01-01' to sSQLDate
10619>>>>>            End
10619>>>>>>
10619>>>>>        End
10619>>>>>>
10619>>>>>        Else Begin
10620>>>>>            Move dDFDate to sSQLDate
10621>>>>>        End
10621>>>>>>
10621>>>>>        
10621>>>>>        // Change date format back to original
10621>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10624>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10627>>>>>        
10627>>>>>        Function_Return sSQLDate
10628>>>>>    End_Function
10629>>>>>    
10629>>>>>    
10629>>>>>    
10629>>>>>    // Convert a SQL date to a DataFlex date using the dummy zero date value.
10629>>>>>    Function CLISQLDateToDFDate String sDriver String sSQLDate Returns Date
10631>>>>>        
10631>>>>>        Integer iDriverIndex
10631>>>>>        
10631>>>>>        Date dDFDate
10631>>>>>        String sDummyDateValue
10631>>>>>        Integer iOrgDateFmt
10631>>>>>        Integer iOrgDateSep
10631>>>>>        
10631>>>>>        // Change date format to military, SQL dates are military dates
10631>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10634>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10637>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10640>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10643>>>>>        
10643>>>>>        // We only need to convert if the date is the dummy zero date value
10643>>>>>        Get DriverIndex sDriver to iDriverIndex
10644>>>>>        If (iDriverIndex <> 0) Begin
10646>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyDateValue
10649>>>>>        End
10649>>>>>>
10649>>>>>        Else Begin
10650>>>>>            Move '0001-01-01' to sDummyDateValue
10651>>>>>        End
10651>>>>>>
10651>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 to dDFDate
10654>>>>>        Else ;            Move sSQLDate to dDFDate
10656>>>>>        
10656>>>>>        // Change date format back to original
10656>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10659>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10662>>>>>        
10662>>>>>        Function_Return dDFDate
10663>>>>>    End_Function
10664>>>>>    
10664>>>>>    Function DriverIndex String sDriver Returns Integer
10666>>>>>        
10666>>>>>        String  sCurrentDriver
10666>>>>>        Integer iNumberOfDrivers iDriver iCount
10666>>>>>        
10666>>>>>        Move 0 to iDriver
10667>>>>>        
10667>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
10670>>>>>        For iCount from 1 to iNumberOfDrivers
10676>>>>>>
10676>>>>>            
10676>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
10679>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
10681>>>>>                Move iCount to iDriver
10682>>>>>            End
10682>>>>>>
10682>>>>>        Loop
10683>>>>>>
10683>>>>>        
10683>>>>>        Function_Return iDriver
10684>>>>>        
10684>>>>>    End_Function
10685>>>>>    
10685>>>>>    
10685>>>>>    // Redirect an exisitng connection. The existing connection
10685>>>>>    // will point to another database but all tables will stay
10685>>>>>    // open!
10685>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
10687>>>>>        String  sDriver
10687>>>>>        String  sVoid
10687>>>>>        Integer iResult
10687>>>>>        Integer iVoid
10687>>>>>        
10687>>>>>        Get psDriverID to sDriver
10688>>>>>        If (sDriver <> "") Begin
10690>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
10695>>>>>        End
10695>>>>>>
10695>>>>>        Function_Return iResult
10696>>>>>    End_Function
10697>>>>>    
10697>>>>>    // Redirect a connection of a connection ID
10697>>>>>    // sConnectionId must contain a valid ConnectionId ("DFCONNID=MyID")
10697>>>>>    // sConnectString must contain a valid connectstring ("SERVER=MyServer;DATABASE=MyDatabase;UID=MyName;PWD=MyPassword")
10697>>>>>    //
10697>>>>>    // RedirectIDConnectString will redirect from the old connection (Server/Database the connectionId currently points to)
10697>>>>>    // to the new connection (Server/Database specified in sConnectString)
10697>>>>>    // All opened tables will be moved from old connection to new connection. (Tables must have identical structure in both connections)
10697>>>>>    //
10697>>>>>    // If bKeepLoggedIn = false, the new connection will be logged in, the old connection will be logged out
10697>>>>>    // If bKeepLoggedIn = true, connections will remain open and re-used on next redirectIdConnection
10697>>>>>    //
10697>>>>>    // Returns:
10697>>>>>    //     0 when the redirection was successful.
10697>>>>>    //     1 if the connection ID does not exist or can not be found.
10697>>>>>    //     2 login into the new connection failed.
10697>>>>>    //
10697>>>>>    Function RedirectIdConnectString String sConnectionId String sConnectString Boolean bKeepLoggedIn Returns Integer
10699>>>>>        String  sDriver
10699>>>>>        String  sVoid
10699>>>>>        Integer iResult
10699>>>>>        
10699>>>>>        Integer iOption
10699>>>>>        
10699>>>>>        // iOption
10699>>>>>        // 0 = RedirectConnection
10699>>>>>        // 1 = RedirectIdConnectString
10699>>>>>        // 2 = RedirectIdConnectStringKeepLoggedIn
10699>>>>>        If (bKeepLoggedIn) Begin
10701>>>>>            Move 2 to iOption
10702>>>>>        End
10702>>>>>>
10702>>>>>        Else Begin
10703>>>>>            Move 1 to iOption
10704>>>>>        End
10704>>>>>>
10704>>>>>        
10704>>>>>        Get psDriverID to sDriver
10705>>>>>        If (sDriver <> "") Begin
10707>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sConnectionId sConnectString iOption Result iResult
10712>>>>>        End
10712>>>>>>
10712>>>>>        Function_Return iResult
10713>>>>>    End_Function
10714>>>>>    
10714>>>>>    
10714>>>>>    // Create a DataFlex side connection id that can be used later on.
10714>>>>>    //
10714>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
10716>>>>>        String  sDriver
10716>>>>>        Integer iResult
10716>>>>>        Integer iOptions
10716>>>>>        
10716>>>>>        Get psDriverID to sDriver
10717>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
10720>>>>>        Else ;            Move iOpt to iOptions
10722>>>>>        If (sDriver <> "") Begin
10724>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
10729>>>>>        End
10729>>>>>>
10729>>>>>        Function_Return iResult
10730>>>>>    End_Function
10731>>>>>    
10731>>>>>    
10731>>>>>    
10731>>>>>    // Delete a DataFlex side connection id.
10731>>>>>    //
10731>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
10733>>>>>        String  sDriver
10733>>>>>        Integer iResult
10733>>>>>        String sVoid
10733>>>>>        
10733>>>>>        Get psDriverID to sDriver
10734>>>>>        If (sDriver <> "") Begin
10736>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
10741>>>>>        End
10741>>>>>>
10741>>>>>        Function_Return iResult
10742>>>>>    End_Function
10743>>>>>    
10743>>>>>End_Class
10744>>>
10744>>>Use cBaseErrorHandler.pkg
Including file: cBaseErrorHandler.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cBaseErrorHandler.pkg)
10744>>>>>Use errornum.inc
10744>>>>>Use cTrappedErrors.pkg
Including file: cTrappedErrors.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cTrappedErrors.pkg)
10744>>>>>>>Define MAX_ERROR_NUMBER for 32766
10744>>>>>>>
10744>>>>>>>// This array stores the set of trapped errors as toggled ranges starting
10744>>>>>>>// with the errors that are trapped. The array should always contain 0 and
10744>>>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
10744>>>>>>>// following items...
10744>>>>>>>//
10744>>>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
10744>>>>>>>//
10744>>>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
10744>>>>>>>// 10 through the rest are trapped.
10744>>>>>>>//
10744>>>>>>>Class cTrappedErrors is an array
10745>>>>>>>    Procedure Construct_Object
10747>>>>>>>        Forward Send Construct_Object
10749>>>>>>>        
10749>>>>>>>        Send initArray
10750>>>>>>>    End_Procedure
10751>>>>>>>    
10751>>>>>>>    // Find largest error LE targetError. Assumes array is sorted.
10751>>>>>>>    Function findErrorLE Integer targetError Returns Integer
10753>>>>>>>        
10753>>>>>>>        Integer lowIndex hiIndex midIndex currError
10753>>>>>>>        
10753>>>>>>>        // If error is outside of boudary conditions, use
10753>>>>>>>        // value of closest valid error# instead.
10753>>>>>>>        If (targetError <= 0);            Move 1 to targetError
10756>>>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
10760>>>>>>>        
10760>>>>>>>        Move 0 to lowIndex
10761>>>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
10762>>>>>>>        
10762>>>>>>>        // midIndex will contain the closest error LE to target upon exit.
10762>>>>>>>        Repeat
10762>>>>>>>>
10762>>>>>>>            
10762>>>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
10763>>>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
10764>>>>>>>            
10764>>>>>>>            // midIndex is targetIndex if a match occurs
10764>>>>>>>            If (currError = targetError) ;                Function_Return midIndex
10767>>>>>>>            
10767>>>>>>>            // We are either on it or just below it.
10767>>>>>>>            If ( lowIndex = midIndex ) Begin
10769>>>>>>>                
10769>>>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
10772>>>>>>>                
10772>>>>>>>                Function_Return midIndex
10773>>>>>>>                
10773>>>>>>>            End
10773>>>>>>>>
10773>>>>>>>            
10773>>>>>>>            // No match, so move the boundaries.
10773>>>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
10776>>>>>>>            Else ;                Move midIndex to lowIndex
10778>>>>>>>            
10778>>>>>>>        Until lowIndex gt hiIndex
10780>>>>>>>        
10780>>>>>>>        Function_Return midIndex
10781>>>>>>>        
10781>>>>>>>    End_Function
10782>>>>>>>    
10782>>>>>>>    // Boundaries of the table are assumed to hold error limits.
10782>>>>>>>    Procedure initArray
10784>>>>>>>        Send delete_data
10785>>>>>>>        Set array_value  0 to 0
10786>>>>>>>        Set array_value  1 to ( MAX_ERROR_NUMBER + 1 )
10787>>>>>>>    End_Procedure
10788>>>>>>>    
10788>>>>>>>    // Return 1 if Error is trapped, 0 otherwise.
10788>>>>>>>    Function IsTrapped Integer Error# Returns Integer
10790>>>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
10791>>>>>>>    End_Function
10792>>>>>>>    
10792>>>>>>>    // Add the error as long as it doesn't violate boundary conditions.
10792>>>>>>>    // This routine leaves the array unsorted.
10792>>>>>>>    Procedure addError Integer Error#
10794>>>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value  ( item_count( Self ) ) to ( Integer( Error# ) )
10797>>>>>>>    End_Procedure
10798>>>>>>>    
10798>>>>>>>    // Set error to flagged state.
10798>>>>>>>    Procedure handleError Integer Error# Integer trapFlag
10800>>>>>>>        
10800>>>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
10800>>>>>>>        
10800>>>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
10802>>>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
10803>>>>>>>>
10803>>>>>>>            Procedure_Return
10804>>>>>>>        End
10804>>>>>>>>
10804>>>>>>>        
10804>>>>>>>        Get findErrorLE Error# to prevErrIndex
10805>>>>>>>        Get isTrapped   Error# to prevErrFlag
10806>>>>>>>        
10806>>>>>>>        // if eq, Error already handled in some range.
10806>>>>>>>        If (PrevErrFlag <> trapFlag) Begin
10808>>>>>>>            
10808>>>>>>>            // This is kind of complicated. If we are adding an error,
10808>>>>>>>            // we have to account for the error already being in the
10808>>>>>>>            // array as well as rejoining ranges that have been previously
10808>>>>>>>            // split and splitting ranges when adding a new flag.
10808>>>>>>>            
10808>>>>>>>            Get integer_value  ( prevErrIndex + 1 ) to nextErrValue
10809>>>>>>>            Get integer_value  prevErrIndex         to prevErrValue
10810>>>>>>>            
10810>>>>>>>            // Do this first so prevErrIndex stays valid.
10810>>>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
10813>>>>>>>            Else ;                Send addError ( Error# + 1 )
10815>>>>>>>            
10815>>>>>>>            If ( prevErrValue < Error# ) ;                Send addError Error#
10818>>>>>>>            Else ;                Send delete_item prevErrIndex
10820>>>>>>>        End
10820>>>>>>>>
10820>>>>>>>        Send sort_items UPWARD_DIRECTION
10821>>>>>>>        
10821>>>>>>>    End_Procedure
10822>>>>>>>    
10822>>>>>>>    // Flag error as trappable
10822>>>>>>>    Procedure Trap_Error Integer Error#
10824>>>>>>>        Send handleError Error# 1
10825>>>>>>>    End_Procedure
10826>>>>>>>    
10826>>>>>>>    // Flag error as non-trappable
10826>>>>>>>    Procedure Ignore_Error Integer Error#
10828>>>>>>>        Send handleError Error# 0
10829>>>>>>>    End_Procedure
10830>>>>>>>    
10830>>>>>>>    // Flag all errors as trappable
10830>>>>>>>    Procedure Trap_All
10832>>>>>>>        Send initArray
10833>>>>>>>    End_Procedure
10834>>>>>>>    
10834>>>>>>>    // Flag all errors as non-trappable
10834>>>>>>>    Procedure Ignore_All
10836>>>>>>>        Send delete_data
10837>>>>>>>        Set array_value 0 to 0
10838>>>>>>>        Set array_value 1 to 1
10839>>>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
10840>>>>>>>    End_Procedure
10841>>>>>>>End_Class
10842>>>>>>>
10842>>>>>Use LanguageText.pkg
10842>>>>>Use VdfBase.pkg
10842>>>>>
10842>>>>>// used by error handler and UserError to pull a caption out of the error string
10842>>>>>Define C_ErrorCaption for "*CAPTION*="
10842>>>>>
10842>>>>>Class cBaseErrorHandler is a cObject
10843>>>>>    Procedure Construct_Object
10845>>>>>        Forward Send Construct_Object
10847>>>>>        
10847>>>>>        Set delegation_mode to no_delegate_or_error
10848>>>>>        
10848>>>>>        // This is the caption that appears for unhandled errors dialog box
10848>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
10849>>>>>        
10849>>>>>        // This is the caption that appears for standard user errors
10849>>>>>        Property String psUserErrorCaption C_$Error
10850>>>>>        
10850>>>>>        // If set false, this makes the error handler work the old way which
10850>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
10850>>>>>        Property Boolean pbUnhandledErrorSupport       True
10851>>>>>        
10851>>>>>        Property Boolean pbErrorProcessingState False  // Flag which is sent when error is being processed. This stops error recursion.
10852>>>>>        
10852>>>>>        Property Integer piCurrentErrorNumber     0
10853>>>>>        Property Integer piCurrentErrorLine        0
10854>>>>>        
10854>>>>>        Property Integer[] paUserErrors       // Collection of sorted error numbers considered to be user errors. (note, this array must remain sorted!)
10855>>>>>        
10855>>>>>        
10855>>>>>        Object oTrappedErrors is a cTrappedErrors
10857>>>>>        End_Object
10858>>>>>        
10858>>>>>        Send DefineStandardUserErrors
10859>>>>>        
10859>>>>>        Move Self to Error_Object_Id
10860>>>>>        Move Self to ghoErrorHandler
10861>>>>>    End_Procedure
10862>>>>>    
10862>>>>>    Procedure DefineStandardUserErrors
10864>>>>>        Integer[] aUserErrors
10865>>>>>        
10865>>>>>        // define the standard user error numbers....
10865>>>>>        Move 0                                     to aUserErrors[0]
10866>>>>>        Move DFERR_NUMBER_TOO_LARGE                to aUserErrors[1]
10867>>>>>        Move DFERR_WINDOW_RANGE                    to aUserErrors[2]
10868>>>>>        Move DFERR_ENTRY_REQUIRED                  to aUserErrors[3]
10869>>>>>        Move DFERR_ENTER_A_NUMBER                  to aUserErrors[4]
10870>>>>>        Move DFERR_BAD_ENTRY                       to aUserErrors[5]
10871>>>>>        Move DFERR_ENTER_VALID_DATE                to aUserErrors[6]
10872>>>>>        Move DFERR_NUMERIC_RANGE                   to aUserErrors[7]
10873>>>>>        Move DFERR_DUPLICATE_REC                   to aUserErrors[8]
10874>>>>>        Move DFERR_TEXT_FIELD_TOO_LONG             to aUserErrors[9]
10875>>>>>        Move DFERR_FIND_PRIOR_BEG_OF_FILE          to aUserErrors[10]
10876>>>>>        Move DFERR_FIND_PAST_END_OF_FILE           to aUserErrors[11]
10877>>>>>        Move DFERR_NO_REC_TO_DELETE                to aUserErrors[12]
10878>>>>>        Move DFERR_FIELD_NOT_INDEXED               to aUserErrors[13]
10879>>>>>        Move DFERR_REC_NUMBER_RANGE                to aUserErrors[14]
10880>>>>>        Move DFERR_ENTER_VALID_REC_ID              to aUserErrors[15]
10881>>>>>        Move DFERR_OPERATOR_ERROR                  to aUserErrors[16]
10882>>>>>        Move DFERR_CANT_CHANGE_KEY_FIELD           to aUserErrors[17]
10883>>>>>        Move DFERR_NO_DELETE_RELATED_RECORDS_EXIST to aUserErrors[18]
10884>>>>>        Move DFERR_OPERATION_NOT_ALLOWED           to aUserErrors[19]
10885>>>>>        Move DFERR_OPERATOR                        to aUserErrors[20]
10886>>>>>        Move DFERR_XML_HTTP                        to aUserErrors[21]
10887>>>>>        Move DFERR_CLIENT_SOAP_TRANSFER            to aUserErrors[22]
10888>>>>>        Move DFERR_CLIENT_SOAP_FAULT               to aUserErrors[23]
10889>>>>>        Move DFERR_TEXT_TOO_LARGE_FOR_FIELD        to aUserErrors[24]
10890>>>>>        Move DFERR_WINPRINT                        to aUserErrors[25]
10891>>>>>        Move DFERR_CRYSTAL_REPORT                  to aUserErrors[26]
10892>>>>>        Move DFERR_MAPI                            to aUserErrors[27]
10893>>>>>        Move DFERR_FILE_ACCESS_VIOLATION           to aUserErrors[28]
10894>>>>>        Move DFERR_DATAFLEX_REPORTS                to aUserErrors[29]
10895>>>>>        Move DFERR_CANT_REFIND_RECORD              to aUserErrors[30]
10896>>>>>        // WebApp Errors
10896>>>>>        Move DFERR_WEBAPP_ACCESS_DENIED            to aUserErrors[31]
10897>>>>>        // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error number of DDs.
10897>>>>>        Move 999                                   to aUserErrors[32]
10898>>>>>        // This is session timeout (we keep the old number 950 for backwards comatibility reasons)
10898>>>>>        Move DFERR_WEBAPP_SESSION_TIMEOUT          to aUserErrors[33]
10899>>>>>        // This is session timeout (we keep the old number 951 for backwards comatibility reasons)
10899>>>>>        Move DFERR_WEBAPP_BAD_SESSION_KEY          to aUserErrors[34]
10900>>>>>        Move DFERR_WEBAPP_INVALID_URL              to aUserErrors[35]
10901>>>>>        Move DFERR_WEBAPP_INVALID_URL_REC          to aUserErrors[36]
10902>>>>>        Move (SortArray(aUserErrors)) to aUserErrors
10903>>>>>        Set paUserErrors to aUserErrors
10904>>>>>    End_Procedure
10905>>>>>    
10905>>>>>    Procedure HandleError Integer iErrNum Integer iErrLine String sErrText
10907>>>>>        //  Stub method implemented by subclass
10907>>>>>    End_Procedure
10908>>>>>    
10908>>>>>    // Called by the runtime when an error occurs. Initiates the main error handling. Skips errors
10908>>>>>    // that are ignored and makes sure to prevent recursion by checking the error processing state.
10908>>>>>    Procedure Error_Report Integer iErrNum Integer iErrLine String sErrText
10910>>>>>        If (pbErrorProcessingState(Self)) ;            Procedure_Return
10913>>>>>            
10913>>>>>        If (not(IsTrapped(Self, iErrNum))) ;            Procedure_Return
10916>>>>>        
10916>>>>>        Set pbErrorProcessingState to True
10917>>>>>        Set piCurrentErrorNumber to iErrNum
10918>>>>>        Set piCurrentErrorLine to iErrLine
10919>>>>>        
10919>>>>>        Send HandleError iErrNum iErrLine sErrText
10920>>>>>        
10920>>>>>        Set piCurrentErrorNumber to 0
10921>>>>>        Set piCurrentErrorLine to 0
10922>>>>>        Move 0 to ghoErrorSource
10923>>>>>        Set pbErrorProcessingState to False
10924>>>>>    End_Procedure
10925>>>>>    
10925>>>>>    
10925>>>>>
10925>>>>>    
10925>>>>>    // Returns true if this is a user error (i.e. "find past end of file")
10925>>>>>    Function IsUserError Integer iError Returns Boolean
10927>>>>>        Integer[] aUserErrors
10928>>>>>        Get paUserErrors to aUserErrors
10929>>>>>        Function_Return (BinarySearchArray(iError, aUserErrors) <> -1)
10930>>>>>    End_Function
10931>>>>>    
10931>>>>>        // returns true if this is an unhandled error (i.e., not a user error
10931>>>>>    Function IsUnhandledError Integer iError Returns Boolean
10933>>>>>        Integer[] UserErrors
10934>>>>>        Get paUserErrors to UserErrors
10935>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
10936>>>>>    End_Function
10937>>>>>    
10937>>>>>    Procedure AddUserError Integer iError
10939>>>>>        // adds a user error to the collection of defined 'user errors'
10939>>>>>        Integer[] aUserErrors
10940>>>>>        Get paUserErrors to aUserErrors
10941>>>>>        
10941>>>>>        If (BinarySearchArray(iError, aUserErrors) = -1) Begin
10943>>>>>            Move (InsertInArray(aUserErrors, BinarySearchInsertPos(), iError)) to aUserErrors         // Keep the array sorted. Makes searching fast, adding slower.
10944>>>>>            Set paUserErrors to aUserErrors
10945>>>>>        End
10945>>>>>>
10945>>>>>    End_Procedure
10946>>>>>    
10946>>>>>    Procedure RemoveUserError Integer iError
10948>>>>>        // Removes the passed error number from the set of user errors.
10948>>>>>        Integer iIndex
10948>>>>>        Integer[] aUserErrors
10949>>>>>        
10949>>>>>        Get paUserErrors to aUserErrors
10950>>>>>        Move (BinarySearchArray(iError, aUserErrors)) to iIndex
10951>>>>>        
10951>>>>>        If (iIndex <> -1) Begin
10953>>>>>            Move (RemoveFromArray(aUserErrors, iIndex)) to aUserErrors
10954>>>>>            Set paUserErrors to aUserErrors
10955>>>>>        End
10955>>>>>>
10955>>>>>    End_Procedure
10956>>>>>    
10956>>>>>    Procedure RemoveAllUserErrors
10958>>>>>        // Clears set of User Errors
10958>>>>>        Set paUserErrors to (ResizeArray(paUserErrors(Self), 0))
10959>>>>>    End_Procedure
10960>>>>>    
10960>>>>>    // return true if an error number is critical
10960>>>>>    Function IsCritical Integer iError Returns Boolean
10962>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(iError)+"."))
10963>>>>>    End_Function
10964>>>>>    
10964>>>>>    Procedure TrapError Integer iError
10966>>>>>        Send Trap_Error of oTrappedErrors iError
10967>>>>>    End_Procedure
10968>>>>>    
10968>>>>>    Procedure IgnoreError Integer iError
10970>>>>>        Send Ignore_Error of oTrappedErrors iError
10971>>>>>    End_Procedure
10972>>>>>    
10972>>>>>    Procedure IgnoreAllErrors
10974>>>>>        Send Ignore_All of oTrappedErrors
10975>>>>>    End_Procedure
10976>>>>>    
10976>>>>>    Procedure TrapAllErrors
10978>>>>>        Send Trap_All of oTrappedErrors
10979>>>>>    End_Procedure
10980>>>>>    
10980>>>>>    Function IsTrapped Integer iError  Returns Boolean
10982>>>>>        Function_Return (IsTrapped(oTrappedErrors,iError))
10983>>>>>    End_Function
10984>>>>>    
10984>>>>>    
10984>>>>>
10984>>>>>    
10984>>>>>    // Used to fetch the default error description.
10984>>>>>    //
10984>>>>>    // iError   - Error number
10984>>>>>    // sMessage - Additional error message
10984>>>>>    // Returns  - Complete error message
10984>>>>>    Function ErrorDescription Integer iError String sMessage Returns String
10986>>>>>        String sDescription
10986>>>>>        Boolean bAvailable
10986>>>>>        
10986>>>>>        //  Fetch system error text
10986>>>>>        Get Error_Text of Desktop iError to sDescription
10987>>>>>        Get Error_Text_Available of Desktop iError to bAvailable
10988>>>>>        
10988>>>>>        //  Trim both messages
10988>>>>>        Move (Trim(sDescription)) to sDescription
10989>>>>>        Move (Trim(sMessage)) to sMessage
10990>>>>>        
10990>>>>>        //  Append message if needed
10990>>>>>        If (sMessage <> "") Begin
10992>>>>>            If (sDescription <> "" and bAvailable) Begin
10994>>>>>                Move (sDescription + " " + sMessage) to sDescription
10995>>>>>            End
10995>>>>>>
10995>>>>>            Else Begin
10996>>>>>                Move sMessage to sDescription
10997>>>>>            End
10997>>>>>>
10997>>>>>        End
10997>>>>>>
10997>>>>>        
10997>>>>>        Function_Return sDescription
10998>>>>>    End_Function
10999>>>>>    
10999>>>>>    // Legacy names here for backwards compatibility
10999>>>>>    Function Error_Description Integer iError String sMessage Returns String
11001>>>>>        Function_Return (ErrorDescription(Self, iError, sMessage))
11002>>>>>    End_Function
11003>>>>>    
11003>>>>>    
11003>>>>>    Function Error_processing_state Returns Boolean
11005>>>>>        Function_Return (pbErrorProcessingState(Self))
11006>>>>>    End_Function
11007>>>>>    
11007>>>>>    Function Current_Error_Number Returns Integer
11009>>>>>        Function_Return (piCurrentErrorNumber(Self))
11010>>>>>    End_Function
11011>>>>>    
11011>>>>>    Procedure Set Current_Error_Number Integer iErr
11013>>>>>        Set piCurrentErrorNumber to iErr
11014>>>>>    End_Procedure
11015>>>>>    
11015>>>>>    Function Error_Line_Number Returns Integer
11017>>>>>        Function_Return (piCurrentErrorLine(Self))
11018>>>>>    End_Function
11019>>>>>    
11019>>>>>    Procedure Set Error_Line_Number Integer iLine
11021>>>>>        Set piCurrentErrorLine to iLine
11022>>>>>    End_Procedure
11023>>>>>    
11023>>>>>    Procedure Trap_Error Integer iError
11025>>>>>        Send TrapError iError
11026>>>>>    End_Procedure
11027>>>>>    
11027>>>>>    Procedure Ignore_Error Integer iError
11029>>>>>        Send IgnoreError iError
11030>>>>>    End_Procedure
11031>>>>>    
11031>>>>>    Procedure Trap_All
11033>>>>>        Send TrapAllErrors
11034>>>>>    End_Procedure
11035>>>>>    
11035>>>>>    Procedure Ignore_All
11037>>>>>        Send IgnoreAllErrors
11038>>>>>    End_Procedure
11039>>>>>    
11039>>>>>    Function Is_Critical Integer iError Returns Boolean
11041>>>>>        Function_Return (IsCritical(Self, iError))
11042>>>>>    End_Function
11043>>>>>End_Class
11044>>>>>
11044>>>>>Procedure UserError Global String sMessage String sCaption
11046>>>>>    String sCapt
11046>>>>>    If (Error_Object_Id=0) Begin
11048>>>>>        Error DFERR_PROGRAM "No Error Handler"
11049>>>>>>
11049>>>>>        Procedure_Return
11050>>>>>    End
11050>>>>>>
11050>>>>>    
11050>>>>>    // Accept not passing a caption in which case the error handler's
11050>>>>>    // default caption. It had been the intention to require a caption ("" if none)
11050>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
11050>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
11050>>>>>    If (num_arguments>1) Begin
11052>>>>>        Move sCaption to sCapt
11053>>>>>    End
11053>>>>>>
11053>>>>>    
11053>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
11054>>>>>>
11054>>>>>End_Procedure
11055>>>
11055>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files\DataFlex 25.0\Pkg\sql.pkg)
11055>>>>>// Embedded SQL classes for use with Data Access Worldwide CLI    
11055>>>>>// Connectivty Kits.                                              
11055>>>>>Use CLI.pkg
11055>>>>>
11055>>>>>// Global storage for results
11055>>>>>Integer SQLResult
11055>>>>>
11055>>>>>// Embedded SQL function constants
11055>>>>>Define FUNC_SQLCONNECT             for 1000000
11055>>>>>Define FUNC_SQLFILECONNECT         for 1000001
11055>>>>>Define FUNC_SQLDISCONNECT          for 1000002
11055>>>>>Define FUNC_SQLOPEN                for 1000003
11055>>>>>Define FUNC_SQLCLOSE               for 1000004
11055>>>>>Define FUNC_SQLPREPARE             for 1000005
11055>>>>>Define FUNC_SQLEXECUTE             for 1000006
11055>>>>>Define FUNC_SQLEXECDIRECT          for 1000007
11055>>>>>Define FUNC_SQLFETCH               for 1000008
11055>>>>>Define FUNC_SQLCOLUMNINFO          for 1000009
11055>>>>>Define FUNC_SQLCOLUMNVALUE         for 1000010
11055>>>>>Define FUNC_SQLBINDFILE            for 1000011
11055>>>>>Define FUNC_SQLGETDATA             for 1000012
11055>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  for 1000013
11055>>>>>Define FUNC_SQLCOLSTRINGATTRIB     for 1000014
11055>>>>>Define FUNC_SQLCOLINTATTRIB        for 1000015
11055>>>>>Define FUNC_SQLSTMTINTATTRIB       for 1000016
11055>>>>>Define FUNC_SQLSETPROCNAME         for 1000017
11055>>>>>Define FUNC_SQLSETPROCARG          for 1000018
11055>>>>>Define FUNC_SQLCALL                for 1000019
11055>>>>>Define FUNC_SQLGETPROCARGLEN       for 1000020
11055>>>>>Define FUNC_SQLGETPROCARG          for 1000021
11055>>>>>Define FUNC_SQLGETPROCRETVALLEN    for 1000022
11055>>>>>Define FUNC_SQLGETPROCRETVAL       for 1000023
11055>>>>>Define FUNC_SQLNEXTRESULTSET       for 1000024
11055>>>>>Define FUNC_SQLBUFFERSTATUS        for 1000025
11055>>>>>Define FUNC_SQLSETPROCSCHEMA       for 1000026
11055>>>>>Define FUNC_SQLGETMESSAGE          for 1000027
11055>>>>>Define FUNC_SQLSETSTMTINTATTRIB    for 1000028
11055>>>>>
11055>>>>>// Embedded SQL statement attribute constants
11055>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
11055>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
11055>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
11055>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
11055>>>>>Define SQLSTMTATTRIB_CURSOR_TYPE    for 5
11055>>>>>
11055>>>>>// Embedded SQL possible values for SQLSTMTATTRIB_CURSOR_TYPE
11055>>>>>Define SQL_CURSOR_FORWARD_ONLY      for 0
11055>>>>>Define SQL_CURSOR_KEYSET_DRIVEN     for 1
11055>>>>>Define SQL_CURSOR_DYNAMIC           for 2
11055>>>>>Define SQL_CURSOR_STATIC            for 3
11055>>>>>
11055>>>>>
11055>>>>>// Embedded SQL column attribute constants
11055>>>>>Define SQLCOLATTRIB_SIZE           for 1
11055>>>>>Define SQLCOLATTRIB_LENGTH         for 1
11055>>>>>Define SQLCOLATTRIB_PRECISION      for 2
11055>>>>>Define SQLCOLATTRIB_LABEL          for 3
11055>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
11055>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
11055>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
11055>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
11055>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
11055>>>>>
11055>>>>>
11055>>>>>// Types used for conversion with ConvertToXml
11055>>>>>Define esqlTime      for 8
11055>>>>>Define esqlDatetime  for 9
11055>>>>>
11055>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
11055>>>>>Integer giLastSQLhdbc
11055>>>>>Integer giLastSQLhstmt
11055>>>>>
11055>>>>>Move -1 to giLastSQLhdbc
11056>>>>>Move -1 to giLastSQLhstmt
11057>>>>>
11057>>>>>Struct tSQLColumn
11057>>>>>    Integer iSQLType
11057>>>>>    Integer iSQLSize
11057>>>>>    Integer iSQLPrecision
11057>>>>>    Integer iVariableDataType
11057>>>>>End_Struct
11057>>>>>
11057>>>>>// Statement object for embedded sql                           
11057>>>>>//   An object is created for each statement. These will be children    
11057>>>>>//   of cSQLConnection objects which manage the create and destruction  
11057>>>>>//   of these.                                                          
11057>>>>>
11057>>>>>Class cSQLStatement is a cObject
11058>>>>>    
11058>>>>>    Procedure Construct_object
11060>>>>>        Forward Send Construct_object
11062>>>>>        
11062>>>>>        Property Handle  phCLIStatementHandle   0
11063>>>>>        Property Handle  phCLIConnectionHandle  0
11064>>>>>        Property String  psDriverID             ""
11065>>>>>        
11065>>>>>        Property Integer piLastColumn      0
11066>>>>>        Property Integer piLastArgument    0
11067>>>>>        Property Integer piBindFile        0
11068>>>>>        
11068>>>>>        Property Integer piColumnCount     0
11069>>>>>        
11069>>>>>        // True if there is at least 1 column with a variable length data type
11069>>>>>        Property Integer piHasVariableDataType  0
11070>>>>>        
11070>>>>>        // Max size of buffer for variable length data. Default 16000
11070>>>>>        Property Integer piMaxVariableBufferLength 16000
11071>>>>>        
11071>>>>>        // Allocated buffer for SQLGetData.
11071>>>>>        Property WString psVariableBuffer  ""
11072>>>>>        
11072>>>>>        // Allocated size of psVariableBuffer
11072>>>>>        Property Integer piVariableBufferLength 0
11073>>>>>        
11073>>>>>        // Stores column properties of a result set.
11073>>>>>        Property tSQLColumn[] paSQLColumns
11074>>>>>        
11074>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
11074>>>>>        //   0    = Fetch returned no data.
11074>>>>>        //   <> 0 = Row fetched
11074>>>>>        Property Integer piFetchResult     0
11075>>>>>        
11075>>>>>        
11075>>>>>        Property String psDummyZeroDate              '0001-01-01'
11076>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
11077>>>>>        
11077>>>>>    End_Procedure
11078>>>>>    
11078>>>>>    // Store basic information about the statement.
11078>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
11080>>>>>        
11080>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
11081>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
11082>>>>>        Set psDriverID             to sDrvrId
11083>>>>>        
11083>>>>>    End_Procedure
11084>>>>>    
11084>>>>>    
11084>>>>>    // Destroy the cSQLStatement object
11084>>>>>    Procedure DestroySQLStatement
11086>>>>>        Send Destroy
11087>>>>>    End_Procedure
11088>>>>>    
11088>>>>>    // Handle an error that has occurred while checking properties.
11088>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
11090>>>>>        Integer iErrHandle
11090>>>>>        Integer iErrNum
11090>>>>>        String  sLocationInfo
11090>>>>>        
11090>>>>>        // Get the DataFlex statement identifier
11090>>>>>        Move Self to iErrHandle
11091>>>>>        
11091>>>>>        // Determine error number
11091>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
11094>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
11098>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
11102>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
11104>>>>>        
11104>>>>>        // Create location ifnormation
11104>>>>>        Move "[" to sLocationInfo
11105>>>>>        If (sOriginMsg <> "") Begin
11107>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
11108>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
11109>>>>>        End
11109>>>>>>
11109>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
11110>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
11111>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
11112>>>>>        
11112>>>>>        // Generate the error
11112>>>>>        Error iErrNum sLocationInfo
11113>>>>>>
11113>>>>>    End_Procedure
11114>>>>>    
11114>>>>>    // Handle general error not related to the properties
11114>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
11116>>>>>        Integer iErrHandle
11116>>>>>        String  sLocationInfo
11116>>>>>        
11116>>>>>        // Get the DataFlex statement identifier
11116>>>>>        Move Self to iErrHandle
11117>>>>>        
11117>>>>>        // Create location information
11117>>>>>        Move "[" to sLocationInfo
11118>>>>>        If (sOriginMsg <> "") Begin
11120>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
11121>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
11122>>>>>        End
11122>>>>>>
11122>>>>>        If (sErrtext <> "") Begin
11124>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
11125>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
11126>>>>>        End
11126>>>>>>
11126>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
11127>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
11128>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
11129>>>>>        
11129>>>>>        // Generate the error
11129>>>>>        Error iErrNum sLocationInfo
11130>>>>>>
11130>>>>>    End_Procedure
11131>>>>>    
11131>>>>>    // Handle an illegal attribute error
11131>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
11133>>>>>        Integer bReport
11133>>>>>        
11133>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
11136>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
11139>>>>>    End_Procedure
11140>>>>>    
11140>>>>>    // Check if a column number is legal
11140>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
11142>>>>>        Integer bLegal
11142>>>>>        Integer iNumColumns
11142>>>>>        
11142>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11143>>>>>        If (iCol > 0 and iCol <= iNumColumns) ;            Move DFTRUE to bLegal
11146>>>>>        Else ;            Move DFFALSE to bLegal
11148>>>>>        
11148>>>>>        Function_Return bLegal
11149>>>>>    End_Function
11150>>>>>    
11150>>>>>    
11150>>>>>    
11150>>>>>    // Close a statement and free all alllocated resources
11150>>>>>    Procedure SQLClose
11152>>>>>        Integer ihdbc
11152>>>>>        Integer ihstmt
11152>>>>>        Integer iVoid
11152>>>>>        String  sDrvrId
11152>>>>>        String  sEmpty
11152>>>>>        
11152>>>>>        // Initialize
11152>>>>>        Move "" to sEmpty
11153>>>>>        
11153>>>>>        // Get the cli handles
11153>>>>>        Get phCLIStatementHandle  to ihstmt
11154>>>>>        Get phCLIConnectionHandle to ihdbc
11155>>>>>        Get psDriverId            to sDrvrId
11156>>>>>        
11156>>>>>        // Free the CLI handle
11156>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11158>>>>>            // Call the driver function to close
11158>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCLOSE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
11163>>>>>            
11163>>>>>            Move -1 to giLastSQLhstmt
11164>>>>>            // Free the DataFlex handle
11164>>>>>            Send DestroySQLStatement
11165>>>>>        End
11165>>>>>>
11165>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
11167>>>>>    End_Procedure
11168>>>>>    
11168>>>>>    // Prepare a statement for execution
11168>>>>>    Procedure SQLPrepare String sStatement
11170>>>>>        Integer ihdbc
11170>>>>>        Integer ihstmt
11170>>>>>        Integer iVoid
11170>>>>>        String  sDrvrId
11170>>>>>        
11170>>>>>        // Get the cli handles
11170>>>>>        Get phCLIStatementHandle  to ihstmt
11171>>>>>        Get phCLIConnectionHandle to ihdbc
11172>>>>>        Get psDriverId            to sDrvrId
11173>>>>>        
11173>>>>>        // Prepare
11173>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11175>>>>>            // Call the driver function to prepare
11175>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLPREPARE ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
11180>>>>>            Set piLastArgument to 0
11181>>>>>
11181>>>>>        End
11181>>>>>>
11181>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
11183>>>>>    End_Procedure
11184>>>>>    
11184>>>>>    Procedure SQLGetStatementAttributes
11186>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
11186>>>>>        String sMaxValue
11186>>>>>        tSQLColumn[] aSQLColumns
11186>>>>>        tSQLColumn[] aSQLColumns
11187>>>>>        
11187>>>>>        Integer iSqlType
11187>>>>>        Integer iSQLSize
11187>>>>>        Integer iSQLprecision
11187>>>>>        Integer iVariableDataType
11187>>>>>        
11187>>>>>        String  sDrvrId
11187>>>>>        
11187>>>>>        Integer iHasVariableDataType
11187>>>>>        
11187>>>>>        Move 0 to iHasVariableDataType
11188>>>>>        
11188>>>>>        
11188>>>>>        // Get the cli handles
11188>>>>>        Get phCLIStatementHandle  to ihstmt
11189>>>>>        Get phCLIConnectionHandle to ihdbc
11190>>>>>        Get psDriverId            to sDrvrId
11191>>>>>        
11191>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11192>>>>>        
11192>>>>>        Set piColumnCount to iNumColumns
11193>>>>>        
11193>>>>>        // Fill columns array
11193>>>>>        For iCol from 1 to iNumColumns
11199>>>>>>
11199>>>>>            Move 0 to iVariableDataType
11200>>>>>            
11200>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
11201>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
11202>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
11203>>>>>            
11203>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
11205>>>>>                // text type
11205>>>>>                Move 1 to iVariableDataType
11206>>>>>            End
11206>>>>>>
11206>>>>>            Else Begin
11207>>>>>                If (sDrvrId = "MSSQLDRV") Begin
11209>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0
11209>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                        ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
11211>>>>>                        
11211>>>>>                        Move 1 to iVariableDataType
11212>>>>>                    End
11212>>>>>>
11212>>>>>                End
11212>>>>>>
11212>>>>>            End
11212>>>>>>
11212>>>>>            
11212>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType
11213>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
11214>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
11215>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
11216>>>>>            
11216>>>>>            If (not(iVariableDataType)) Begin
11218>>>>>                If (iSQLSize > iMaxSize) Begin
11220>>>>>                    Move iSQLSize to iMaxSize
11221>>>>>                End
11221>>>>>>
11221>>>>>            End
11221>>>>>>
11221>>>>>            Else Begin
11222>>>>>                Move 1 to iHasVariableDataType
11223>>>>>            End
11223>>>>>>
11223>>>>>            
11223>>>>>        Loop
11224>>>>>>
11224>>>>>        
11224>>>>>        Set paSQLColumns   to aSQLColumns
11225>>>>>        Set piHasVariableDataType to iHasVariableDataType
11226>>>>>        
11226>>>>>    End_Procedure
11227>>>>>    
11227>>>>>    // Execute a prepared statement
11227>>>>>    Procedure SQLExecute
11229>>>>>        Integer ihdbc
11229>>>>>        Integer ihstmt
11229>>>>>        Integer iVoid
11229>>>>>        String  sDrvrId
11229>>>>>        String  sEmpty
11229>>>>>        
11229>>>>>        // Initialize
11229>>>>>        Move "" to sEmpty
11230>>>>>        
11230>>>>>        // Get the cli handles
11230>>>>>        Get phCLIStatementHandle  to ihstmt
11231>>>>>        Get phCLIConnectionHandle to ihdbc
11232>>>>>        Get psDriverId            to sDrvrId
11233>>>>>        
11233>>>>>        // Execute
11233>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11235>>>>>            // Call the driver function to execute
11235>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
11240>>>>>            Send SQLGetStatementAttributes
11241>>>>>            Set piLastArgument to 0
11242>>>>>        End
11242>>>>>>
11242>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
11244>>>>>    End_Procedure
11245>>>>>    
11245>>>>>    
11245>>>>>    
11245>>>>>    // Prepare and execute a statement
11245>>>>>    Procedure SQLExecDirect String sStatement
11247>>>>>        Integer ihdbc
11247>>>>>        Integer ihstmt
11247>>>>>        Integer iVoid
11247>>>>>        String  sDrvrId
11247>>>>>        
11247>>>>>        // Get the cli handles
11247>>>>>        Get phCLIStatementHandle  to ihstmt
11248>>>>>        Get phCLIConnectionHandle to ihdbc
11249>>>>>        Get psDriverId            to sDrvrId
11250>>>>>        
11250>>>>>        // ExecDirect
11250>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11252>>>>>            // Call the driver function to execdirect
11252>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
11257>>>>>            Send SQLGetStatementAttributes
11258>>>>>        End
11258>>>>>>
11258>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
11260>>>>>    End_Procedure
11261>>>>>    
11261>>>>>    // Fetch the next row
11261>>>>>    // Returns  : 0   = No more data
11261>>>>>    //<>0 = Success
11261>>>>>    Function SQLFetch Returns Integer
11263>>>>>        Integer ihdbc
11263>>>>>        Integer ihstmt
11263>>>>>        Integer iResult
11263>>>>>        String  sDrvrId
11263>>>>>        String  sEmpty
11263>>>>>        
11263>>>>>        // Initialize
11263>>>>>        Move "" to sEmpty
11264>>>>>        Move 0  to iResult
11265>>>>>        
11265>>>>>        // Get the cli handles
11265>>>>>        Get phCLIStatementHandle  to ihstmt
11266>>>>>        Get phCLIConnectionHandle to ihdbc
11267>>>>>        Get psDriverId            to sDrvrId
11268>>>>>        
11268>>>>>        // Fetch
11268>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11270>>>>>            Move False to Err
11271>>>>>            
11271>>>>>            // Call the driver function to fetch
11271>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11276>>>>>            
11276>>>>>            // If something went wrong, adjust the result
11276>>>>>            If (Err) ;                Move 0 to iResult
11279>>>>>            
11279>>>>>            Set piLastcolumn to 0
11280>>>>>        End
11280>>>>>>
11280>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
11282>>>>>        
11282>>>>>        Function_Return iResult
11283>>>>>    End_Function
11284>>>>>    
11284>>>>>    // Fetch the next row and return an array with all column values
11284>>>>>    // Returns  : Array of strings with all column values
11284>>>>>    // Sets piFetchResult property
11284>>>>>    //   0    = No more data
11284>>>>>    //   <> 0 = Success
11284>>>>>    Function SQLFetchRowValues Returns String[]
11286>>>>>        
11286>>>>>        String[] asValues
11287>>>>>        
11287>>>>>        tSQLColumn[] aSQLColumns
11287>>>>>        tSQLColumn[] aSQLColumns
11288>>>>>        
11288>>>>>        Integer ihdbc
11288>>>>>        Integer ihstmt
11288>>>>>        Integer iResult iVoid
11288>>>>>        Integer iColCount iCol
11288>>>>>        String  sDrvrId
11288>>>>>        String  sEmpty
11288>>>>>        Longptr pResultWStr
11288>>>>>        WString wVariableResult
11288>>>>>        Integer iHasVariableDataType
11288>>>>>        Integer iLen
11288>>>>>        Integer iVariableBufferLength
11288>>>>>        
11288>>>>>        // Initialize
11288>>>>>        Move "" to sEmpty
11289>>>>>        Move 0  to iResult
11290>>>>>        
11290>>>>>        // Get the cli handles
11290>>>>>        Get phCLIStatementHandle  to ihstmt
11291>>>>>        Get phCLIConnectionHandle to ihdbc
11292>>>>>        Get psDriverId            to sDrvrId
11293>>>>>        
11293>>>>>        Get paSQLColumns to aSQLColumns
11294>>>>>        Get piColumnCount to iColCount
11295>>>>>        Get piHasVariableDataType to iHasVariableDataType
11296>>>>>        
11296>>>>>        If (iHasVariableDataType) Begin
11298>>>>>            
11298>>>>>            Get piVariableBufferLength      to iVariableBufferLength
11299>>>>>            Get piMaxVariableBufferLength   to iLen
11300>>>>>            
11300>>>>>            If (iLen > iVariableBufferLength) Begin
11302>>>>>                // Allocate
11302>>>>>                Move (Repeat(' ', iLen)) to wVariableResult
11303>>>>>                
11303>>>>>                Set piVariableBufferLength to iLen
11304>>>>>                Set psVariableBuffer       to wVariableResult
11305>>>>>                
11305>>>>>                Get piVariableBufferLength to iVariableBufferLength
11306>>>>>            End
11306>>>>>>
11306>>>>>        End
11306>>>>>>
11306>>>>>        
11306>>>>>        // Fetch
11306>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11308>>>>>            Move (False) to Err
11309>>>>>            
11309>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11309>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
11309>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
11309>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11311>>>>>                // Setup function arguments
11311>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
11316>>>>>                Move ihstmt to giLastSQLhstmt
11317>>>>>                Move ihdbc to giLastSQLhdbc
11318>>>>>            End
11318>>>>>>
11318>>>>>            
11318>>>>>            // Call the driver function to fetch
11318>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
11323>>>>>            
11323>>>>>            // If something went wrong, adjust the result
11323>>>>>            If (Err) ;                Move 0 to iResult
11326>>>>>            
11326>>>>>            If (iResult) Begin
11328>>>>>                For iCol from 1 to iColCount
11334>>>>>>
11334>>>>>                    
11334>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
11336>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                            Callback 0 ;                            Passing sEmpty sEmpty iCol ;                            Result pResultWStr
11341>>>>>                            
11341>>>>>                        If (pResultWStr) Begin
11343>>>>>                            Move (CString(PointerToWString(pResultWStr))) to asValues[iCol - 1]
11344>>>>>                        End
11344>>>>>>
11344>>>>>                        Else Begin
11345>>>>>                            Move "" to asValues[iCol - 1]
11346>>>>>                        End
11346>>>>>>
11346>>>>>                        
11346>>>>>                    End
11346>>>>>>
11346>>>>>                    Else Begin
11347>>>>>                        Get psVariableBuffer       to wVariableResult
11348>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing iCol iVariableBufferLength (AddressOf(wVariableResult));                            Result iVoid
11353>>>>>                        
11353>>>>>                        Move (CString(wVariableResult)) to asValues[iCol - 1]
11354>>>>>                    End
11354>>>>>>
11354>>>>>                    
11354>>>>>                Loop
11355>>>>>>
11355>>>>>            End
11355>>>>>>
11355>>>>>        End
11355>>>>>>
11355>>>>>        Else Begin
11356>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
11357>>>>>        End
11357>>>>>>
11357>>>>>        
11357>>>>>        Set piFetchResult to iResult
11358>>>>>        
11358>>>>>        Function_Return asValues
11359>>>>>        
11359>>>>>    End_Function
11360>>>>>    
11360>>>>>    // Fetch a complete result set.
11360>>>>>    // Returns  : 2-dimensional array of strings with result set
11360>>>>>    // Sets piFetchResult property
11360>>>>>    //   0    = No more data
11360>>>>>    //   <> 0 = Success
11360>>>>>    Function SQLFetchResultsetValues Returns String[][]
11362>>>>>        
11362>>>>>        String[][] asValues
11363>>>>>        
11363>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
11363>>>>>        String sDrvrId sEmpty sMax
11363>>>>>        Longptr pResultWStr
11363>>>>>        WString wResult
11363>>>>>        
11363>>>>>        tSQLColumn[] aSQLColumns
11363>>>>>        tSQLColumn[] aSQLColumns
11364>>>>>        WString  wVariableResult
11364>>>>>        Integer iHasVariableDataType
11364>>>>>        Integer iLen
11364>>>>>        Integer iVariableBufferLength
11364>>>>>        
11364>>>>>        // Initialize
11364>>>>>        Move "" to sEmpty
11365>>>>>        Move 0  to iResult
11366>>>>>        
11366>>>>>        // Get the cli handles
11366>>>>>        Get phCLIStatementHandle  to ihstmt
11367>>>>>        Get phCLIConnectionHandle to ihdbc
11368>>>>>        Get psDriverId            to sDrvrId
11369>>>>>        
11369>>>>>        // Fetch
11369>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11371>>>>>            Move False to Err
11372>>>>>            
11372>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11372>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
11372>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
11372>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11374>>>>>                // Setup function arguments
11374>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
11379>>>>>                Move ihstmt to giLastSQLhstmt
11380>>>>>                Move ihdbc to giLastSQLhdbc
11381>>>>>            End
11381>>>>>>
11381>>>>>            
11381>>>>>            Get piColumnCount to iColCount
11382>>>>>            If (iColCount) Begin
11384>>>>>                Get paSQLColumns to aSQLColumns
11385>>>>>                Get piHasVariableDataType to iHasVariableDataType
11386>>>>>                If (iHasVariableDataType) Begin
11388>>>>>                    Get piVariableBufferLength      to iVariableBufferLength
11389>>>>>                    Get piMaxVariableBufferLength   to iLen
11390>>>>>                    If (iLen > iVariableBufferLength) Begin
11392>>>>>                        // Allocate
11392>>>>>                        Move (Repeat(' ', iLen)) to wVariableResult
11393>>>>>                        
11393>>>>>                        Set piVariableBufferLength to iLen
11394>>>>>                        Set psVariableBuffer       to wVariableResult
11395>>>>>                        
11395>>>>>                        Get piVariableBufferLength to iVariableBufferLength
11396>>>>>                    End
11396>>>>>>
11396>>>>>                    Else Begin
11397>>>>>                        Set psVariableBuffer       to wVariableResult
11398>>>>>                    End
11398>>>>>>
11398>>>>>                End
11398>>>>>>
11398>>>>>                
11398>>>>>                // Call the driver function to fetch
11398>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11403>>>>>                If (Err) ;                    Move 0 to iResult
11406>>>>>                
11406>>>>>                While (iResult <> 0)
11410>>>>>                    
11410>>>>>                    For iCol from 1 to (iColCount)
11416>>>>>>
11416>>>>>                        
11416>>>>>                        If (not(aSQLColumns[iCol].iVariableDataType)) Begin
11418>>>>>                            
11418>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback 0 ;                                Passing sEmpty sEmpty iCol ;                                Result pResultWStr
11423>>>>>                            
11423>>>>>                            If (pResultWStr) Begin
11425>>>>>                                Move (CString(PointerToWString(pResultWStr))) to asValues[iRow][iCol - 1]
11426>>>>>                            End
11426>>>>>>
11426>>>>>                            Else Begin
11427>>>>>                                Move "" to asValues[iRow][iCol - 1]
11428>>>>>                            End
11428>>>>>>
11428>>>>>                        End
11428>>>>>>
11428>>>>>                        Else Begin
11429>>>>>                            //Variable data
11429>>>>>                            Move wVariableResult to wResult
11430>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback 0 ;                                Passing iCol iVariableBufferLength (AddressOf(wResult)) ;                                Result iVoid
11435>>>>>                            
11435>>>>>                            Move (CString(wResult)) to asValues[iRow][iCol - 1]
11436>>>>>                        End
11436>>>>>>
11436>>>>>                    Loop
11437>>>>>>
11437>>>>>                    
11437>>>>>                    Increment iRow
11438>>>>>                    
11438>>>>>                    // Call the driver function to fetch
11438>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
11443>>>>>                    If (Err) ;                        Move 0 to iResult
11446>>>>>                    
11446>>>>>                Loop
11447>>>>>>
11447>>>>>            End
11447>>>>>>
11447>>>>>        End
11447>>>>>>
11447>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
11449>>>>>        
11449>>>>>        Set piFetchResult to iResult
11450>>>>>        
11450>>>>>        Function_Return asValues
11451>>>>>    End_Function
11452>>>>>    
11452>>>>>    // Get the next column
11452>>>>>    Function SQLNextColumn Returns String
11454>>>>>        Integer iCol
11454>>>>>        String  sResult
11454>>>>>        
11454>>>>>        Get piLastColumn to iCol
11455>>>>>        Increment iCol
11456>>>>>        Get SQLColumnValue iCol to sResult
11457>>>>>        Set piLastColumn to iCol
11458>>>>>        
11458>>>>>        Function_Return sResult
11459>>>>>    End_Function
11460>>>>>    
11460>>>>>    
11460>>>>>    // Returns the native type of a column
11460>>>>>    Function SQLColumnType Integer iCol Returns Integer
11462>>>>>        Integer ihdbc
11462>>>>>        Integer ihstmt
11462>>>>>        String  sDrvrId
11462>>>>>        Integer iSQLType
11462>>>>>        Integer iColumns
11462>>>>>        
11462>>>>>        tSQLColumn[] aSQLColumns
11462>>>>>        tSQLColumn[] aSQLColumns
11463>>>>>        
11463>>>>>        // Get the cli handles
11463>>>>>        Get phCLIStatementHandle  to ihstmt
11464>>>>>        Get phCLIConnectionHandle to ihdbc
11465>>>>>        Get psDriverId            to sDrvrId
11466>>>>>        
11466>>>>>        // Get the value
11466>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11468>>>>>            
11468>>>>>            Get paSQLColumns   to aSQLColumns
11469>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11470>>>>>            
11470>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11472>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
11473>>>>>            End
11473>>>>>>
11473>>>>>            Else Begin
11474>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"
11475>>>>>            End
11475>>>>>>
11475>>>>>        End
11475>>>>>>
11475>>>>>        Else Begin
11476>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
11477>>>>>        End
11477>>>>>>
11477>>>>>        
11477>>>>>        Function_Return iSQLType
11478>>>>>    End_Function
11479>>>>>    
11479>>>>>    // Returns the size (max length) of a column
11479>>>>>    Function SQLColumnSize Integer iCol Returns Integer
11481>>>>>        Integer ihdbc
11481>>>>>        Integer ihstmt
11481>>>>>        String  sDrvrId
11481>>>>>        Integer iSQLSize
11481>>>>>        Integer iColumns
11481>>>>>        
11481>>>>>        tSQLColumn[] aSQLColumns
11481>>>>>        tSQLColumn[] aSQLColumns
11482>>>>>        
11482>>>>>        // Get the cli handles
11482>>>>>        Get phCLIStatementHandle  to ihstmt
11483>>>>>        Get phCLIConnectionHandle to ihdbc
11484>>>>>        Get psDriverId            to sDrvrId
11485>>>>>        
11485>>>>>        // Get the value
11485>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11487>>>>>            
11487>>>>>            Get paSQLColumns   to aSQLColumns
11488>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11489>>>>>            
11489>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11491>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
11492>>>>>            End
11492>>>>>>
11492>>>>>            Else Begin
11493>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"
11494>>>>>            End
11494>>>>>>
11494>>>>>        End
11494>>>>>>
11494>>>>>        Else Begin
11495>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
11496>>>>>        End
11496>>>>>>
11496>>>>>        
11496>>>>>        Function_Return iSQLSize
11497>>>>>    End_Function
11498>>>>>    
11498>>>>>    //  Returns 1 for variable length datatypes.
11498>>>>>    //  For example SQL Server varchar(max) or text type
11498>>>>>    //  The data of variable length datatype columns should be retrieved with SQLGetData
11498>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
11500>>>>>        Integer ihdbc
11500>>>>>        Integer ihstmt
11500>>>>>        String  sDrvrId
11500>>>>>        Integer iVariableDataType
11500>>>>>        Integer iColumns
11500>>>>>        
11500>>>>>        tSQLColumn[] aSQLColumns
11500>>>>>        tSQLColumn[] aSQLColumns
11501>>>>>        
11501>>>>>        // Get the cli handles
11501>>>>>        Get phCLIStatementHandle  to ihstmt
11502>>>>>        Get phCLIConnectionHandle to ihdbc
11503>>>>>        Get psDriverId            to sDrvrId
11504>>>>>        
11504>>>>>        // Get the value
11504>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11506>>>>>            
11506>>>>>            Get paSQLColumns   to aSQLColumns
11507>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
11508>>>>>            
11508>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
11510>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
11511>>>>>            End
11511>>>>>>
11511>>>>>            Else Begin
11512>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"
11513>>>>>            End
11513>>>>>>
11513>>>>>        End
11513>>>>>>
11513>>>>>        Else Begin
11514>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
11515>>>>>        End
11515>>>>>>
11515>>>>>        
11515>>>>>        Function_Return iVariableDataType
11516>>>>>    End_Function
11517>>>>>    
11517>>>>>    
11517>>>>>    // Return the value of a column in a fetched row of a given
11517>>>>>    // statement.
11517>>>>>    Function SQLColumnValue Integer iCol Returns String
11519>>>>>        Integer ihdbc
11519>>>>>        Integer ihstmt
11519>>>>>        String  sDrvrId sResult
11519>>>>>        Longptr pResultWStr
11519>>>>>        
11519>>>>>        Integer iVoid
11519>>>>>        Integer iColSize
11519>>>>>        Integer iColPrecision
11519>>>>>        String  sEmpty
11519>>>>>        Integer bLegalColumn
11519>>>>>        
11519>>>>>        // Initialize
11519>>>>>        Move "" to sResult
11520>>>>>        
11520>>>>>        // Get the cli handles
11520>>>>>        Get phCLIStatementHandle  to ihstmt
11521>>>>>        Get phCLIConnectionHandle to ihdbc
11522>>>>>        Get psDriverId            to sDrvrId
11523>>>>>        
11523>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11523>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
11523>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
11523>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11525>>>>>            // Setup function arguments
11525>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback 0 ;                Passing ihdbc iCol ihstmt ;                Result iVoid
11530>>>>>            Move ihstmt to giLastSQLhstmt
11531>>>>>            Move ihdbc to giLastSQLhdbc
11532>>>>>        End
11532>>>>>>
11532>>>>>        
11532>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11534>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                Callback 0 ;                Passing sResult sEmpty iCol ;                Result pResultWStr
11539>>>>>            
11539>>>>>            If (pResultWStr) Begin
11541>>>>>                Move (PointerToWString(pResultWStr)) to sResult
11542>>>>>            End
11542>>>>>>
11542>>>>>            Else Begin
11543>>>>>                Move "" to sResult
11544>>>>>            End
11544>>>>>>
11544>>>>>        End
11544>>>>>>
11544>>>>>        Else Begin
11545>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
11546>>>>>        End
11546>>>>>>
11546>>>>>        
11546>>>>>        Function_Return sResult
11547>>>>>        
11547>>>>>    End_Function
11548>>>>>    
11548>>>>>    // Add a file to the files used to place the statement result in.
11548>>>>>    Procedure SQLBindFile Integer iFileNum
11550>>>>>        Integer ihdbc
11550>>>>>        Integer ihstmt
11550>>>>>        Integer iVoid
11550>>>>>        String  sDrvrId
11550>>>>>        String  sFileType
11550>>>>>        Integer bIsOpen
11550>>>>>        
11550>>>>>        // Get the cli handles
11550>>>>>        Get phCLIStatementHandle  to ihstmt
11551>>>>>        Get phCLIConnectionHandle to ihdbc
11552>>>>>        Get psDriverId            to sDrvrId
11553>>>>>        
11553>>>>>        // If a file number is not passed see if we can use the statement's
11553>>>>>        // default file number which is usually set with SetFileConnection
11553>>>>>        If (iFileNum = 0) Begin
11555>>>>>            Get piBindFile to iFileNum
11556>>>>>            If (iFileNum = 0) Begin
11558>>>>>                // Logic error, if 0 is passed as filenumber, piBindFile should be set.
11558>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
11559>>>>>                
11559>>>>>                Move 0 to SQLResult
11560>>>>>                Procedure_Return
11561>>>>>            End
11561>>>>>>
11561>>>>>        End
11561>>>>>>
11561>>>>>        
11561>>>>>        // Bind the file
11561>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11563>>>>>            // Chek if the file is open
11563>>>>>            Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
11566>>>>>            If (bIsOpen) Begin
11568>>>>>                // Check if the file has the correct type
11568>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
11571>>>>>                If (sFileType = sDrvrId) Begin
11573>>>>>                    // Call the driver function to add a file to a statement
11573>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                        Callback Self ;                        Passing ihdbc iFileNum ihstmt ;                        Result iVoid
11578>>>>>                End
11578>>>>>>
11578>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
11580>>>>>            End
11580>>>>>>
11580>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
11582>>>>>        End
11582>>>>>>
11582>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
11584>>>>>    End_Procedure
11585>>>>>    
11585>>>>>    
11585>>>>>    
11585>>>>>    // Get data of a column.                                  
11585>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
11587>>>>>        Integer ihdbc
11587>>>>>        Integer ihstmt
11587>>>>>        Integer iVoid
11587>>>>>        Integer iColSize
11587>>>>>        Integer iResult
11587>>>>>        String  sDrvrId
11587>>>>>        WString wResult
11587>>>>>        String  sEmpty
11587>>>>>        Integer bLegalColumn
11587>>>>>        
11587>>>>>        Integer iVariableBufferLength
11587>>>>>        
11587>>>>>        // Initialize
11587>>>>>        Move "" to sEmpty
11588>>>>>        Move 0 to iResult
11589>>>>>        
11589>>>>>        // Get the cli handles
11589>>>>>        Get phCLIStatementHandle  to ihstmt
11590>>>>>        Get phCLIConnectionHandle to ihdbc
11591>>>>>        Get psDriverId            to sDrvrId
11592>>>>>        
11592>>>>>        // Get the data
11592>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11594>>>>>            // Check if the column exists
11594>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11596>>>>>                If (iLen = 0) Begin
11598>>>>>                    Get SQLColumnValue iCol to wResult
11599>>>>>                End
11599>>>>>>
11599>>>>>                Else Begin
11600>>>>>                    // Add 1 for string terminator
11600>>>>>                    Move (iLen + 1) to iLen
11601>>>>>                    
11601>>>>>                    Get piVariableBufferLength to iVariableBufferLength
11602>>>>>                    If (iLen > iVariableBufferLength) Begin
11604>>>>>                        // Allocate
11604>>>>>                        Move (Repeat(' ', iLen)) to wResult
11605>>>>>                        
11605>>>>>                        Set piVariableBufferLength to iLen
11606>>>>>                        Set psVariableBuffer       to wResult
11607>>>>>                    End
11607>>>>>>
11607>>>>>                    Else Begin
11608>>>>>                        Get psVariableBuffer       to wResult
11609>>>>>                    End
11609>>>>>>
11609>>>>>                    
11609>>>>>                    
11609>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11609>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
11609>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
11609>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11611>>>>>                        // Setup function arguments
11611>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                            Callback 0 ;                            Passing ihdbc iCol ihstmt ;                            Result iVoid
11616>>>>>                        Move ihstmt to giLastSQLhstmt
11617>>>>>                        Move ihdbc to giLastSQLhdbc
11618>>>>>                    End
11618>>>>>>
11618>>>>>                    
11618>>>>>                    Move False to Err
11619>>>>>                    // Call the driver function to get the data
11619>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                        Callback Self ;                        Passing iCol iLen (AddressOf(wResult)) ;                        Result iResult
11624>>>>>                    
11624>>>>>                    // If something went wrong, adjust the result
11624>>>>>                    If (Err) Begin
11626>>>>>                        Move 0 to iResult
11627>>>>>                    End
11627>>>>>>
11627>>>>>                    
11627>>>>>                    // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
11627>>>>>                    If (iResult = -4) Begin
11629>>>>>                        Move (SizeOfWString(wResult)) to iResult
11630>>>>>                    End
11630>>>>>>
11630>>>>>                End
11630>>>>>>
11630>>>>>            End
11630>>>>>>
11630>>>>>            Else Begin
11631>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
11632>>>>>            End
11632>>>>>>
11632>>>>>        End
11632>>>>>>
11632>>>>>        Else Begin
11633>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
11634>>>>>        End
11634>>>>>>
11634>>>>>        
11634>>>>>        // Fill global result
11634>>>>>        If (iResult > 0) Begin
11636>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
11637>>>>>        End
11637>>>>>>
11637>>>>>        Else Begin
11638>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
11639>>>>>        End
11639>>>>>>
11639>>>>>        
11639>>>>>        Function_Return (CString(wResult))
11640>>>>>    End_Function
11641>>>>>
11641>>>>>    // SQLGetDataToUChar (SQLGetData returning uchar array)
11641>>>>>    // Use for binary data and for character data containing Unicode non-bmp characters
11641>>>>>    Function SQLGetDataToUChar Integer iCol Integer iLen Returns UChar[]
11643>>>>>        Integer ihdbc
11643>>>>>        Integer ihstmt
11643>>>>>        Integer iVoid
11643>>>>>        Integer iColSize
11643>>>>>        Integer iResult
11643>>>>>        String  sDrvrId
11643>>>>>        UChar[] uaResult
11644>>>>>        
11644>>>>>        Integer iSQLType
11644>>>>>        Integer iBinaryType
11644>>>>>        Integer iLenArray
11644>>>>>        Integer iResizeSize
11644>>>>>        
11644>>>>>        Move 0 to iResult
11645>>>>>        
11645>>>>>        // Get the cli handles
11645>>>>>        Get phCLIStatementHandle  to ihstmt
11646>>>>>        Get phCLIConnectionHandle to ihdbc
11647>>>>>        Get psDriverId            to sDrvrId
11648>>>>>        
11648>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11650>>>>>            // Check if the column exists
11650>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
11652>>>>>                            
11652>>>>>                Get SQLColumnType iCol to iSQLType
11653>>>>>                If ( (iSQLType = SQL_BINARY) or (iSQLType = SQL_VARBINARY) or (iSQLType = SQL_LONGVARBINARY) ) Begin
11655>>>>>                    Move 1 to iBinaryType
11656>>>>>                End
11656>>>>>>
11656>>>>>                Else Begin
11657>>>>>                    Move 0 to iBinaryType 
11658>>>>>                End
11658>>>>>>
11658>>>>>    
11658>>>>>                If (iBinaryType) Begin
11660>>>>>                    Move (ResizeArray(uaResult,iLen)) to uaResult
11661>>>>>                End
11661>>>>>>
11661>>>>>                Else Begin
11662>>>>>                    // Character type
11662>>>>>                    // returned as wstring (2 bytes per character)
11662>>>>>                    // Add 1 for string terminator
11662>>>>>                    Move (iLen + 1) to iLen
11663>>>>>                    Move (iLen * 2) to iLenArray // wstring 2 bytes per char
11664>>>>>                    Move (ResizeArray(uaResult,iLenArray)) to uaResult
11665>>>>>                End
11665>>>>>>
11665>>>>>
11665>>>>>                // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
11665>>>>>                // in the next FUNC_SQLCOLUMNVALUE call.
11665>>>>>                If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
11667>>>>>                    // Setup function arguments
11667>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
11672>>>>>                    Move ihstmt to giLastSQLhstmt
11673>>>>>                    Move ihdbc to giLastSQLhdbc
11674>>>>>                End
11674>>>>>>
11674>>>>>                
11674>>>>>                Move False to Err
11675>>>>>                
11675>>>>>                // Call the driver function to get the data
11675>>>>>                // iResult will be the length of the data in bytes 
11675>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                    Callback Self ;                    Passing iCol iLen (AddressOf(uaResult[0])) ;                    Result iResult
11680>>>>>                
11680>>>>>                // If something went wrong, adjust the result
11680>>>>>                If (Err) Begin
11682>>>>>                    Move 0 to iResult
11683>>>>>                End
11683>>>>>>
11683>>>>>                
11683>>>>>                // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
11683>>>>>                If (iResult = -4) Begin
11685>>>>>                    Move (SizeOfArray(uaResult)) to iResult
11686>>>>>                End
11686>>>>>>
11686>>>>>                
11686>>>>>                If (iBinaryType) Begin
11688>>>>>                    If (iResult < iLen) Begin
11690>>>>>                        Move (ResizeArray(uaResult,iResult)) to uaResult
11691>>>>>                    End
11691>>>>>>
11691>>>>>                End
11691>>>>>>
11691>>>>>                Else Begin
11692>>>>>                    // Character data
11692>>>>>                    //   iResult has length of data in bytes (without zero terminator)
11692>>>>>                    //   uaResult will have data + zero terminator
11692>>>>>                    If (iResult < (iLenArray - 2) ) Begin
11694>>>>>                        // Received less than requested, strip off trailing zeroes.
11694>>>>>                        Move iResult to iResizeSize
11695>>>>>                    End
11695>>>>>>
11695>>>>>                    Else Begin
11696>>>>>                        // Strip off zero terminator
11696>>>>>                        Move (iLenArray - 2) to iResizeSize
11697>>>>>                    End
11697>>>>>>
11697>>>>>                    
11697>>>>>                    Move (ResizeArray(uaResult,iResizeSize)) to uaResult
11698>>>>>                    
11698>>>>>                End
11698>>>>>>
11698>>>>>            End
11698>>>>>>
11698>>>>>            Else Begin
11699>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
11700>>>>>            End
11700>>>>>>
11700>>>>>        End
11700>>>>>>
11700>>>>>        Else Begin
11701>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
11702>>>>>        End
11702>>>>>>
11702>>>>>        
11702>>>>>        // Fill global result
11702>>>>>        If (iResult > 0) Begin
11704>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
11705>>>>>        End
11705>>>>>>
11705>>>>>        Else Begin
11706>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
11707>>>>>        End
11707>>>>>>
11707>>>>>        
11707>>>>>        Function_Return uaResult
11708>>>>>
11708>>>>>    End_Function
11709>>>>>    
11709>>>>>    
11709>>>>>    // Map a column name to a number, if the name id not found no
11709>>>>>    // error is generated the returned number will be 0 (zero) in
11709>>>>>    // that case
11709>>>>>    Function SQLColumnMap String sColname Returns Integer
11711>>>>>        Integer ihdbc
11711>>>>>        Integer ihstmt
11711>>>>>        Integer iNumColumns
11711>>>>>        Integer iColCount
11711>>>>>        Integer iColNum
11711>>>>>        String  sDrvrId
11711>>>>>        String  sCurColName
11711>>>>>        
11711>>>>>        // Get the cli handles
11711>>>>>        Get phCLIStatementHandle  to ihstmt
11712>>>>>        Get phCLIConnectionHandle to ihdbc
11713>>>>>        Get psDriverId            to sDrvrId
11714>>>>>        
11714>>>>>        // Get the number by looping through the column names
11714>>>>>        Move 0 to iColNum
11715>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
11716>>>>>        For iColCount from 1 to iNumColumns
11722>>>>>>
11722>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt to sCurColName
11723>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount to iColNum
11726>>>>>            
11726>>>>>            If (iColNum) ;                Break
11729>>>>>        Loop
11730>>>>>>
11730>>>>>        
11730>>>>>        Function_Return iColNum
11731>>>>>    End_Function
11732>>>>>    
11732>>>>>    
11732>>>>>    // SQLStmtAttribute
11732>>>>>    // Moved to SQLGetStatementAttribute. 
11732>>>>>    // This function is still here for backward compatibility.
11732>>>>>
11732>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
11734>>>>>        String  sResult
11734>>>>>
11734>>>>>        Get SQLGetStmtAttribute iAttribId to sResult        
11735>>>>>        
11735>>>>>        Function_Return sResult
11736>>>>>    End_Function
11737>>>>>
11737>>>>> 
11737>>>>>   Function SQLGetStmtAttribute Integer iAttribId Returns String
11739>>>>>        Integer ihdbc
11739>>>>>        Integer ihstmt
11739>>>>>        String  sResult
11739>>>>>        String  sDrvrId
11739>>>>>        
11739>>>>>        // Initialize
11739>>>>>        Move "" to sResult
11740>>>>>        
11740>>>>>        // Get the cli handles
11740>>>>>        Get phCLIStatementHandle  to ihstmt
11741>>>>>        Get phCLIConnectionHandle to ihdbc
11742>>>>>        Get psDriverId            to sDrvrId
11743>>>>>        
11743>>>>>        // Get the attribute
11743>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt to sResult
11746>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetStmtAttribute"
11748>>>>>        
11748>>>>>        Function_Return sResult
11749>>>>>    End_Function
11750>>>>>
11750>>>>>    
11750>>>>>    Procedure SQLSetStmtAttribute Integer iAttribId String sAttribValue 
11752>>>>>
11752>>>>>        Integer ihdbc
11752>>>>>        Integer ihstmt
11752>>>>>        String  sDrvrId
11752>>>>>        
11752>>>>>        Integer iLen
11752>>>>>        Integer bLegalAttrib
11752>>>>>        Integer iVoid
11752>>>>>        Integer iAttribValue
11752>>>>>
11752>>>>>        Get phCLIStatementHandle  to ihstmt
11753>>>>>        Get phCLIConnectionHandle to ihdbc
11754>>>>>        Get psDriverId            to sDrvrId
11755>>>>>        
11755>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11757>>>>>            Case Begin
11757>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
11759>>>>>                    Move DFTRUE to bLegalAttrib
11760>>>>>                    Break
11761>>>>>                    
11761>>>>>                Case Else
11761>>>>>                    Move DFFALSE to bLegalAttrib
11762>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLSetStmtAttribute"
11763>>>>>            Case End
11763>>>>>
11763>>>>>            If (bLegalAttrib) Begin
11765>>>>>                If (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE) Begin
11767>>>>>                    
11767>>>>>                    Move sAttribValue to iAttribValue // Check numeric?
11768>>>>>                    Case Begin
11768>>>>>                        Case (iAttribValue = SQL_CURSOR_FORWARD_ONLY)
11770>>>>>                        Case (iAttribValue = SQL_CURSOR_DYNAMIC)
11773>>>>>                        Case (iAttribValue = SQL_CURSOR_KEYSET_DRIVEN)
11776>>>>>                        Case (iAttribValue = SQL_CURSOR_STATIC)
11779>>>>>                            Break
11780>>>>>                            
11780>>>>>                        Case Else
11780>>>>>                            Move DFFALSE to bLegalAttrib
11781>>>>>                            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE (SFormat("Invalid value for SQLSTMTATTRIB_CURSOR_TYPE: %1", iAttribValue)) "SQLSetStmtAttribute"
11782>>>>>
11782>>>>>                    Case End
11782>>>>>                End
11782>>>>>>
11782>>>>>            End
11782>>>>>>
11782>>>>>
11782>>>>>            
11782>>>>>            If (bLegalAttrib) Begin
11784>>>>>                
11784>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                    Callback Self ;                    Passing ihdbc iVoid ihstmt ;                    Result iVoid
11789>>>>>                
11789>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETSTMTINTATTRIB ;                    Callback Self ;                    Passing iAttribId iAttribValue 0 ;                    Result iVoid
11794>>>>>            End
11794>>>>>>
11794>>>>>        End
11794>>>>>>
11794>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
11796>>>>>        
11796>>>>>        
11796>>>>>        
11796>>>>>    End_Procedure
11797>>>>>    
11797>>>>>    
11797>>>>>    
11797>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
11799>>>>>        String  sResult
11799>>>>>        Integer iLen
11799>>>>>        Integer bLegalAttrib
11799>>>>>        
11799>>>>>        // Initialize
11799>>>>>        Move ""     to sResult
11800>>>>>        
11800>>>>>        // Get the attribute
11800>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11802>>>>>            Case Begin
11802>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
11804>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
11807>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
11810>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
11813>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
11816>>>>>                    Move DFTRUE to bLegalAttrib
11817>>>>>                    Break
11818>>>>>                    
11818>>>>>                Case Else
11818>>>>>                    Move DFFALSE to bLegalAttrib
11819>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
11820>>>>>            Case End
11820>>>>>            
11820>>>>>            If (bLegalAttrib) Begin
11822>>>>>                // Setup function arguments
11822>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                    Callback Self ;                    Passing ihdbc iAttribId ihstmt ;                    Result sResult
11827>>>>>            End
11827>>>>>>
11827>>>>>        End
11827>>>>>>
11827>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
11829>>>>>        
11829>>>>>        Function_Return sResult
11830>>>>>    End_Function
11831>>>>>    
11831>>>>>    
11831>>>>>    
11831>>>>>    // Get a column's attribute
11831>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
11833>>>>>        Integer ihdbc
11833>>>>>        Integer ihstmt
11833>>>>>        String  sResult
11833>>>>>        String  sDrvrId
11833>>>>>        
11833>>>>>        // Initialize
11833>>>>>        Move "" to sResult
11834>>>>>        
11834>>>>>        // Get the cli handles
11834>>>>>        Get phCLIStatementHandle  to ihstmt
11835>>>>>        Get phCLIConnectionHandle to ihdbc
11836>>>>>        Get psDriverId            to sDrvrId
11837>>>>>        
11837>>>>>        // Get the attribute
11837>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt to sResult
11840>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
11842>>>>>        
11842>>>>>        Function_Return sResult
11843>>>>>    End_Function
11844>>>>>    
11844>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
11846>>>>>        String  sResult
11846>>>>>        String  sEmpty
11846>>>>>        Integer bIsStringAttribute
11846>>>>>        Integer iLen
11846>>>>>        Integer iVoid
11846>>>>>        Integer bLegalAttrib
11846>>>>>        Integer bLegalColumn
11846>>>>>        
11846>>>>>        // Initialize
11846>>>>>        Move "" to sResult
11847>>>>>        Move "" to sEmpty
11848>>>>>        Move 0  to iLen
11849>>>>>        
11849>>>>>        // Get the attribute
11849>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11851>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol to bLegalColumn
11852>>>>>            If (bLegalColumn) Begin
11854>>>>>                // Determine the atributes type
11854>>>>>                Case Begin
11854>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
11856>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
11859>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
11862>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
11865>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
11868>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
11871>>>>>                        Move DFFALSE to bIsStringAttribute
11872>>>>>                        Move DFTRUE to bLegalAttrib
11873>>>>>                        Break
11874>>>>>                        
11874>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
11877>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
11880>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
11883>>>>>                        Move DFTRUE to bIsStringAttribute
11884>>>>>                        Move DFTRUE to bLegalAttrib
11885>>>>>                        Break
11886>>>>>                        
11886>>>>>                    Case Else
11886>>>>>                        Move DFFALSE to bLegalAttrib
11887>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
11888>>>>>                Case End
11888>>>>>                
11888>>>>>                If (bLegalAttrib) Begin
11890>>>>>                    // Setup function arguments
11890>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
11895>>>>>                    
11895>>>>>                    If (bIsStringAttribute) Begin
11897>>>>>                        // Call the driver function to get the data length
11897>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result iLen
11902>>>>>                        
11902>>>>>                        If (iLen) Begin
11904>>>>>                            // Allocate
11904>>>>>                            Move (Repeat(' ', iLen)) to sResult
11905>>>>>                            
11905>>>>>                            // Call the driver function to get the name
11905>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                Callback Self ;                                Passing sResult sEmpty iAttribId ;                                Result iVoid
11910>>>>>                        End
11910>>>>>>
11910>>>>>                    End
11910>>>>>>
11910>>>>>                    Else Begin
11911>>>>>                        // get the attribute
11911>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result sResult
11916>>>>>                    End
11916>>>>>>
11916>>>>>                End
11916>>>>>>
11916>>>>>            End
11916>>>>>>
11916>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
11918>>>>>        End
11918>>>>>>
11918>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
11920>>>>>        
11920>>>>>        Function_Return sResult
11921>>>>>    End_Function
11922>>>>>    
11922>>>>>    
11922>>>>>    // Preapre for calling a stored procedure, pass the procedure name.
11922>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
11924>>>>>        Integer ihdbc
11924>>>>>        Integer ihstmt
11924>>>>>        String  sDrvrId
11924>>>>>        Integer iVoid
11924>>>>>        String  sSchema
11924>>>>>        String  sEmpty
11924>>>>>        
11924>>>>>        // Initialize
11924>>>>>        Move "" to sEmpty
11925>>>>>        
11925>>>>>        // Get the cli handles
11925>>>>>        Get phCLIStatementHandle  to ihstmt
11926>>>>>        Get phCLIConnectionHandle to ihdbc
11927>>>>>        Get psDriverId            to sDrvrId
11928>>>>>        
11928>>>>>        // Call the procedure
11928>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11930>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg to sSchema
11933>>>>>            Else ;                Move "" to sSchema
11935>>>>>            
11935>>>>>            If (sSchema <> "") Begin
11937>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                    Callback Self ;                    Passing ihdbc sSchema ihstmt ;                    Result iVoid
11942>>>>>            End
11942>>>>>>
11942>>>>>            
11942>>>>>            // Call the procedure
11942>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                Callback Self ;                Passing ihdbc sProcName ihstmt ;                Result iVoid
11947>>>>>            
11947>>>>>            Set piLastArgument to 0
11948>>>>>        End
11948>>>>>>
11948>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
11950>>>>>    End_Procedure
11951>>>>>    
11951>>>>>    // Pass the next argument
11951>>>>>    Procedure SQLSetNextArgument String sArgument
11953>>>>>        Integer iArgnum
11953>>>>>        
11953>>>>>        Get piLastArgument to iArgnum
11954>>>>>        Increment iArgnum
11955>>>>>        Send SQLSetArgument iArgnum sArgument
11956>>>>>        Set piLastArgument to iArgnum
11957>>>>>    End_Procedure
11958>>>>>    
11958>>>>>    
11958>>>>>    
11958>>>>>    // Set the next argument
11958>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
11960>>>>>        Integer ihdbc
11960>>>>>        Integer ihstmt
11960>>>>>        String  sDrvrId
11960>>>>>        Integer iVoid
11960>>>>>        String  sEmpty
11960>>>>>        
11960>>>>>        // Initialize
11960>>>>>        Move "" to sEmpty
11961>>>>>        
11961>>>>>        // Get the cli handles
11961>>>>>        Get phCLIStatementHandle  to ihstmt
11962>>>>>        Get phCLIConnectionHandle to ihdbc
11963>>>>>        Get psDriverId            to sDrvrId
11964>>>>>        
11964>>>>>        // Call the procedure
11964>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
11966>>>>>            // Pass the information
11966>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
11971>>>>>            
11971>>>>>            // Pass the argument
11971>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sArgument sEmpty 0 ;                Result iVoid
11976>>>>>        End
11976>>>>>>
11976>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
11978>>>>>    End_Procedure
11979>>>>>    
11979>>>>>    Procedure SQLSetNextParameter String sParamValue Integer iParamType
11981>>>>>        Integer iParamNum 
11981>>>>>        Integer iType
11981>>>>>        
11981>>>>>        If (num_arguments < 2) Begin
11983>>>>>            Move typeString to iType
11984>>>>>        End
11984>>>>>>
11984>>>>>        Else Begin
11985>>>>>            Move iParamType to iType
11986>>>>>        End
11986>>>>>>
11986>>>>>        
11986>>>>>        Get piLastArgument to iParamNum
11987>>>>>        Increment iParamNum
11988>>>>>        Send SQLSetParameter iParamNum sParamValue iType
11989>>>>>        Set piLastArgument to iParamNum
11990>>>>>    End_Procedure
11991>>>>>
11991>>>>>    Procedure SQLSetParameter Integer iParamNum String sParamValue Integer iParamType
11993>>>>>        
11993>>>>>        Integer ihdbc
11993>>>>>        Integer ihstmt
11993>>>>>        String  sDrvrId
11993>>>>>        Integer iVoid
11993>>>>>        String  sEmpty
11993>>>>>        Integer iType
11993>>>>>        
11993>>>>>        If (num_arguments < 3) Begin
11995>>>>>            Move typeString to iType
11996>>>>>        End
11996>>>>>>
11996>>>>>        Else Begin
11997>>>>>            Move iParamType to iType
11998>>>>>        End
11998>>>>>>
11998>>>>>        
11998>>>>>        Case Begin
11998>>>>>            Case (iType = typeDate )    
12000>>>>>
12000>>>>>                If (sParamValue <> "") Begin
12002>>>>>                    ConvertToXml typeDate sParamValue to sParamValue
12003>>>>>                End
12003>>>>>>
12003>>>>>                
12003>>>>>                Break
12004>>>>>
12004>>>>>            Case (iType = typeDatetime )    
12007>>>>>
12007>>>>>                If (sParamValue <> "") Begin
12009>>>>>                    ConvertToXml esqlDatetime sParamValue to sParamValue
12010>>>>>                    Move (Replace('T',sParamValue,' ')) to sParamValue 
12011>>>>>                End
12011>>>>>>
12011>>>>>
12011>>>>>                Break
12012>>>>>
12012>>>>>            Case (iType = typeNumber )    
12015>>>>>
12015>>>>>                If (sParamValue <> "") Begin
12017>>>>>                    ConvertToXml typeNumber sParamValue to sParamValue
12018>>>>>                End
12018>>>>>>
12018>>>>>                
12018>>>>>                Break
12019>>>>>            
12019>>>>>            Case (iType = typeTime )    
12022>>>>>
12022>>>>>                If (sParamValue <> "") Begin
12024>>>>>                    ConvertToXml esqlTime sParamValue to sParamValue
12025>>>>>                End
12025>>>>>>
12025>>>>>                
12025>>>>>                Break
12026>>>>>                
12026>>>>>            Case Else
12026>>>>>                    // sParamValue is a string type or a type that must be passed as a string
12026>>>>>                    Break
12027>>>>>                
12027>>>>>        Case End
12027>>>>>        
12027>>>>>        
12027>>>>>        // Initialize
12027>>>>>        Move "" to sEmpty
12028>>>>>        
12028>>>>>        // Get the cli handles
12028>>>>>        Get phCLIStatementHandle  to ihstmt
12029>>>>>        Get phCLIConnectionHandle to ihdbc
12030>>>>>        Get psDriverId            to sDrvrId
12031>>>>>        
12031>>>>>        // Call the procedure
12031>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12033>>>>>            // Pass the information
12033>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iParamnum ihstmt ;                Result iVoid
12038>>>>>            
12038>>>>>            // Pass the argument
12038>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sParamValue sEmpty 0 ;                Result iVoid
12043>>>>>        End
12043>>>>>>
12043>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetParameter"
12045>>>>>    End_Procedure
12046>>>>>    
12046>>>>>    
12046>>>>>    // Call a stored procedure
12046>>>>>    Procedure SQLCall
12048>>>>>        Integer ihdbc
12048>>>>>        Integer ihstmt
12048>>>>>        String  sDrvrId
12048>>>>>        Integer iVoid
12048>>>>>        String  sEmpty
12048>>>>>        
12048>>>>>        // Initialize
12048>>>>>        Move "" to sEmpty
12049>>>>>        
12049>>>>>        // Get the cli handles
12049>>>>>        Get phCLIStatementHandle  to ihstmt
12050>>>>>        Get phCLIConnectionHandle to ihdbc
12051>>>>>        Get psDriverId            to sDrvrId
12052>>>>>        
12052>>>>>        // Call the procedure
12052>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12054>>>>>            // Call the procedure
12054>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCALL ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
12059>>>>>            
12059>>>>>            Send SQLGetStatementAttributes
12060>>>>>            Set piLastArgument to 0
12061>>>>>        End
12061>>>>>>
12061>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
12063>>>>>    End_Procedure
12064>>>>>    
12064>>>>>    
12064>>>>>    // Get the next argument
12064>>>>>    Function SQLGetNextArgument Returns String
12066>>>>>        Integer iArgnum
12066>>>>>        String  sResult
12066>>>>>        
12066>>>>>        Get piLastArgument to iArgnum
12067>>>>>        Increment iArgnum
12068>>>>>        Get SQLGetArgument iArgnum to sResult
12069>>>>>        Set piLastArgument to iArgnum
12070>>>>>        
12070>>>>>        Function_Return sResult
12071>>>>>    End_Function
12072>>>>>    
12072>>>>>    
12072>>>>>    
12072>>>>>    // Get the specified argument from a procedure
12072>>>>>    Function SQLGetArgument Integer iArgnum Returns String
12074>>>>>        Integer ihdbc
12074>>>>>        Integer ihstmt
12074>>>>>        String  sDrvrId
12074>>>>>        Integer iVoid
12074>>>>>        String  sEmpty
12074>>>>>        String  sArgument
12074>>>>>        Integer iLen
12074>>>>>        
12074>>>>>        // Initialize
12074>>>>>        Move "" to sEmpty
12075>>>>>        Move "" to sArgument
12076>>>>>        
12076>>>>>        // Get the cli handles
12076>>>>>        Get phCLIStatementHandle  to ihstmt
12077>>>>>        Get phCLIConnectionHandle to ihdbc
12078>>>>>        Get psDriverId            to sDrvrId
12079>>>>>        
12079>>>>>        // Call the procedure
12079>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12081>>>>>            // Pass the information
12081>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
12086>>>>>            
12086>>>>>            // Get the length
12086>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result iLen
12091>>>>>            
12091>>>>>            If (iLen) Begin
12093>>>>>                // Allocate
12093>>>>>                Move (Repeat(' ', iLen)) to sArgument
12094>>>>>                
12094>>>>>                // Pass the argument
12094>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                    Callback Self ;                    Passing sArgument sEmpty 0 ;                    Result iVoid
12099>>>>>            End
12099>>>>>>
12099>>>>>        End
12099>>>>>>
12099>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
12101>>>>>        
12101>>>>>        Function_Return sArgument
12102>>>>>    End_Function
12103>>>>>    
12103>>>>>    
12103>>>>>    // Get the return value of a stored function
12103>>>>>    Function SQLReturnValue Returns String
12105>>>>>        Integer ihdbc
12105>>>>>        Integer ihstmt
12105>>>>>        String  sDrvrId
12105>>>>>        Integer iVoid
12105>>>>>        String  sEmpty
12105>>>>>        String  sRetval
12105>>>>>        Integer iLen
12105>>>>>        
12105>>>>>        // Initialize
12105>>>>>        Move "" to sEmpty
12106>>>>>        Move "" to sRetval
12107>>>>>        
12107>>>>>        // Get the cli handles
12107>>>>>        Get phCLIStatementHandle  to ihstmt
12108>>>>>        Get phCLIConnectionHandle to ihdbc
12109>>>>>        Get psDriverId            to sDrvrId
12110>>>>>        
12110>>>>>        // Call the procedure
12110>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12112>>>>>            // Get the length
12112>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iLen
12117>>>>>            
12117>>>>>            If (iLen) Begin
12119>>>>>                // Allocate
12119>>>>>                Move (Repeat(' ', iLen)) to sRetval
12120>>>>>                
12120>>>>>                // Pass the argument
12120>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                    Callback Self ;                    Passing ihdbc sRetval ihstmt ;                    Result iVoid
12125>>>>>            End
12125>>>>>>
12125>>>>>        End
12125>>>>>>
12125>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
12127>>>>>        
12127>>>>>        Function_Return sRetval
12128>>>>>    End_Function
12129>>>>>    
12129>>>>>    
12129>>>>>    // Switch to the next set
12129>>>>>    // Returns : 0   = No more result sets
12129>>>>>    //     <>0 = Switched to next set
12129>>>>>    Function SQLNextResultSet Returns Integer
12131>>>>>        Integer ihdbc
12131>>>>>        Integer ihstmt
12131>>>>>        String  sDrvrId
12131>>>>>        Integer iResult
12131>>>>>        String  sEmpty
12131>>>>>        
12131>>>>>        // Initialize
12131>>>>>        Move "" to sEmpty
12132>>>>>        Move 0  to iResult
12133>>>>>        
12133>>>>>        // Get the cli handles
12133>>>>>        Get phCLIStatementHandle  to ihstmt
12134>>>>>        Get phCLIConnectionHandle to ihdbc
12135>>>>>        Get psDriverId            to sDrvrId
12136>>>>>        
12136>>>>>        // Call the procedure
12136>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12138>>>>>            // Get the length
12138>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iResult
12143>>>>>            
12143>>>>>            Send SQLGetStatementAttributes
12144>>>>>            Set piLastArgument to 0
12145>>>>>        End
12145>>>>>>
12145>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
12147>>>>>        
12147>>>>>        Function_Return iResult
12148>>>>>    End_Function
12149>>>>>    
12149>>>>>    
12149>>>>>    // Setup a file that will be acivated after a succesfull
12149>>>>>    //fetch on the statement
12149>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
12151>>>>>        Integer ihdbc
12151>>>>>        Integer ihstmt
12151>>>>>        String  sDrvrId
12151>>>>>        Integer iResult
12151>>>>>        Integer bIsOpen
12151>>>>>        Integer iVoid
12151>>>>>        String  sFileType
12151>>>>>        
12151>>>>>        // Check if file is open
12151>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
12154>>>>>        If (bIsOpen) Begin
12156>>>>>            // Get the cli handles
12156>>>>>            Get phCLIStatementHandle  to ihstmt
12157>>>>>            Get phCLIConnectionHandle to ihdbc
12158>>>>>            Get psDriverId            to sDrvrId
12159>>>>>            
12159>>>>>            // Call the procedure
12159>>>>>            If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12161>>>>>                // Check if the file has the correct type
12161>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
12164>>>>>                If (sFileType = sDrvrId) Begin
12166>>>>>                    // Setup the buffer
12166>>>>>                    Call_Driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                        Callback Self ;                        Passing ihdbc bState ihstmt  ;                        Result iVoid
12171>>>>>                End
12171>>>>>>
12171>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
12173>>>>>            End
12173>>>>>>
12173>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
12175>>>>>        End
12175>>>>>>
12175>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
12177>>>>>    End_Procedure
12178>>>>>    
12178>>>>>    
12178>>>>>    
12178>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
12180>>>>>        Integer ihdbc
12180>>>>>        Integer ihstmt
12180>>>>>        String  sDrvrId
12180>>>>>        String  sMessage
12180>>>>>        Integer iVoid
12180>>>>>        
12180>>>>>        // Initialize
12180>>>>>        Move "" to sMessage
12181>>>>>        
12181>>>>>        // Get the cli handles
12181>>>>>        Get phCLIStatementHandle  to ihstmt
12182>>>>>        Get phCLIConnectionHandle to ihdbc
12183>>>>>        Get psDriverId            to sDrvrId
12184>>>>>        
12184>>>>>        // Call the procedure
12184>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
12186>>>>>            // Setup function arguments
12186>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iMessageNum ihstmt ;                Result iVoid
12191>>>>>            
12191>>>>>            Move (Repeat(' ', 1024)) to sMessage
12192>>>>>            // Get the length
12192>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                Callback Self ;                Passing iVoid sMessage iVoid ;                Result iVoid
12197>>>>>        End
12197>>>>>>
12197>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
12199>>>>>        
12199>>>>>        Function_Return sMessage
12200>>>>>    End_Function
12201>>>>>    
12201>>>>>    
12201>>>>>    
12201>>>>>    // Remove the component identifier from a diagnostic message
12201>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
12203>>>>>        While (Left(sDiagMessage, 1) = "[")
12207>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) to sDiagMessage
12208>>>>>        Loop
12209>>>>>>
12209>>>>>        
12209>>>>>        Function_Return sDiagMessage
12210>>>>>    End_Function
12211>>>>>    
12211>>>>>    
12211>>>>>    
12211>>>>>    // Convert a DataFlex date to a SQL Date. Use dummy zero dates.
12211>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
12213>>>>>        
12213>>>>>        Integer iType
12213>>>>>        String  sSQLDate
12213>>>>>        Integer iOrgDateFmt
12213>>>>>        Integer iOrgDateSep
12213>>>>>        
12213>>>>>        String sDriverId
12213>>>>>        String sDummyZeroDate
12213>>>>>        String sDummyZeroDateMssqlDatetime
12213>>>>>        
12213>>>>>        // Change date format to military, SQL dates are military dates
12213>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
12216>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12219>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
12222>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
12225>>>>>        
12225>>>>>        // We only need to convert if the date is 0
12225>>>>>        If (Integer(dDFDate = 0)) Begin
12227>>>>>            
12227>>>>>            If (num_arguments < 2) Begin
12229>>>>>                Move SQL_TYPE_TIMESTAMP to iType
12230>>>>>            End
12230>>>>>>
12230>>>>>            Else Begin
12231>>>>>                Move iSQLType to iType
12232>>>>>            End
12232>>>>>>
12232>>>>>            
12232>>>>>            
12232>>>>>            Get psDriverID to sDriverId
12233>>>>>            Get psDummyZeroDate to sDummyZeroDate
12234>>>>>            
12234>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
12236>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12237>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
12238>>>>>            End
12238>>>>>>
12238>>>>>            Else Begin
12239>>>>>                Move sDummyZeroDate to sSQLDate
12240>>>>>            End
12240>>>>>>
12240>>>>>            
12240>>>>>        End
12240>>>>>>
12240>>>>>        Else Begin
12241>>>>>            Move dDFDate to sSQLDate
12242>>>>>        End
12242>>>>>>
12242>>>>>        
12242>>>>>        // Change date format back to original
12242>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
12245>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12248>>>>>        
12248>>>>>        Function_Return sSQLDate
12249>>>>>    End_Function
12250>>>>>    
12250>>>>>    
12250>>>>>    // Convert a SQL date to a DataFlex Date. Use dummy zero dates.
12250>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
12252>>>>>        
12252>>>>>        Integer iType
12252>>>>>        Date    dDFDate
12252>>>>>        Integer iOrgDateFmt
12252>>>>>        Integer iOrgDateSep
12252>>>>>        
12252>>>>>        String  sDriverId
12252>>>>>        String  sDummyZeroDate
12252>>>>>        String  sDummyZeroDateMssqlDatetime
12252>>>>>        
12252>>>>>        Get psDriverID to sDriverId
12253>>>>>        
12253>>>>>        Get psDummyZeroDate to sDummyZeroDate
12254>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12255>>>>>        
12255>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
12258>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12261>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
12264>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
12267>>>>>        
12267>>>>>        Move (Left(sSQLDate,10)) to sSQLDate
12268>>>>>        
12268>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;            ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
12270>>>>>            Move 0 to dDFDate
12271>>>>>        End
12271>>>>>>
12271>>>>>        Else Begin
12272>>>>>            Move sSQLDate to dDFDate
12273>>>>>        End
12273>>>>>>
12273>>>>>        
12273>>>>>        // Change date format back to original
12273>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
12276>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
12279>>>>>        
12279>>>>>        Function_Return dDFDate
12280>>>>>    End_Function
12281>>>>>    
12281>>>>>End_Class
12282>>>>>
12282>>>>>
12282>>>>>// Connection object for embedded SQL                          
12282>>>>>// This provides the ability to create a connection for a driver.     
12282>>>>>// It will contain child statement objects                            
12282>>>>>
12282>>>>>Class cSQLConnection is a cObject
12283>>>>>    
12283>>>>>    Procedure Construct_object
12285>>>>>        Forward Send Construct_object
12287>>>>>        
12287>>>>>        Property Integer phCLIConnectionHandle       0
12288>>>>>        
12288>>>>>        Property String  psDriverID        ""
12289>>>>>        Property Integer piBindFile        0
12290>>>>>        
12290>>>>>        Property String psDummyZeroDate              '0001-01-01'
12291>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
12292>>>>>        
12292>>>>>    End_Procedure
12293>>>>>    
12293>>>>>    
12293>>>>>    
12293>>>>>    // Store basic information about the connection
12293>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId
12295>>>>>        
12295>>>>>        String sDummyZeroDate
12295>>>>>        Integer iDriverIndex
12295>>>>>        
12295>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
12296>>>>>        Set psDriverID            to sDrvrId
12297>>>>>        
12297>>>>>        Case Begin
12297>>>>>            Case (sDrvrId = "MSSQLDRV")
12299>>>>>                Set psDummyZeroDate to '0001-01-01'
12300>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
12301>>>>>                Break
12302>>>>>            Case (sDrvrId = "DB2_DRV")
12305>>>>>                Set psDummyZeroDate to '0001-01-01'
12306>>>>>                Break
12307>>>>>            Case (sDrvrId = "ODBC_DRV")
12310>>>>>                Get DriverIndex "ODBC_DRV" to iDriverIndex
12311>>>>>                If (iDriverIndex <> 0) Begin
12313>>>>>                    Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyZeroDate
12316>>>>>                End
12316>>>>>>
12316>>>>>                Else Begin
12317>>>>>                    Move '0001-01-01' to sDummyZeroDate
12318>>>>>                End
12318>>>>>>
12318>>>>>
12318>>>>>                Set psDummyZeroDate to sDummyZeroDate
12319>>>>>                Break
12320>>>>>                
12320>>>>>        Case End
12320>>>>>        
12320>>>>>    End_Procedure
12321>>>>>    
12321>>>>>    Function DriverIndex String sDriver Returns Integer
12323>>>>>        
12323>>>>>        String  sCurrentDriver
12323>>>>>        Integer iNumberOfDrivers iDriver iCount
12323>>>>>        
12323>>>>>        Move 0 to iDriver
12324>>>>>        
12324>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
12327>>>>>        For iCount from 1 to iNumberOfDrivers
12333>>>>>>
12333>>>>>            
12333>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
12336>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
12338>>>>>                Move iCount to iDriver
12339>>>>>            End
12339>>>>>>
12339>>>>>        Loop
12340>>>>>>
12340>>>>>        
12340>>>>>        Function_Return iDriver
12341>>>>>        
12341>>>>>    End_Function
12342>>>>>
12342>>>>>    
12342>>>>>    // Destroy the SQLConnection object
12342>>>>>    Procedure DestroySQLConnection
12344>>>>>        Send Destroy
12345>>>>>    End_Procedure
12346>>>>>    
12346>>>>>    
12346>>>>>    // Connect to a database server
12346>>>>>    // Returns : 1 Succesfully connected
12346>>>>>    //           0 Not connected
12346>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
12348>>>>>        Integer ihdbc
12348>>>>>        String  sEmpty
12348>>>>>        
12348>>>>>        // Initialize
12348>>>>>        Move "" to sEmpty
12349>>>>>        Move 0  to ihdbc
12350>>>>>        
12350>>>>>        Move False to Err
12351>>>>>        
12351>>>>>        // Call the driver function to connect
12351>>>>>        Call_Driver 0 sDrvrId Function FUNC_SQLCONNECT ;            Callback Self ;            Passing sConnect sEmpty Self ;            Result ihdbc
12356>>>>>        
12356>>>>>        // If there was an error, make result invalid
12356>>>>>        If (Err) ;            Move 0 to ihdbc
12359>>>>>        
12359>>>>>        // Check result and store it
12359>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
12362>>>>>        
12362>>>>>        // Return success status
12362>>>>>        Function_Return (ihdbc <> 0)
12363>>>>>    End_Function
12364>>>>>    
12364>>>>>    
12364>>>>>    // Use a connection of an already open file
12364>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
12366>>>>>        Integer ihdbc
12366>>>>>        Integer bIsOpen
12366>>>>>        String  sDrvrId
12366>>>>>        String  sEmpty
12366>>>>>        
12366>>>>>        // Initialize
12366>>>>>        Move "" to sEmpty
12367>>>>>        Move 0  to ihdbc
12368>>>>>        
12368>>>>>        // Check if file is open
12368>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
12371>>>>>        If (bIsOpen) Begin
12373>>>>>            // Fill the driver id, assume longest is 255 characters
12373>>>>>            Move (Repeat(' ', 255)) to sDrvrId
12374>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
12377>>>>>            
12377>>>>>            Move False to Err
12378>>>>>            
12378>>>>>            // Call the driver function to connect
12378>>>>>            Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result ihdbc
12383>>>>>            
12383>>>>>            // If there was an error, make result invalid
12383>>>>>            If (Err) ;                Move 0 to ihdbc
12386>>>>>            
12386>>>>>            // Check result and store it
12386>>>>>            If (ihdbc <> 0) Begin
12388>>>>>                // Somehow Call_driver overwrites the sDrvrId variable, restore it here
12388>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
12391>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
12392>>>>>                
12392>>>>>                // Set filenum so it can be used for fetching
12392>>>>>                Set piBindFile to iFileNum
12393>>>>>            End
12393>>>>>>
12393>>>>>        End
12393>>>>>>
12393>>>>>        
12393>>>>>        // Return success status
12393>>>>>        Function_Return (ihdbc <> 0)
12394>>>>>    End_Function
12395>>>>>    
12395>>>>>    
12395>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
12395>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
12395>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
12395>>>>>    // The connectstring must be an exact match, but can be case insensitive
12395>>>>>    // The connectstring can contain a connection id. For example: "DFCONNID=MyConnectionID"
12395>>>>>    // If no matching connectstring is found, this function will return 0
12395>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
12395>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
12397>>>>>        Integer ihdbc
12397>>>>>        String  sEmpty
12397>>>>>        Integer iFileNum
12397>>>>>        
12397>>>>>        // Initialize
12397>>>>>        Move "" to sEmpty
12398>>>>>        Move 0  to ihdbc
12399>>>>>        
12399>>>>>        Move False to Err
12400>>>>>        
12400>>>>>        // Call the driver function
12400>>>>>        //   Note we call FUNC_SQLFILECONNECT with iFileNum = 0.
12400>>>>>        //   This will perform SQLConnectionConnect instead of SQLFileConnect
12400>>>>>        Move 0 to iFileNum
12401>>>>>        Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;            Callback Self ;            Passing sConnectString sEmpty Self ;            Result ihdbc
12406>>>>>        
12406>>>>>        // If there was an error, make result invalid
12406>>>>>        If (Err) ;            Move 0 to ihdbc
12409>>>>>        
12409>>>>>        // Check result and store it
12409>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
12412>>>>>        
12412>>>>>        // Return success status
12412>>>>>        Function_Return (ihdbc <> 0)
12413>>>>>    End_Function
12414>>>>>    
12414>>>>>    
12414>>>>>    // Disconnect from an embedded SQL server and free allocated
12414>>>>>    // resources
12414>>>>>    Procedure SQLDisconnect
12416>>>>>        Integer ihdbc
12416>>>>>        Integer iVoid
12416>>>>>        String  sDrvrId
12416>>>>>        String  sEmpty
12416>>>>>        
12416>>>>>        // Initialize
12416>>>>>        Move "" to sEmpty
12417>>>>>        
12417>>>>>        // Get the cli handle
12417>>>>>        Get phCLIConnectionHandle to ihdbc
12418>>>>>        Get psDriverId to sDrvrId
12419>>>>>        
12419>>>>>        // Free the CLI handle
12419>>>>>        If (ihdbc <> 0) Begin
12421>>>>>            // Call the driver function to disconnect
12421>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                Callback Self ;                Passing sEmpty sEmpty ihdbc ;                Result iVoid
12426>>>>>            
12426>>>>>            Move -1 to giLastSQLhdbc
12427>>>>>            
12427>>>>>            // Free the DataFlex handle
12427>>>>>            Send DestroySQLConnection
12428>>>>>        End
12428>>>>>>
12428>>>>>    End_Procedure
12429>>>>>    
12429>>>>>    // Create a cSQLStatement object
12429>>>>>    Function CreateSQLStatement Returns Handle
12431>>>>>        
12431>>>>>        Handle hoSQLStatement
12431>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
12432>>>>>        
12432>>>>>        // If the connection has a default Bind File, assign it to the
12432>>>>>        // statement object. The default is set when you open a file with a
12432>>>>>        // SetFileConnection command.
12432>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
12433>>>>>        
12433>>>>>        Function_Return hoSQLStatement
12434>>>>>    End_Function
12435>>>>>    
12435>>>>>    
12435>>>>>    // Open a statement for use
12435>>>>>    Function SQLOpen Returns Handle
12437>>>>>        Handle  hoSQLStatement
12437>>>>>        Integer ihdbc
12437>>>>>        Integer ihstmt
12437>>>>>        Integer iVoid
12437>>>>>        String  sDrvrId
12437>>>>>        String  sEmpty
12437>>>>>        String  sDummyZeroDate
12437>>>>>        String  sDummyZeroDateMssqlDatetime
12437>>>>>        
12437>>>>>        // Initialize
12437>>>>>        Move "" to sEmpty
12438>>>>>        
12438>>>>>        // Get the cli handle to the connection
12438>>>>>        Get phCLIConnectionHandle to ihdbc
12439>>>>>        Get psDriverId  to sDrvrId
12440>>>>>        
12440>>>>>        // Allocate a new handle and populate it
12440>>>>>        If (ihdbc <> 0) Begin
12442>>>>>            // Create a new cSQLStatement object
12442>>>>>            Get CreateSQLStatement to hoSQLStatement
12443>>>>>            
12443>>>>>            // Call the driver function to allocate a cli statement handle
12443>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLOPEN ;                Callback Self ;                Passing hoSQLStatement sEmpty ihdbc ;                Result ihstmt
12448>>>>>            
12448>>>>>            // If unsuccessful destroy hoSQLStatement
12448>>>>>            If (ihstmt = 0) Begin
12450>>>>>                Send DestroySQLStatement of hoSQLStatement
12451>>>>>                Move 0 to hoSQLStatement
12452>>>>>            End
12452>>>>>>
12452>>>>>            Else Begin
12453>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
12454>>>>>                
12454>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
12454>>>>>                Get psDummyZeroDate              to sDummyZeroDate
12455>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
12456>>>>>                
12456>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
12457>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
12458>>>>>                
12458>>>>>            End
12458>>>>>>
12458>>>>>        End
12458>>>>>>
12458>>>>>        
12458>>>>>        Function_Return hoSQLStatement
12459>>>>>    End_Function
12460>>>>>    
12460>>>>>End_Class
12461>>>>>
12461>>>>>// Manager for embedded SQL handles.                           
12461>>>>>// We want to be able to use multiple drivers and multiple            
12461>>>>>// connections within a driver and multiple statements within a       
12461>>>>>// connection. To allow this we have placed our own handle logic on   
12461>>>>>// top of the driver handle logic. This way we can handle the         
12461>>>>>// situation where two driver handles may be equal.                   
12461>>>>>
12461>>>>>Class cSQLHandleManager is a cObject
12462>>>>>    
12462>>>>>    Procedure Construct_object
12464>>>>>        Forward Send Construct_object
12466>>>>>        
12466>>>>>        Property String  psDefaultDriver      ""
12467>>>>>        Property String  psDefaultConnection  ""
12468>>>>>        
12468>>>>>    End_Procedure
12469>>>>>    
12469>>>>>    // Create a cSQLConnection object
12469>>>>>    Function CreateSQLConnection Returns Handle
12471>>>>>        Handle hoSQLConnection
12471>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
12472>>>>>        Function_Return hoSQLConnection
12473>>>>>    End_Function
12474>>>>>    
12474>>>>>    
12474>>>>>    // Store default connection information
12474>>>>>    Procedure SQLSetConnect String sDriver String sConnect
12476>>>>>        Set psDefaultDriver      to sDriver
12477>>>>>        Set psDefaultConnection  to sConnect
12478>>>>>    End_Procedure
12479>>>>>    
12479>>>>>    
12479>>>>>    // Make a connection to an embedded SQL server
12479>>>>>    // Returns : The DataFlex handle to the connection
12479>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
12481>>>>>        Handle hoSQLConnection
12481>>>>>        Integer bOK
12481>>>>>        
12481>>>>>        // Check arguments
12481>>>>>        If (sDrvrID = "" and sConnect = "") Begin
12483>>>>>            Get psDefaultDriver      to sDrvrId
12484>>>>>            Get psDefaultConnection  to sConnect
12485>>>>>        End
12485>>>>>>
12485>>>>>        
12485>>>>>        // Create a cSQLConnection object
12485>>>>>        Get CreateSQLConnection to hoSQLConnection
12486>>>>>        // Connect to the database
12486>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
12487>>>>>        
12487>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12487>>>>>        If (not(bOK)) Begin
12489>>>>>            Send DestroySQLConnection of hoSQLConnection
12490>>>>>            Move 0 to hoSQLConnection
12491>>>>>        End
12491>>>>>>
12491>>>>>        
12491>>>>>        Function_Return hoSQLConnection
12492>>>>>    End_Function
12493>>>>>    
12493>>>>>    
12493>>>>>    
12493>>>>>    // Make an existing connection available for use with Embedded SQL.
12493>>>>>    // The connection is identified by the number of a file
12493>>>>>    // that is open for that connection.
12493>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
12495>>>>>        Handle hoSQLConnection
12495>>>>>        Integer bOK
12495>>>>>        
12495>>>>>        // Create a cSQLConnection object
12495>>>>>        Get CreateSQLConnection to hoSQLConnection
12496>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum to bOK
12497>>>>>        
12497>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12497>>>>>        If (not(bOK)) Begin
12499>>>>>            Send DestroySQLConnection of hoSQLConnection
12500>>>>>            Move 0 to hoSQLConnection
12501>>>>>        End
12501>>>>>>
12501>>>>>        
12501>>>>>        Function_Return hoSQLConnection
12502>>>>>    End_Function
12503>>>>>    
12503>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
12503>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
12503>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
12503>>>>>    // The connectstrings must be an exact match, but can be case insensitive
12503>>>>>    // If no matching connectstring is found, this function will return 0
12503>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
12503>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
12505>>>>>        Handle hoSQLConnection
12505>>>>>        Integer bOK
12505>>>>>        
12505>>>>>        // Check arguments
12505>>>>>        If (sDrvrID = "" and sConnectString = "") Begin
12507>>>>>            Get psDefaultDriver      to sDrvrId
12508>>>>>            Get psDefaultConnection  to sConnectString
12509>>>>>        End
12509>>>>>>
12509>>>>>        
12509>>>>>        // Create a cSQLConnection object
12509>>>>>        Get CreateSQLConnection to hoSQLConnection
12510>>>>>        // Connect to the database
12510>>>>>        Get SQLConnectionConnect of hoSQLConnection sDrvrID sConnectString to bOK
12511>>>>>        
12511>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
12511>>>>>        If (not(bOK)) Begin
12513>>>>>            Send DestroySQLConnection of hoSQLConnection
12514>>>>>            Move 0 to hoSQLConnection
12515>>>>>        End
12515>>>>>>
12515>>>>>        
12515>>>>>        Function_Return hoSQLConnection
12516>>>>>    End_Function
12517>>>>>    
12517>>>>>    
12517>>>>>End_Class
12518>>>Use cApplication.pkg
12518>>>
12518>>>// constants
12518>>>Define C_ConnectionId for "DFCONNID=" // symbol used in INT/SERVER for connection Id
12518>>>Define C_ConnectionIdCmdLineName for "dfconnid=" // left side of name used in command line argument for dfconnid.ini file
12518>>>Define C_ConnectionIniFileName for "DFConnId.ini" // default name of connections INI file.
12518>>>Define C_ConnectionIniSectionBaseName for "connection" // normally assumes a suffix like connection1, conneciton 2, etc.
12518>>>Define C_ConnectionIniSectionId for "id" // Name of connection id
12518>>>Define C_ConnectionIniSectionDriver for "driver" // left side of [id] section for driver
12518>>>Define C_ConnectionIniSectionConnection for "connection" // left side of [id] section for connection
12518>>>Define C_ConnectionIniSectionUID for "UID"
12518>>>Define C_ConnectionIniSectionPWD for "PWD"
12518>>>Define C_ConnectionIniSectionTrusted for "trusted_connection"
12518>>>Define C_ConnectionIniSectionDisabled for "disabled"
12518>>>
12518>>>// connection ID information
12518>>>Struct tConnection
12518>>>    String sId                // connection id
12518>>>    String sString            // server-string as added via the ini file
12518>>>    String sUID               // User Id
12518>>>    String sPWD               // non-encrypted password
12518>>>    Boolean bTrustedConnection // Trusted connection
12518>>>    Integer iOptions          // connection ID options (don't use)
12518>>>    String sDriver            // name of driver
12518>>>    Integer iDriverIndex      // loaded driver index (is 1 based, 0 if none)
12518>>>    String sConnectionString  // Full connection string assembled from various strings
12518>>>    String sSection           // this is usually the section name as it appears
12518>>>    // in the connections ini file (e.g., [Connection1])
12518>>>    Boolean bDisabled         // if set, this is not an active Id
12518>>>End_Struct
12518>>>
12518>>>// used to search loaded (registered) drivers to find CLI connection handle
12518>>>Struct tDriverCLIDictionary
12518>>>    String sDriver // registered driver name
12518>>>    Handle hoCLI   // CLI handle of object created when driver was loaded
12518>>>End_Struct
12518>>>
12518>>>// privately used to write INI sections
12518>>>Struct tConnectionIniSection
12518>>>    String sSection // section INI name. Should be unique
12518>>>    String[] Keys
12518>>>    String[] Values
12518>>>End_Struct
12518>>>
12518>>>// search tConnection by case insensitive ID
12518>>>Function ComparetConnectionById Desktop tConnection C1 tConnection C2 Returns Integer
12520>>>    String sId1 sId2
12520>>>    Move (Uppercase(C1.sId)) to sId1
12521>>>    Move (Uppercase(C2.sId)) to sId2
12522>>>    If (sId1>sId2) Begin
12524>>>        Function_Return (GT)
12525>>>    End
12525>>>>
12525>>>    Else If (sId1<sId2) Begin
12528>>>        Function_Return (LT)
12529>>>    End
12529>>>>
12529>>>    Function_Return (EQ)
12530>>>End_Function
12531>>>
12531>>>Class cConnection is a cObject
12532>>>    
12532>>>    Procedure Construct_Object
12534>>>        Forward Send Construct_Object
12536>>>        
12536>>>        // If you want to do this all manually set this False
12536>>>        Property Boolean pbUseConnectionIni True
12537>>>        
12537>>>        // When using managed logins, login again if already logged in?
12537>>>        Property Boolean pbSkipDuplicateLogin True
12538>>>        
12538>>>        // can be set to false, to require a login before an open. This gets
12538>>>        // set when the driver is registered.
12538>>>        Property Boolean private_pbLoginOnOpen True
12539>>>        
12539>>>        // name of connections ini file. Only set this if you want to override
12539>>>        // the normal mechanism of getting a name.
12539>>>        Property String psConnectionIni ""
12540>>>        
12540>>>        // as a scurity precaution this can be disabled so someone cannot run a
12540>>>        // cmdline option that redirects to a different database
12540>>>        Property Boolean pbCmdLineIniAllowed True
12541>>>        
12541>>>        // normally this is dfconnid="name" but it can be customized in the case where
12541>>>        // an application would have a conflict with this.
12541>>>        Property String psConnectionIdCmdLine C_ConnectionIdCmdLineName
12542>>>        
12542>>>        // Determines AutoConnect behavior (usually sent by cApplication after workspace
12542>>>        // is opened. Default is to RegisterAll and LoginAll and abort if error). If set
12542>>>        // false, nothing happens.
12542>>>        Property Boolean pbAutoConnect True
12543>>>        
12543>>>        // is a login dialog used? If so, it must be created and registered in ghoLoginConnectDialog
12543>>>        Property Boolean pbLoginDialogRequired True
12544>>>        
12544>>>        // is encryption used? If so, it must be created and registered in ghoLoginEncryption
12544>>>        Property Boolean pbEncryptPassword True
12545>>>        
12545>>>        // class to use for driver connection objects. Advanced use for sub-classing
12545>>>        Property Handle phcDriverConnection (RefClass(cCLIHandler))
12546>>>        
12546>>>        // can be used by error trapping / handling
12546>>>        Property Integer piErrorNumber
12547>>>        Property Integer piErrorLine
12548>>>        Property String psErrorText
12549>>>        Property Handle phoOldError
12550>>>        
12550>>>        Property tDriverCLIDictionary[] pRegisteredDriversDict
12551>>>        
12551>>>        Property tConnection[] pConnections
12552>>>
12552>>>        // Application name that is passed in the connectionstring (APP=)
12552>>>        // If empty, will be set to the program name
12552>>>        Property String psConnectionAppName ""
12553>>>        
12553>>>        Move Self to ghoConnection
12554>>>        
12554>>>    End_Procedure
12555>>>    
12555>>>    // error trapping for this object
12555>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
12557>>>        Set piErrorLine to iErrorLine
12558>>>        Set piErrorNumber to iErrorNumber
12559>>>        Set psErrorText to sErrorText
12560>>>    End_Procedure
12561>>>    
12561>>>    Procedure TrapErrors
12563>>>        If (Error_Object_Id = Self) Begin
12565>>>            Error DFERR_PROGRAM "ASSERT: cConnection: TrapErrors called twice!"
12566>>>>
12566>>>            Procedure_Return
12567>>>        End
12567>>>>
12567>>>        Set phoOldError to Error_Object_Id
12568>>>        Set piErrorNumber to 0
12569>>>        Move Self to Error_Object_Id
12570>>>    End_Procedure
12571>>>    
12571>>>    Procedure UnTrapErrors
12573>>>        Get phoOldError to Error_Object_Id
12574>>>    End_Procedure
12575>>>    
12575>>>    // Report a connections configuration error as a handled user error.
12575>>>    Procedure ConfigurationError Integer iError String sError
12577>>>        Send UserError sError C_$DriverConfigurationError
12578>>>    End_Procedure
12579>>>    
12579>>>    // Setting this property will change this new and all existing managed drivers
12579>>>    Procedure Set pbLoginOnOpen Boolean bLoginOnOpen
12581>>>        tDriverCLIDictionary[] DriverMap
12581>>>        tDriverCLIDictionary[] DriverMap
12582>>>        Integer i iDriver
12582>>>        Set private_pbLoginOnOpen to bLoginOnOpen
12583>>>        
12583>>>        // set any existing registered drivers
12583>>>        Get pRegisteredDriversDict to DriverMap
12584>>>        For i from 0 to (SizeOfArray(DriverMap)-1)
12590>>>>
12590>>>            Get DriverIndex DriverMap[i].sDriver to iDriver
12591>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to bLoginOnOpen
12594>>>        Loop
12595>>>>
12595>>>        
12595>>>    End_Procedure
12596>>>    
12596>>>    Function pbLoginOnOpen Returns Boolean
12598>>>        Boolean bLogin
12598>>>        Get private_pbLoginOnOpen to bLogin
12599>>>        Function_Return bLogin
12600>>>    End_Function
12601>>>    
12601>>>    
12601>>>    // returns the Index from list of loaded drivers for sDriver. 0 if not found
12601>>>    // This searches all loaded drivers which may include drivers that were
12601>>>    // not registered.
12601>>>    Function DriverIndex String sDriver Returns Integer
12603>>>        Integer iDrivers i
12603>>>        String sADriver
12603>>>        Move (Uppercase(sDriver)) to sDriver
12604>>>        Get_Attribute DF_NUMBER_DRIVERS to iDrivers
12607>>>        For i from 1 to iDrivers
12613>>>>
12613>>>            Get_Attribute DF_DRIVER_NAME of i to sADriver
12616>>>            If (sDriver=Uppercase(sADriver)) Begin
12618>>>                Function_Return i
12619>>>            End
12619>>>>
12619>>>        Loop
12620>>>>
12620>>>        Function_Return 0
12621>>>    End_Function
12622>>>    
12622>>>    // returns cConnectionCLIHandler object for this driver id.
12622>>>    // This must be a registered managed driver. If not found return 0
12622>>>    // This can be used to test if a driver is registered (and therefore loaded)
12622>>>    Function DriverCLIHandler String sDriver Returns Handle
12624>>>        Integer iIndex
12624>>>        tDriverCLIDictionary[] DriverMap
12624>>>        tDriverCLIDictionary[] DriverMap
12625>>>        tDriverCLIDictionary DriverItem
12625>>>        tDriverCLIDictionary DriverItem
12625>>>        Move (Trim(Uppercase(sDriver))) to sDriver
12626>>>        Move sDriver to DriverItem.sDriver
12627>>>        Get pRegisteredDriversDict to DriverMap
12628>>>        Move (SearchArray(DriverItem,DriverMap)) to iIndex
12629>>>        If (iIndex<>-1) Begin
12631>>>            Function_Return DriverMap[iIndex].hoCLI
12632>>>        End
12632>>>>
12632>>>        Function_Return 0
12633>>>    End_Function
12634>>>    
12634>>>    // low level load which does not register the driver - only loads
12634>>>    Function LoadDriver String sDriver Returns Boolean
12636>>>        Integer iErrorNumber
12636>>>        Send TrapErrors
12637>>>        Load_Driver sDriver
12638>>>        Send UnTrapErrors
12639>>>        Get piErrorNumber to iErrorNumber
12640>>>        Function_Return (iErrorNumber=0)
12641>>>    End_Function
12642>>>    
12642>>>    Function TestDriverConformance String sDriver Integer iDriver Handle hoCLI Returns Boolean
12644>>>        Integer iConformance
12644>>>        Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
12647>>>        If (not(iConformance iand 8)) Begin // bit 4 is managed driver conformance
12649>>>            Send ConfigurationError DFERR_SETUP (SFormat(C_$DriverIsNotManaged,sDriver))
12650>>>            Function_Return False
12651>>>        End
12651>>>>
12651>>>        Function_Return True
12652>>>    End_Function
12653>>>    
12653>>>    // Register this driver. Load driver if not yet loaded
12653>>>    // return cConnectionCLIHandler handle for this driver
12653>>>    // If registered, just return the handle
12653>>>    // return 0 if driver cannot be loaded
12653>>>    // If newly registered here, sends OnDriverRegistered event
12653>>>    // raise error if driver cannot be loaded or does not conform
12653>>>    Function RegisterDriver String sDriver Returns Handle
12655>>>        Integer iIndex iDriver iConformance
12655>>>        Handle hoCLI hClass
12655>>>        Boolean bOk
12655>>>        Boolean bAutoLogin
12655>>>        tDriverCLIDictionary[] DriverMap
12655>>>        tDriverCLIDictionary[] DriverMap
12656>>>        Integer iIds iRet
12656>>>        String sId
12656>>>        Get DriverCLIHandler sDriver to hoCLI
12657>>>        If (hoCLI=0) Begin // driver not registered yet
12659>>>            Get pRegisteredDriversDict to DriverMap
12660>>>            Get phcDriverConnection to hClass
12661>>>            Get CreateNamed hClass ("oCLI_"+sDriver) to hoCLI
12662>>>            Move (SizeOfArray(DriverMap)) to iIndex
12663>>>            Move (Trim(Uppercase(sDriver)))  to DriverMap[iIndex].sDriver
12664>>>            Move hoCLI to DriverMap[iIndex].hoCLI
12665>>>            Set pRegisteredDriversDict to DriverMap
12666>>>            Set psDriverID of hoCLI to DriverMap[iIndex].sDriver
12667>>>            
12667>>>            Get DriverIndex DriverMap[iIndex].sDriver to iDriver
12668>>>            Move (iDriver>0) to bOk // is driver already loaded (just not registered)
12669>>>            If not bOk Begin
12671>>>                Get LoadDriver DriverMap[iIndex].sDriver to bOk
12672>>>                If bOk Begin
12674>>>                    Get DriverIndex DriverMap[iIndex].sDriver to iDriver
12675>>>                End
12675>>>>
12675>>>                Else Begin
12676>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$DriverNotFound,sDriver))
12677>>>                End
12677>>>>
12677>>>            End
12677>>>>
12677>>>            
12677>>>            // finally make sure loaded driver supports managed connections and any other
12677>>>            // tests that might be applied by the developer
12677>>>            If bOk Begin
12679>>>                Get TestDriverConformance sDriver iDriver hoCLI to bOk
12680>>>            End
12680>>>>
12680>>>            
12680>>>            If not bOk Begin
12682>>>                Send Destroy of hoCLI
12683>>>                Move 0 to hoCLI
12684>>>                Move (RemoveFromArray(DriverMap,iIndex)) to DriverMap
12685>>>                Set pRegisteredDriversDict to DriverMap
12686>>>            End
12686>>>>
12686>>>            Else Begin
12687>>>                // driver is loaded and valid, complete registration
12687>>>                
12687>>>                // Is auto-login on open supported?
12687>>>                Get pbLoginOnOpen to bAutoLogin
12688>>>                Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to bAutoLogin
12691>>>                
12691>>>                // remove existing connection IDs as defined in the driver.int file. If you are
12691>>>                // using registered connections, you are using registered drivers!
12691>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iIds
12694>>>                While (iIds>0)
12698>>>                    Decrement iIds
12699>>>                    Get DeleteConnectionID of hoCLI "" iIds to iRet
12700>>>                Loop
12701>>>>
12701>>>                
12701>>>                Send OnDriverRegistered sDriver iDriver hoCLI
12702>>>            End
12702>>>>
12702>>>        End
12702>>>>
12702>>>        Function_Return hoCLI
12703>>>    End_Function
12704>>>    
12704>>>    
12704>>>    
12704>>>    // returns a string array of loaded drivers (managed and unmanaged)
12704>>>    Function LoadedDrivers Returns String[]
12706>>>        Integer iDrivers i
12706>>>        String[] ArrayOfDrivers
12707>>>        Get_Attribute DF_NUMBER_DRIVERS to iDrivers
12710>>>        For i from 1 to iDrivers
12716>>>>
12716>>>            Get_Attribute DF_DRIVER_NAME of i to ArrayOfDrivers[i-1]
12719>>>        Loop
12720>>>>
12720>>>        Function_Return ArrayOfDrivers
12721>>>    End_Function
12722>>>    
12722>>>    // List of all Server connection-strings logged into this driver.
12722>>>    // This includes managed/registered strings and strings used in non-managed ways (e.g., in int file)
12722>>>    Function DriverServerNames String sDriver Returns String[]
12724>>>        Integer iConnections i iDriver
12724>>>        String[] Connections
12725>>>        Get DriverIndex sDriver to iDriver
12726>>>        If (iDriver>0) Begin
12728>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iConnections
12731>>>            For i from 0 to (iConnections-1)
12737>>>>
12737>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver (i+1) to Connections[i]
12740>>>            Loop
12741>>>>
12741>>>        End
12741>>>>
12741>>>        Function_Return Connections
12742>>>    End_Function
12743>>>    
12743>>>    // this does a low level login, which basically wraps the login command with some error handling
12743>>>    // and the ability to make a login silent.
12743>>>    // This is essentially a Login command surrounded by error checking and trapping
12743>>>    Function BasicLogin String sDriver String sServer String sName String sPassword Returns Integer
12745>>>        Integer iError iIndex
12745>>>        Handle hoConnect
12745>>>        Get DriverIndex sDriver to iIndex
12746>>>        If (iIndex>0) Begin
12748>>>            Send TrapErrors
12749>>>            Login sServer sName sPassword sDriver
12751>>>            Send UnTrapErrors
12752>>>            Get piErrorNumber to iError
12753>>>        End
12753>>>>
12753>>>        Else Begin
12754>>>            Move DFERR_PROGRAM to iError
12755>>>            Error iError (SFormat(C_$DriverNotFound,  sDriver))
12756>>>>
12756>>>        End
12756>>>>
12756>>>        Function_Return iError
12757>>>    End_Function
12758>>>    
12758>>>    
12758>>>    // get array of managed connections across all drivers
12758>>>    // returns array of connections in tConnection.
12758>>>    Function ConnectionIDs Returns tConnection[]
12760>>>        tConnection[] Connections
12760>>>        tConnection[] Connections
12761>>>        Get pConnections to Connections
12762>>>        Function_Return Connections
12763>>>    End_Function
12764>>>    
12764>>>    // return index of Id from pConnections array. -1 if missing
12764>>>    Function ConnectionIdIndex String sId Returns Integer
12766>>>        tConnection[] Connections
12766>>>        tConnection[] Connections
12767>>>        tConnection Connection
12767>>>        tConnection Connection
12767>>>        Integer iIndex
12767>>>        Move (trim(sId)) to Connection.sId
12768>>>        Get pConnections to Connections
12769>>>        Move (SearchArray(Connection,Connections,Desktop,RefFunc(ComparetConnectionById))) to iIndex
12770>>>        Function_Return iIndex
12771>>>    End_Function
12772>>>    
12772>>>    // return handle of cConnectionCLIHandler object for this id. 0 if none
12772>>>    Function ConnectionIdCLIHandler String sId Returns Handle
12774>>>        tConnection[] Ids
12774>>>        tConnection[] Ids
12775>>>        Integer iIndex
12775>>>        Handle hoCLI
12775>>>        Get ConnectionIds to Ids
12776>>>        Get ConnectionIdIndex sId to iIndex
12777>>>        If (iIndex<>-1) Begin
12779>>>            Get DriverCLIHandler Ids[iIndex].sDriver to hoCLI
12780>>>            Function_Return hoCLI
12781>>>        End
12781>>>>
12781>>>        Function_Return 0
12782>>>    End_Function
12783>>>    
12783>>>    // return connection info for this id. Programming error if Id does not exist
12783>>>    Function ConnectionIdInfo String sId Returns tConnection
12785>>>        tConnection[] ConnIDs
12785>>>        tConnection[] ConnIDs
12786>>>        tConnection ConnId
12786>>>        tConnection ConnId
12786>>>        Integer iIndex i
12786>>>        Handle hoCLI
12786>>>        Get ConnectionIdCLIHandler sId to hoCLI
12787>>>        If (hoCLI) Begin
12789>>>            Get ConnectionIdIndex sId to iIndex
12790>>>            Get ConnectionIDs to ConnIDs
12791>>>            Move ConnIDs[iIndex] to ConnId
12792>>>        End
12792>>>>
12792>>>        Else Begin
12793>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
12794>>>>
12794>>>        End
12794>>>>
12794>>>        Function_Return ConnId
12795>>>    End_Function
12796>>>    
12796>>>    
12796>>>    // add or upate connection to pConnections. Do not call directly
12796>>>    Function AddToConnections tConnection Connection Returns Integer
12798>>>        tConnection[] Connections
12798>>>        tConnection[] Connections
12799>>>        Integer iIndex
12799>>>        Get pConnections to Connections
12800>>>        Get ConnectionIdIndex Connection.sId to iIndex
12801>>>        If (iIndex=-1) Begin
12803>>>            Move (SizeOfArray(Connections)) to iIndex
12804>>>        End
12804>>>>
12804>>>        Move Connection to Connections[iIndex]
12805>>>        Set pConnections to Connections
12806>>>        Function_Return iIndex
12807>>>    End_Function
12808>>>    
12808>>>    // Remove connection ID from pConnection. Don't call directly
12808>>>    Function RemoveFromConnections String sId Returns Boolean
12810>>>        tConnection[] Connections
12810>>>        tConnection[] Connections
12811>>>        Integer iIndex
12811>>>        Get pConnections to Connections
12812>>>        Get ConnectionIdIndex sId to iIndex
12813>>>        If (iIndex<>-1) Begin
12815>>>            Move (RemoveFromArray(Connections,iIndex)) to Connections
12816>>>            Set pConnections to Connections
12817>>>        End
12817>>>>
12817>>>        Function_Return (iIndex<>-1)
12818>>>    End_Function
12819>>>    
12819>>>    // Return the connection ID syntax used for IDs in the INT file (e.g., DFCONNID=ID1)
12819>>>    // helper so you don't have to remember this syntax. Does not verify Id
12819>>>    Function ConnectionIDServerString String sId Returns String
12821>>>        Function_Return (C_ConnectionId - sId)
12822>>>    End_Function
12823>>>    
12823>>>    // Returns Connection.Ini file name if passed from the command line.
12823>>>    // requires cApplication object
12823>>>    // It's looking for something like dfconnid=myconnid.ini
12823>>>    Function ConnectionIniFromCmdLine Returns String
12825>>>        Handle hoCmdLine
12825>>>        Integer iCount iArg iPos
12825>>>        String sArg sFile sLeft
12825>>>        Get psConnectionIdCmdLine to sLeft
12826>>>        Get phoCommandLine of ghoApplication to hoCmdLine
12827>>>        Get CountOfArgs of hoCmdLine to iCount
12828>>>        For iArg from 1 to iCount
12834>>>>
12834>>>            Get Argument of hoCmdLine iArg to sArg
12835>>>            If (Pos(Lowercase(sLeft),Trim(Lowercase(sArg)))=1) Begin
12837>>>                Move (Trim(Remove(sArg,1,Length(C_ConnectionIdCmdLineName)))) to sFile
12838>>>                Function_Return sFile
12839>>>            End
12839>>>>
12839>>>        Loop
12840>>>>
12840>>>        Function_Return ""
12841>>>    End_Function
12842>>>    
12842>>>    // get qualified version of connections INI file using the rules for
12842>>>    // acquring this name. This file may not exist.
12842>>>    Function ConnectionIniFile Returns String
12844>>>        String sConnections sPath sPName
12844>>>        Boolean bCmdLineIniAllowed
12844>>>        Handle hoWorkspace
12844>>>        
12844>>>        Get pbCmdLineIniAllowed to bCmdLineIniAllowed
12845>>>        Get phoWorkspace of ghoApplication to hoWorkspace
12846>>>        
12846>>>        // order of naming precedence
12846>>>        // 1. If defined directly via a set, use that name
12846>>>        // 2. If command line allowed and exists use that name
12846>>>        // 3. If workspace has a definition (from config.ws) use that name
12846>>>        // 4. Else the default of data\dfconnid.ini
12846>>>        
12846>>>        Get psConnectionIni to sConnections
12847>>>        If (sConnections="" and bCmdLineIniAllowed) Begin
12849>>>            Get ConnectionIniFromCmdLine to sConnections
12850>>>        End
12850>>>>
12850>>>        If (sConnections="") Begin
12852>>>            Get psConnectionIni of hoWorkspace to sConnections
12853>>>        End
12853>>>>
12853>>>        If (sConnections="") Begin
12855>>>            Move C_ConnectionIniFileName to sConnections
12856>>>        End
12856>>>>
12856>>>        Move (Trim(sConnections)) to sConnections
12857>>>        
12857>>>        If (sConnections<>"") Begin
12859>>>            // first data path
12859>>>            If (Pos("<datapath>\",Lowercase(sConnections))) Begin
12861>>>                Get psDataPath of hoWorkspace to sPath
12862>>>                Move "<datapath>\" to sPName
12863>>>            End
12863>>>>
12863>>>            // first programs path
12863>>>            Else If (Pos("<apppath>\",Lowercase(sConnections))) Begin
12866>>>                Get GetApplicationPath of hoWorkspace to sPath
12867>>>                Move "<apppath>\" to sPName
12868>>>            End
12868>>>>
12868>>>            // first workspace home path
12868>>>            Else If (Pos("<homepath>\",Lowercase(sConnections))) Begin
12871>>>                Get psHome of hoWorkspace to sPath
12872>>>                Move "<homepath>\" to sPName
12873>>>            End
12873>>>>
12873>>>            // if no special path, use first data path
12873>>>            Else If (not(IsFilenameQualified(sConnections))) Begin
12876>>>                Get psDataPath of hoWorkspace to sPath
12877>>>                Move '' to sPName
12878>>>            End
12878>>>>
12878>>>            
12878>>>            If (sPath<>"") Begin
12880>>>                Get PathAtIndex of hoWorkspace sPath 1 to sPath
12881>>>                If (sPName<>"") Begin
12883>>>                    Move (Replace(sPName, sConnections, (sPath + "\"))) to sConnections
12884>>>                End
12884>>>>
12884>>>                Else Begin
12885>>>                    Move (sPath + "\" + sConnections) to sConnections
12886>>>                End
12886>>>>
12886>>>            End
12886>>>>
12886>>>        End
12886>>>>
12886>>>        Function_Return sConnections
12887>>>    End_Function
12888>>>    
12888>>>    Procedure OnReadCredentials String sSection String sId Handle hoIni String ByRef sUID String ByRef sPWDEncrypted Boolean ByRef bTrusted
12890>>>        String sTrusted
12890>>>        If (hoIni) Begin
12892>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionUID "" to sUID
12893>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionPWD "" to sPWDEncrypted
12894>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionTrusted "" to sTrusted
12895>>>            Move (lowercase(sTrusted)="yes") to bTrusted
12896>>>        End
12896>>>>
12896>>>    End_Procedure
12897>>>    
12897>>>    Procedure OnWriteCredentials String sSection String sId Handle hoIni String sUID String sPWDEncrypted Boolean bTrusted
12899>>>        If hoIni Begin
12901>>>            If (not(bTrusted) and  sUID<>"") Begin
12903>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionUID sUID
12904>>>            End
12904>>>>
12904>>>            Else Begin
12905>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionUID
12906>>>            End
12906>>>>
12906>>>            
12906>>>            If (not(bTrusted) and sUID<>"" and sPWDEncrypted<>"") Begin
12908>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionPWD sPWDEncrypted
12909>>>            End
12909>>>>
12909>>>            Else Begin
12910>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionPWD
12911>>>            End
12911>>>>
12911>>>            
12911>>>            If (bTrusted) Begin
12913>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionTrusted "yes"
12914>>>            End
12914>>>>
12914>>>            Else Begin
12915>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionTrusted
12916>>>            End
12916>>>>
12916>>>        End
12916>>>>
12916>>>    End_Procedure
12917>>>    
12917>>>    // returns a list of connection Ids from the connections.ini file.
12917>>>    // Driver does not have to be loaded (if not loaded, hoCLI=0)
12917>>>    // If pbUseConnectionIni is False, this does Nothing
12917>>>    // and must be augmented to do anything useful
12917>>>    Function LoadStoredConnections tConnection[] ByRef Connects Returns Boolean
12919>>>        String sConnectPath sId sConnect sDriver sUID sPWD sSection sDisabled
12919>>>        String[] Sections
12920>>>        Handle hoWorkspace hoArray hoIniFile
12920>>>        Integer i iConns iIndex
12920>>>        Boolean bUseConnectionIni bOk bTrusted bDisabled
12920>>>        tConnection ConnNew
12920>>>        tConnection ConnNew
12920>>>        
12920>>>        Get pbUseConnectionIni to bUseConnectionIni
12921>>>        
12921>>>        If bUseConnectionIni Begin
12923>>>            
12923>>>            Get ConnectionIniFile of ghoConnection to sConnectPath
12924>>>            If (sConnectPath="" or not(DoesFileExist(sConnectPath))) Begin
12926>>>                Function_Return True // if file does not exist, that's ok - no connections
12927>>>            End
12927>>>>
12927>>>            
12927>>>            Get Create (RefClass(cIniFile)) to hoIniFile
12928>>>            Get Create (RefClass(Array)) to hoArray
12929>>>            Set psFilename of hoIniFile to sConnectPath
12930>>>            
12930>>>            Send ReadSections of hoIniFile hoArray
12931>>>            
12931>>>            // create an array of all Connection sections.
12931>>>            For i from 0 to (Item_Count(hoArray) -1)
12937>>>>
12937>>>                Get Value of hoArray i to sSection
12938>>>                Move (Trim(sSection)) to sSection
12939>>>                If (Pos(Uppercase(C_ConnectionIniSectionBaseName),Uppercase(sSection))=1) Begin
12941>>>                    // make sure id is not a duplicate
12941>>>                    Move sId to ConnNew.sId
12942>>>                    Move (SearchArray(sSection, Sections, Desktop,RefFunc(DFSTRICMP))) to iIndex
12943>>>                    If (iIndex<>-1) Begin
12945>>>                        Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniDupSection,sConnectPath,sSection))
12946>>>                        Function_Return False
12947>>>                    End
12947>>>>
12947>>>                    Move (trim(sSection)) to Sections[SizeOfArray(Sections)]
12948>>>                End
12948>>>>
12948>>>            Loop
12949>>>>
12949>>>            
12949>>>            For i from 0 to (SizeOfArray(Sections)-1)
12955>>>>
12955>>>                Move Sections[i] to sSection
12956>>>                
12956>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionId "" to sId
12957>>>                If (sId="") Begin
12959>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadId,sConnectPath,sSection))
12960>>>                    Function_Return False
12961>>>                End
12961>>>>
12961>>>                
12961>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionDriver "" to sDriver
12962>>>                If (sDriver="") Begin
12964>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadDriver,sConnectPath,sSection))
12965>>>                    Function_Return False
12966>>>                End
12966>>>>
12966>>>                
12966>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionConnection "" to sConnect
12967>>>                If (sConnect="") Begin
12969>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadConnection,sConnectPath,sSection))
12970>>>                    Function_Return False
12971>>>                End
12971>>>>
12971>>>                
12971>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionDisabled "" to sDisabled
12972>>>                Move (Lowercase(sDisabled)="yes") to bDisabled
12973>>>
12973>>>                Send OnReadCredentials sSection sId hoIniFile (&sUID) (&sPWD) (&bTrusted)
12974>>>                
12974>>>                If (sPWD<>"") Begin
12976>>>                    Get DecryptPassword sPWD to sPWD
12977>>>                End
12977>>>>
12977>>>                
12977>>>                Move sSection to Connects[iConns].sSection
12978>>>                Move sDriver to Connects[iConns].sDriver
12979>>>                Move sId to Connects[iConns].sId
12980>>>                Move sConnect to Connects[iConns].sString
12981>>>                Move bDisabled to Connects[iConns].bDisabled
12982>>>                Move sPWD to Connects[iConns].sPWD
12983>>>                Move bTrusted to Connects[iConns].bTrustedConnection
12984>>>                Move sUID to Connects[iConns].sUID
12985>>>                
12985>>>                Increment iConns
12986>>>            Loop
12987>>>>
12987>>>            Send Destroy of hoArray
12988>>>            Send Destroy of hoIniFile
12989>>>        End
12989>>>>
12989>>>        
12989>>>        Function_Return True
12990>>>    End_Function
12991>>>    
12991>>>    Function DecryptPassword String sPWD Returns String
12993>>>        Handle hoLoginEncrypt
12993>>>        Boolean bEncryptPassword
12993>>>        Get pbEncryptPassword to bEncryptPassword
12994>>>        If (bEncryptPassword) Begin
12996>>>            Move ghoLoginEncryption to hoLoginEncrypt
12997>>>            // if not registered an error will occur - programming error
12997>>>            Get DecryptPassword of hoLoginEncrypt sPWD to sPWD
12998>>>        End
12998>>>>
12998>>>        Function_Return sPWD
12999>>>    End_Function
13000>>>    
13000>>>    Function EncryptPassword String sPWD Returns String
13002>>>        Handle hoLoginEncrypt
13002>>>        Boolean bEncryptPassword
13002>>>        Get pbEncryptPassword to bEncryptPassword
13003>>>        If (bEncryptPassword) Begin
13005>>>            Move ghoLoginEncryption to hoLoginEncrypt
13006>>>            // if not registered an error will occur - programming error
13006>>>            Get EncryptPassword of hoLoginEncrypt sPWD to sPWD
13007>>>        End
13007>>>>
13007>>>        Function_Return sPWD
13008>>>    End_Function
13009>>>    
13009>>>    // Assemble connect string based on connect string, user id, password and trusted connection
13009>>>    // If connect string already contains user id, etc. it is still appended which is consistent
13009>>>    // with odbc connection strings. The last one wins.
13009>>>    // sConnect should contain the SERVER= or DSN= information.
13009>>>    Function AssembleConnectionString String sConnect String sUID String sPWD Boolean bTrusted Returns String
13011>>>        String sConnectString
13011>>>        String sConnectionAppName
13011>>>        
13011>>>        Move sConnect to sConnectString
13012>>>        If (bTrusted) Begin
13014>>>            Move (sConnectString+";trusted_connection=yes") to sConnectString
13015>>>        End
13015>>>>
13015>>>        Else Begin
13016>>>            If (sUID<>"") Begin
13018>>>                Move (sConnectString+";UID="+sUID) to sConnectString
13019>>>            End
13019>>>>
13019>>>            If (sPWD<>"") Begin
13021>>>                Move (sConnectString+";PWD="+sPWD) to sConnectString
13022>>>            End
13022>>>>
13022>>>        End
13022>>>>
13022>>>        
13022>>>        Function_Return sConnectString
13023>>>    End_Function
13024>>>
13024>>>    Procedure AddAppNameToConnectString String sDriver String ByRef sConnectString
13026>>>        
13026>>>        String sConnectionAppName
13026>>>        Integer iAPPpos iNameAppEnd
13026>>>        String sEndConnString
13026>>>        String  sAppKeyword
13026>>>        
13026>>>        If (Uppercase(sDriver) = "MSSQLDRV") Begin
13028>>>            Move "APP=" to sAppKeyword
13029>>>        End
13029>>>>
13029>>>        Else Begin
13030>>>            If (Uppercase(sDriver) = "DB2_DRV") Begin
13032>>>                Move "PROGRAMNAME=" to sAppKeyword
13033>>>            End
13033>>>>
13033>>>        End
13033>>>>
13033>>>        If (sAppKeyword <> "") Begin
13035>>>            // Add the application name. 
13035>>>            Get psConnectionAppName to sConnectionAppName
13036>>>            If (sConnectionAppName = "") Begin
13038>>>                If (ghoApplication <> 0) Begin
13040>>>                    Get GetApplicationName of ghoApplication to sConnectionAppName
13041>>>                End
13041>>>>
13041>>>            End
13041>>>>
13041>>>            If (sConnectionAppName <> "") Begin
13043>>>                // make sure there's no APP already in the string
13043>>>                Move (Pos(sAppKeyword, Uppercase(sConnectString))) to iAPPpos
13044>>>                If (iAPPpos = 0) Begin
13046>>>                    Move (sConnectString+(If(sConnectString<>"",";",""))+sAppKeyword+sConnectionAppName) to sConnectString  
13047>>>                End 
13047>>>>
13047>>>                Else Begin
13048>>>                    // update AppName in connection string
13048>>>                    Move "" to sEndConnString 
13049>>>                    Move (Pos(";", sConnectString, iAPPpos + (Length(sAppKeyword)))) to iNameAppEnd
13050>>>                    If (iNameAppEnd > 0) Begin
13052>>>                        Move (Right(sConnectString, (Length(sConnectString) - iNameAppEnd) + 1)) to sEndConnString
13053>>>                    End
13053>>>>
13053>>>                    Move ((Left(sConnectString, iAPPpos + (Length(sAppKeyword) - 1))+sConnectionAppName)+ sEndConnString) to sConnectString
13054>>>                End
13054>>>>
13054>>>                    
13054>>>            End
13054>>>>
13054>>>        End
13054>>>>
13054>>>    End_Procedure
13055>>>    
13055>>>    Function AddConnectionToDriverCLI Handle hoCLI tConnection Connection Returns Integer
13057>>>        Integer iResult iIndex
13057>>>        Get ConnectionIdIndex Connection.sId to iIndex
13058>>>        If (iIndex<>-1) Begin
13060>>>            Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIdAlreadyExists,Connection.sId))
13061>>>            Function_Return 1
13062>>>        End
13062>>>>
13062>>>        Get CreateConnectionID of hoCLI Connection.sId Connection.sConnectionString Connection.iOptions to iResult
13063>>>        If (iResult=0) Begin
13065>>>            Get AddToConnections Connection to iIndex
13066>>>        End
13066>>>>
13066>>>        Function_Return iResult
13067>>>    End_Function
13068>>>    
13068>>>    
13068>>>    // add a connection id for this driver.
13068>>>    // pass server string, user id, password and trusted connection info. The
13068>>>    // server string that gets added will combine all of these. The password
13068>>>    // may require decoding by calling decode password.
13068>>>    Function AddConnection String sDriver String sId String sString String sUID String sPWD Boolean bTrusted String sSection Returns Integer
13070>>>        Handle hoCLI
13070>>>        Integer iResult
13070>>>        tConnection Connection
13070>>>        tConnection Connection
13070>>>        String sConnectString
13070>>>        Get RegisterDriver sDriver to hoCLI
13071>>>        If (hoCLI=0) Begin
13073>>>            // will have raised an error
13073>>>            Function_Return False
13074>>>        End
13074>>>>
13074>>>        Get DriverIndex sDriver to Connection.iDriverIndex
13075>>>        Move sDriver to Connection.sDriver
13076>>>        Get AssembleConnectionString sString sUID sPWD bTrusted to sConnectString
13077>>>        Send AddAppNameToConnectString sDriver (&sConnectString)
13078>>>        
13078>>>        // assemble the connection struct variable.
13078>>>        Move (Trim(sSection)) to Connection.sSection
13079>>>        Move (Trim(sId)) to Connection.sId
13080>>>        Move sString to Connection.sString
13081>>>        Move sUID to Connection.sUID
13082>>>        Move sPWD to Connection.sPWD
13083>>>        Move bTrusted to Connection.bTrustedConnection
13084>>>        Move True to Connection.iOptions // login always silent.
13085>>>        Move sConnectString to Connection.sConnectionString
13086>>>        Send OnAddConnection (&Connection) // further customize connection
13087>>>        Get AddConnectionToDriverCLI hoCLI Connection to iResult
13088>>>        Function_Return (iResult=0)
13089>>>    End_Function
13090>>>    
13090>>>    // add connectionIds for all registered drivers
13090>>>    // if driver not loaded/registered, do so first
13090>>>    // If any error occurs, stop process and return false, else true
13090>>>    Function AddAllConnections Returns Boolean
13092>>>        tConnection[] Connects
13092>>>        tConnection[] Connects
13093>>>        Integer i iResult
13093>>>        Boolean bOk
13093>>>        Handle hoCLI
13093>>>        Get LoadStoredConnections (&Connects) to bOk
13094>>>        If not bOk Begin
13096>>>            Function_Return False
13097>>>        End
13097>>>>
13097>>>        
13097>>>        For i from 0 to (SizeOfArray(Connects)-1)
13103>>>>
13103>>>            If (not(Connects[i].bDisabled)) Begin
13105>>>                Get AddConnection Connects[i].sDriver Connects[i].sId Connects[i].sString Connects[i].sUID Connects[i].sPWD Connects[i].bTrustedConnection Connects[i].sSection to bOK
13106>>>                If not bOk Begin
13108>>>                    Function_Return False
13109>>>                End
13109>>>>
13109>>>            End
13109>>>>
13109>>>        Loop
13110>>>>
13110>>>        Function_Return True
13111>>>    End_Function
13112>>>    
13112>>>    // returns the DF_DATABASE_ID handle for the passed connection
13112>>>    // should only be called with data obtained from ConnectionIdInfo
13112>>>    // of ConnectionIds and not LoadStoredConnections
13112>>>    // If this returns 0, the connection is not logged in
13112>>>    Function ConnectionDatabaseIdHandle tConnection Conn Returns Handle
13114>>>        Handle hConnectionHandle
13114>>>        String sServerString
13114>>>        Get ConnectionIDServerString Conn.sId to sServerString
13115>>>        Get ServerDatabaseIdHandle Conn.sDriver Conn.iDriverIndex sServerString to hConnectionHandle
13116>>>        Function_Return hConnectionHandle
13117>>>    End_Function
13118>>>    
13118>>>    Function ServerDatabaseIdHandle String sDriver Integer iDriver String sServerString Returns Handle
13120>>>        Integer i
13120>>>        String[] ServerNames
13121>>>        Handle hConnectionHandle
13121>>>        Get DriverServerNames sDriver to ServerNames
13122>>>        Move (SearchArray(sServerString,ServerNames,Desktop,RefFunc(DFSTRICMP))) to i
13123>>>        If (i<>-1) Begin
13125>>>            Get_Attribute DF_DATABASE_ID of iDriver (i+1) to hConnectionHandle
13128>>>        End
13128>>>>
13128>>>        Function_Return hConnectionHandle
13129>>>    End_Function
13130>>>    
13130>>>    // Is connection ID logged in. Pass just the id (e.g. ID1)
13130>>>    // If connection ID is not registered, raise an error
13130>>>    Function IsConnectionIdLoggedIn String sId Returns Boolean
13132>>>        tConnection Connect
13132>>>        tConnection Connect
13132>>>        Handle hConnectionHandle
13132>>>        Get ConnectionIdInfo sId to Connect
13133>>>        Get ConnectionDatabaseIdHandle Connect to hConnectionHandle
13134>>>        Function_Return (hConnectionHandle<>0)
13135>>>    End_Function
13136>>>    
13136>>>    // login to this managed connection via connection id. return 0 if ok
13136>>>    // If ID not found, raise a program error
13136>>>    // Login by connect Id - main interface.
13136>>>    Function LoginConnectionId String sId Returns Integer
13138>>>        Integer iResult
13138>>>        Handle hoCli
13138>>>        Boolean bSkipDup bConnected
13138>>>        String sDriver sServer sError sDesc
13138>>>        tConnection Connect
13138>>>        tConnection Connect
13138>>>        Get ConnectionIdCLIHandler sId to hoCLI
13139>>>        
13139>>>        If hoCli Begin
13141>>>            Get pbSkipDuplicateLogin to bSkipDup
13142>>>            If (bSkipDup) Begin
13144>>>                Get IsConnectionIdLoggedIn sId to bConnected
13145>>>            End
13145>>>>
13145>>>            If not bConnected Begin
13147>>>                Get LoginConnectIdBase sId False to iResult
13148>>>                If (iResult) Begin
13150>>>                    Get psErrorText to sError
13151>>>                    Get ConnectionIdInfo sId to Connect
13152>>>                    Move (sDesc + sFormat("Connection Id=%1.\n\n",sId) + sError) to sError
13153>>>                    Set psErrorText to sError
13154>>>                End
13154>>>>
13154>>>            End
13154>>>>
13154>>>        End
13154>>>>
13154>>>        Else Begin
13155>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
13156>>>>
13156>>>            Move 1 to iResult
13157>>>        End
13157>>>>
13157>>>        Function_Return iResult
13158>>>    End_Function
13159>>>    
13159>>>    // does unconditional login for connection Id. This
13159>>>    // can be customized.
13159>>>    Function LoginConnectIdBase String sId Boolean bSilent Returns Integer
13161>>>        Integer iError
13161>>>        Boolean bOk bSkipDialog
13161>>>        String sConn
13161>>>        tConnection Connect
13161>>>        tConnection Connect
13161>>>        Get ConnectionIdInfo sId to Connect
13162>>>        Get ConnectionIDServerString Connect.sId to sConn
13163>>>        // first try a silent login. If it works we are done
13163>>>        Get BasicLogin Connect.sDriver sConn "" "" to iError
13164>>>        If (iError=0) Begin
13166>>>            Function_Return 0
13167>>>        End
13167>>>>
13167>>>        
13167>>>        // If login failed because of incorrect client, skip the login dialog.
13167>>>        // This is the first place this version test occurs.
13167>>>        If (iError=CLIERR_NOCLIENTSERVERVERSIONMATCH or iError=CLIERR_MINIMUMCLIENTVERSIONNOTFOUND) Begin
13169>>>            Function_Return 1
13170>>>        End
13170>>>>
13170>>>        
13170>>>        // If we have a compliant login dialog, try that.
13170>>>        If (not(bSilent)) Begin
13172>>>            Get LoginConnectIdDialog Connect.sId to bOk
13173>>>        End
13173>>>>
13173>>>        Function_Return (If(bOk,0,1))
13174>>>    End_Function
13175>>>    
13175>>>    
13175>>>    Function LoginConnectIdDialog String sId Returns Boolean
13177>>>        Handle hoLoginConnectDialog bLoginDialogRequired
13177>>>        Boolean bOk
13177>>>        
13177>>>// web applications don't use an embedded database login
13177>>>        Get pbLoginDialogRequired to bLoginDialogRequired
13178>>>        If (bLoginDialogRequired) Begin
13180>>>            Move ghoLoginConnectDialog to hoLoginConnectDialog
13181>>>            // if object missing an error is raised - programming error
13181>>>            Get LoginConnectIdDialog of hoLoginConnectDialog sId to bOk
13182>>>        End
13182>>>>
13182>>>        
13182>>>        Function_Return bOk
13183>>>    End_Function
13184>>>    
13184>>>    // Change Connect string based on passed credentials
13184>>>    // Update the driver's map of connect Id/Connect strings.
13184>>>    // If there is no change in the connection string, this does nothing.
13184>>>    // This will log out and disconnect from the existing connection and connect (but
13184>>>    // not login) to the new one.
13184>>>    // The Id must exist or errors
13184>>>    Function ChangeConnectIdCredentials String sId String sUser String sPwd Boolean bTrust Returns tConnection
13186>>>        tConnection Connect
13186>>>        tConnection Connect
13186>>>        Integer iError
13186>>>        String sConnStr
13186>>>        Get ConnectionIdInfo sId to Connect
13187>>>        Get AssembleConnectionString Connect.sString sUser sPwd bTrust to Connect.sConnectionString
13188>>>        If (Connect.sConnectionString<>sConnStr) Begin
13190>>>            Send LogoutConnectionId Connect.sId
13191>>>            Send DeleteConnectionId Connect.sId
13192>>>            
13192>>>            Move bTrust to Connect.bTrustedConnection
13193>>>            Move (If(bTrust,"",sUser))  to Connect.sUID
13194>>>            Move (If(bTrust,"",sPwd)) to Connect.sPWD
13195>>>            
13195>>>            Get AddConnection Connect.sDriver Connect.sId Connect.sString Connect.sUID Connect.sPWD Connect.bTrustedConnection Connect.sSection to iError
13196>>>        End
13196>>>>
13196>>>        Function_Return Connect
13197>>>    End_Function
13198>>>    
13198>>>    // attempt connection Id login using ID with passed credentials.
13198>>>    // These credentials will update the driver's map of connect Id/Connect strings.
13198>>>    // The Id must exist or errors
13198>>>    Function LoginConnectIdNewCredentials String sId String sUser String sPwd Boolean bTrust Returns Integer
13200>>>        Integer iError
13200>>>        tConnection Connect
13200>>>        tConnection Connect
13200>>>        Get ChangeConnectIdCredentials sId sUser sPwd bTrust to Connect
13201>>>        Get LoginConnectIdBase sId True to iError // silent
13202>>>        Function_Return iError
13203>>>    End_Function
13204>>>    
13204>>>    // Store credentials for Id. By default store in connections INI file, if used.
13204>>>    // Can be augmented or overridden
13204>>>    Function StoreConnectionIdCredentials String sId String sUID String sPWD Boolean bTrusted Returns Boolean
13206>>>        String sConnectPath
13206>>>        Handle hoIniFile
13206>>>        Boolean bUseConnectionIni
13206>>>        tConnection Connect
13206>>>        tConnection Connect
13206>>>        
13206>>>        Get pbUseConnectionIni to bUseConnectionIni
13207>>>        
13207>>>        If bUseConnectionIni Begin
13209>>>            
13209>>>            Get ConnectionIniFile to sConnectPath
13210>>>            If (sConnectPath="" or not(DoesFileExist(sConnectPath))) Begin
13212>>>                Function_Return True // empty is ok
13213>>>            End
13213>>>>
13213>>>            
13213>>>            Get ConnectionIdInfo sId to Connect
13214>>>            Get Create (RefClass(cIniFile)) to hoIniFile
13215>>>            Set psFilename of hoIniFile to sConnectPath
13216>>>            
13216>>>            If (sPWD<>"") Begin
13218>>>                Get EncryptPassword sPWD to sPWD
13219>>>            End
13219>>>>
13219>>>            
13219>>>            Send OnWriteCredentials Connect.sSection sId hoIniFile sUid sPWD bTrusted
13220>>>            
13220>>>            Send Destroy of hoIniFile
13221>>>        End
13221>>>>
13221>>>        Function_Return True
13222>>>    End_Function
13223>>>    
13223>>>    // logout of this managed connection id. If Id does not exist, do nothing
13223>>>    // note that logging out closes all tables for this connection
13223>>>    Procedure LogoutConnectionId String sId
13225>>>        Handle hoCli
13225>>>        String sDriver sServer
13225>>>        Get ConnectionIdCLIHandler sId to hoCLI
13226>>>        If hoCLI Begin
13228>>>            Get psDriverID of hoCli to sDriver
13229>>>            Get ConnectionIDServerString sId to sServer
13230>>>            Logout sDriver sServer
13231>>>        End
13231>>>>
13231>>>    End_Procedure
13232>>>    
13232>>>    // delete this managed connection id. If Id does not exist, do nothing
13232>>>    // if logged in raise a programming error.
13232>>>    Procedure DeleteConnectionId String sId
13234>>>        Handle hoCli
13234>>>        Integer iResult
13234>>>        Boolean bOk bLoggedIn
13234>>>        Get ConnectionIdCLIHandler sId to hoCli
13235>>>        If hoCLI Begin
13237>>>            // if the connection is logged in, this is an error. Precede this call with
13237>>>            // LogoutConnectionId. This is not done automatically so it is clear to the
13237>>>            // developer that they are logging out of existing connections, which closes
13237>>>            // open tables.
13237>>>            Get IsConnectionIdLoggedIn sId to bLoggedIn
13238>>>            If bLoggedIn Begin
13240>>>                Error DFERR_PROGRAM (SFormat("Connection ID '%1' is still logged-in and cannot be deleted",sId))
13241>>>>
13241>>>                Procedure_Return
13242>>>            End
13242>>>>
13242>>>            Get DeleteConnectionID of hoCli sId -1 to iResult
13243>>>            Get RemoveFromConnections sId to bOk
13244>>>        End
13244>>>>
13244>>>    End_Procedure
13245>>>    
13245>>>    
13245>>>    // login to all managed connection Ids for all drivers
13245>>>    // if error return false on first failure
13245>>>    Function LoginAllConnections Returns Boolean
13247>>>        tConnection[] ConnIds
13247>>>        tConnection[] ConnIds
13248>>>        Integer i iResult
13248>>>        Get ConnectionIDs to ConnIds
13249>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13255>>>>
13255>>>            Get LoginConnectionId ConnIds[i].sId to iResult
13256>>>            If (iResult) Begin
13258>>>                Function_Return False
13259>>>            End
13259>>>>
13259>>>        Loop
13260>>>>
13260>>>        Function_Return True
13261>>>    End_Function
13262>>>    
13262>>>    // logout of all managed connections for all drivers
13262>>>    Procedure LogoutAllConnections
13264>>>        tConnection[] ConnIds
13264>>>        tConnection[] ConnIds
13265>>>        Integer i
13265>>>        Get ConnectionIDs to ConnIds
13266>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13272>>>>
13272>>>            Send LogoutConnectionId ConnIds[i].sId
13273>>>        Loop
13274>>>>
13274>>>    End_Procedure
13275>>>    
13275>>>    // "unregister" all managed connections for all drivers
13275>>>    // Logout and then delete the connection. Note there is no DeleteAllConnections
13275>>>    // because you will always want to logout and delete in a single step.
13275>>>    Procedure UnRegisterAllConnections
13277>>>        tConnection[] ConnIds
13277>>>        tConnection[] ConnIds
13278>>>        Integer i
13278>>>        Get ConnectionIDs to ConnIds
13279>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
13285>>>>
13285>>>            Send LogoutConnectionId ConnIds[i].sId
13286>>>            Send DeleteConnectionId ConnIds[i].sId
13287>>>        Loop
13288>>>>
13288>>>    End_Procedure
13289>>>    
13289>>>    // you can redefine a connection-string for a logged in server and all open tables will get
13289>>>    // redirected to the new connection. You can choose to leave the old connection open so if you switch back
13289>>>    // it can be done quickly.
13289>>>    // This assumes that two servers contain the same tables with the same definitions. If they don't things
13289>>>    // will not work. It is the developer's responsibility to make sure this is the case.
13289>>>    // Use with care.
13289>>>    Function RedirectConnectionId String sId String sServer String sUID String sPWD Boolean bTrusted Boolean bKeepOpen Returns Boolean
13291>>>        Handle hoCli
13291>>>        Integer iIndex iRet
13291>>>        tConnection[] Connections
13291>>>        tConnection[] Connections
13292>>>        tConnection Connection
13292>>>        tConnection Connection
13292>>>        String sConnectString
13292>>>        
13292>>>        Get ConnectionIdIndex sId to iIndex
13293>>>        If (iIndex=-1) Begin
13295>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
13296>>>>
13296>>>            Function_Return 1
13297>>>        End
13297>>>>
13297>>>        
13297>>>        Get ConnectionIdCLIHandler sId to hoCli
13298>>>        Get pConnections to Connections
13299>>>        Move Connections[iIndex] to Connection
13300>>>        
13300>>>        Get AssembleConnectionString sServer sUID sPWD bTrusted to sConnectString
13301>>>        Send AddAppNameToConnectString Connection.sDriver (&sConnectString)
13302>>>        Move sServer to Connection.sString
13303>>>        Move sUID to Connection.sUID
13304>>>        Move sPWD to Connection.sPWD
13305>>>        Move bTrusted to Connection.bTrustedConnection
13306>>>        Move sConnectString to Connection.sConnectionString
13307>>>        Get ConnectionIDServerString sId to sId
13308>>>        
13308>>>        Send TrapErrors
13309>>>        Get RedirectIdConnectString of hoCli sId sConnectString bKeepOpen to iRet
13310>>>        Send UnTrapErrors
13311>>>        // if 1, we have the ID but it must not be not logged-in. We can still
13311>>>        // switch to the non-logged in connection
13311>>>        If (iRet=0 or iRet=1) Begin
13313>>>            // if all is ok, update the connection info
13313>>>            Move Connection to Connections[iIndex]
13314>>>            Set pConnections to Connections
13315>>>            Move 0 to iRet
13316>>>            Set piErrorNumber to 0
13317>>>        End
13317>>>>
13317>>>        Function_Return (iRet=0)
13318>>>    End_Function
13319>>>    
13319>>>    // This gets sent when a mangaged driver is registerd (it might already be loaded).
13319>>>    // Can be used to set CLI driver settings like use-cache etc.
13319>>>    Procedure OnDriverRegistered String sDriver Integer iDriver Handle hoCLIHandler
13321>>>    End_Procedure
13322>>>    
13322>>>    
13322>>>    // this can be used to do whatever you want to the various connection
13322>>>    // info. You might use this to handle your own default UID/PWD enoding logic
13322>>>    // etc.
13322>>>    Procedure OnAddConnection tConnection ByRef Connection
13324>>>    End_Procedure
13325>>>    
13325>>>    Function WriteConnectionsIniString Handle hoIniFile String sSection String sKey String sValue Returns Integer
13327>>>        Integer iErrorNumber
13327>>>        Send TrapErrors
13328>>>        Send WriteString of hoIniFile sSection sKey sValue
13329>>>        Send UnTrapErrors
13330>>>        Get piErrorNumber to iErrorNumber
13331>>>        Function_Return iErrorNumber
13332>>>    End_Function
13333>>>    
13333>>>    // update the connections ini file with passed Ids. Note that the section name
13333>>>    // for each ID is not the name that will be written. It exists if this was the
13333>>>    // initial section name.
13333>>>    Function WriteConnectionsIni String sQFile tConnection[] Ids Returns Boolean
13335>>>        Integer i iErrorNumber iIndex iSec iSections
13335>>>        String  sDriver sValue sPWD sSection
13335>>>        Handle hoIniFile hoArray hoSection
13335>>>        Boolean bOk bExists
13335>>>        String[] Keys Values
13337>>>        tConnectionIniSection[] Sections
13337>>>        tConnectionIniSection[] Sections
13338>>>        tConnectionIniSection SectionTarget
13338>>>        tConnectionIniSection SectionTarget
13338>>>        
13338>>>        // if filename not passed, use the default
13338>>>        If (sQFile="") Begin
13340>>>            Get ConnectionIniFile of ghoConnection to sQFile
13341>>>        End
13341>>>>
13341>>>        
13341>>>        Get Create (RefClass(cIniFile)) to hoIniFile
13342>>>        Get Create (RefClass(Array)) to hoArray
13343>>>        Get Create (RefClass(Array)) to hoSection
13344>>>        Set psFilename of hoIniFile to sQFile
13345>>>        
13345>>>        // first save off all info from an existing section name. This section may get
13345>>>        // renamed but we want to write it out later under that new section name. Hence
13345>>>        // we must store all values.
13345>>>        For i from 0 to (SizeOfArray(Ids)-1)
13351>>>>
13351>>>            If (Ids[i].sSection<>"") Begin
13353>>>                Get SectionExists of hoIniFile Ids[i].sSection to bExists
13354>>>                If bExists Begin
13356>>>                    Move (Lowercase(Ids[i].sSection)) to sSection
13357>>>                    Move sSection to Sections[iSections].sSection
13358>>>                    Send Delete_Data of hoSection
13359>>>                    Send ReadSection of hoIniFile sSection hoSection
13360>>>                    For iSec from 0 to (Item_Count(hoSection)-1)
13366>>>>
13366>>>                        Get Value of hoSection iSec to Sections[iSections].Keys[iSec]
13367>>>                        Get ReadString of hoIniFile sSection Sections[iSections].Keys[iSec] "" to Sections[iSections].Values[iSec]
13368>>>                    Loop
13369>>>>
13369>>>                    Increment iSections
13370>>>                End
13370>>>>
13370>>>            End
13370>>>>
13370>>>        Loop
13371>>>>
13371>>>        
13371>>>        // Now remove all existing connection sections
13371>>>        Send ReadSections of hoIniFile hoArray
13372>>>        For i from 0 to (Item_Count(hoArray) -1)
13378>>>>
13378>>>            Get Value of hoArray i to sSection
13379>>>            Move (Trim(sSection)) to sSection
13380>>>            If (Pos(Uppercase(C_ConnectionIniSectionBaseName),Uppercase(sSection))=1) Begin
13382>>>                Send DeleteSection of hoIniFile sSection
13383>>>            End
13383>>>>
13383>>>            If (iErrorNumber<>0) ;                Break
13386>>>        Loop
13387>>>>
13387>>>        
13387>>>        // now write the new connections, with each connection renamed.
13387>>>        For i from 0 to (SizeOfArray(Ids)-1)
13393>>>>
13393>>>            Move (C_ConnectionIniSectionBaseName+String(i+1)) to sSection
13394>>>            
13394>>>            // if the section already existed, write all existing data back under what
13394>>>            // might be a new section name. Some of this may get overridden below
13394>>>            Move (Lowercase(Ids[i].sSection)) to SectionTarget.sSection
13395>>>            Move (SearchArray(SectionTarget,Sections)) to iIndex
13396>>>            If (iIndex<>-1) Begin
13398>>>                For iSec from 0 to (SizeOfArray(Sections[iIndex].Keys)-1)
13404>>>>
13404>>>                    Get WriteConnectionsIniString hoIniFile sSection Sections[iIndex].Keys[iSec] Sections[iIndex].Values[iSec] to iErrorNumber
13405>>>                    If iErrorNumber ;                        Break
13408>>>                Loop
13409>>>>
13409>>>            End
13409>>>>
13409>>>            If iErrorNumber ;                Break
13412>>>            
13412>>>            // now write / overwrite new data
13412>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionId Ids[i].sId to iErrorNumber
13413>>>            If iErrorNumber ;                Break
13416>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionDriver Ids[i].sDriver to iErrorNumber
13417>>>            If iErrorNumber ;                Break
13420>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionConnection Ids[i].sString to iErrorNumber
13421>>>            If iErrorNumber ;                Break
13424>>>
13424>>>            If (Ids[i].bDisabled) Begin
13426>>>                Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionDisabled "yes" to iErrorNumber
13427>>>            End
13427>>>>
13427>>>            Else Begin
13428>>>                Send DeleteKey of hoIniFile sSection C_ConnectionIniSectionDisabled
13429>>>            End
13429>>>>
13429>>>            If iErrorNumber ;                Break
13432>>>
13432>>>            Move Ids[i].sPWD to sPWD
13433>>>            If (sPWD<>"") Begin
13435>>>                Get EncryptPassword sPWD to sPWD
13436>>>            End
13436>>>>
13436>>>            
13436>>>            Send OnWriteCredentials sSection Ids[i].sId hoIniFile Ids[i].sUID sPWD Ids[i].bTrustedConnection
13437>>>        Loop
13438>>>>
13438>>>        
13438>>>        Send Destroy of hoSection
13439>>>        Send Destroy of hoArray
13440>>>        Send Destroy of hoIniFile
13441>>>        Function_Return (iErrorNumber=0)
13442>>>    End_Function
13443>>>    
13443>>>    // creates an SQL Connection handler for SQL usage. It is up to you to destroy this
13443>>>    // by default it creates a cSQLConnection object. This can be augmented to create use
13443>>>    // a different class
13443>>>    Function CreateESQLConnectionHandler Returns Handle
13445>>>        Handle hoSQLConnection
13445>>>        Get CreateNamed (RefClass(cSQLConnection)) "oSQLConnectionHandler" to hoSQLConnection
13446>>>        Function_Return hoSQLConnection
13447>>>    End_Function
13448>>>    
13448>>>    // get a new ESQL connection handle for this connection Id.
13448>>>    // Programmer must destroy this handle when done
13448>>>    // Id must exist. Programming error if it does not
13448>>>    Function SQLConnectionId String sId Returns Handle
13450>>>        Handle hoSQLConnection hoCLI
13450>>>        Integer bOK
13450>>>        String sDrvrID sServer
13450>>>        
13450>>>        Get ConnectionIdCLIHandler sId to hoCLI
13451>>>        If hoCLI Begin
13453>>>            Get ConnectionIDServerString sId to sServer
13454>>>            Get psDriverID of hoCLI to sDrvrId
13455>>>            Get CreateESQLConnectionHandler to hoSQLConnection
13456>>>            
13456>>>            // force it to use existing connection
13456>>>            Get SQLConnectionConnect of hoSQLConnection sDrvrID sServer to bOK
13457>>>            
13457>>>            If (not(bOK)) Begin
13459>>>                Send DestroySQLConnection of hoSQLConnection
13460>>>                Move 0 to hoSQLConnection
13461>>>            End
13461>>>>
13461>>>        End
13461>>>>
13461>>>        Else Begin
13462>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
13463>>>>
13463>>>        End
13463>>>>
13463>>>        Function_Return hoSQLConnection
13464>>>    End_Function
13465>>>    
13465>>>    // these are interfaces that do not require connection Ids. You can pass a
13465>>>    // driver and a server connect string. Generally there are ID versions of these
13465>>>    // that should be used when possible.
13465>>>    
13465>>>    // is this connection to a server logged in. Pass driver and connect string
13465>>>    // connect string should be INT style. Either full string or DFCONNID=xx
13465>>>    // if driver not loaded, raise an error
13465>>>    Function IsDriverConnectionLoggedIn String sDriver String sConnect Returns Boolean
13467>>>        Handle hConnectionHandle hoCLI
13467>>>        Integer iDriver
13467>>>        Get DriverCLIHandler sDriver to hoCLI
13468>>>        If (hoCLI) Begin
13470>>>            Get DriverIndex sDriver to iDriver
13471>>>            Get ServerDatabaseIdHandle sDriver iDriver sConnect to hConnectionHandle
13472>>>        End
13472>>>>
13472>>>        Else Begin
13473>>>            Error DFERR_PROGRAM (SFormat(C_$DriverNotFound,sDriver))
13474>>>>
13474>>>        End
13474>>>>
13474>>>        Function_Return (hConnectionHandle<>0)
13475>>>    End_Function
13476>>>    
13476>>>    // login to this managed connection via driver and connection string.
13476>>>    // Normally you'd not use this and use LoginConnectionId
13476>>>    // If pbSkipDuplicateLogin=T it will skip the login if it is already connected
13476>>>    // If driver not loaded, attempt to load it.
13476>>>    // If it cannot be loaded, raise a configuration Error
13476>>>    // This is low level - use carefully
13476>>>    Function LoginServer String sDriver String sConnectString String sUID String sPWD Boolean bSilent Returns Integer
13478>>>        Integer iResult iDriver
13478>>>        Handle hoCli
13478>>>        Boolean bSkipDup bConnected bOldSilent
13478>>>        Get RegisterDriver sDriver to hoCLI
13479>>>        If hoCli Begin
13481>>>            Get pbSkipDuplicateLogin to bSkipDup
13482>>>            If (bSkipDup) Begin
13484>>>                Get IsDriverConnectionLoggedIn sDriver sConnectString to bConnected
13485>>>            End
13485>>>>
13485>>>            If not bConnected Begin
13487>>>                Get DriverIndex sDriver to iDriver
13488>>>                // note that passing the server as dfconnid=Id will not recognize bSilent
13488>>>                Get_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bOldSilent
13491>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bSilent
13494>>>                Get BasicLogin sDriver sConnectString sUID sPWD to iResult
13495>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bOldSilent
13498>>>            End
13498>>>>
13498>>>        End
13498>>>>
13498>>>        Else Begin
13499>>>            // if driver cannot be loaded, an error will be raised in RegisterDriver
13499>>>            Move 1 to iResult
13500>>>        End
13500>>>>
13500>>>        Function_Return iResult
13501>>>    End_Function
13502>>>    
13502>>>    // can connect using any server connect string for this driver
13502>>>    // returns new  ESQL connection handler, which the developer must destroy.
13502>>>    Function SQLConnection String sDriver String sConnect Returns Handle
13504>>>        Handle hoSQLConnection
13504>>>        String sDrvrID
13504>>>        Handle hoCLI
13504>>>        Boolean bOk
13504>>>        
13504>>>        // will raise configuration error if driver cannot be loaded
13504>>>        Get RegisterDriver sDriver to hoCLI
13505>>>        If hoCli Begin
13507>>>            Get CreateESQLConnectionHandler to hoSQLConnection
13508>>>            
13508>>>            // force it to use existing connection
13508>>>            Get SQLConnectionConnect of hoSQLConnection sDriver sConnect to bOK
13509>>>            
13509>>>            If (not(bOK)) Begin
13511>>>                Send DestroySQLConnection of hoSQLConnection
13512>>>                Move 0 to hoSQLConnection
13513>>>            End
13513>>>>
13513>>>            
13513>>>        End
13513>>>>
13513>>>        Function_Return hoSQLConnection
13514>>>    End_Function
13515>>>    
13515>>>    // get a new ESQL connection handle for this open table. Programmer must
13515>>>    // destroy this handle when done
13515>>>    Function SQLConnectionByTable Handle hoTable Returns Handle
13517>>>        Handle hoSQLConnection
13517>>>        Boolean bOk
13517>>>        
13517>>>        Get CreateESQLConnectionHandler to hoSQLConnection
13518>>>        Get SQLFileConnect of hoSQLConnection hoTable to bOk
13519>>>        If (not(bOK)) Begin
13521>>>            Send DestroySQLConnection of hoSQLConnection
13522>>>            Move 0 to hoSQLConnection
13523>>>        End
13523>>>>
13523>>>        
13523>>>        Function_Return hoSQLConnection
13524>>>    End_Function
13525>>>    
13525>>>    // load all managed drivers and set up all managed connections. Abort if a failure
13525>>>    // if you don't want automatic abort, use RegisterAllDrivers and AddAllConnections
13525>>>    // This should succeed - if not it's a programming error
13525>>>    Procedure RegisterAllConnections
13527>>>        Boolean bOk
13527>>>        Get AddAllConnections to bOk
13528>>>        If not bOk Begin
13530>>>            Send UserError "Could not load and register managed drivers. The application cannot be run"
13531>>>            Abort
13532>>>>
13532>>>        End
13532>>>>
13532>>>    End_Procedure
13533>>>    
13533>>>    // Login to all managed connections in all managed drivers. Abort if any fail
13533>>>    // if you don't want automatic abort, use the function LoginAllConnections or
13533>>>    // LoginConnectionId
13533>>>    Procedure LoginAll
13535>>>        Boolean bOk
13535>>>        Integer iError
13535>>>        String sError
13535>>>        Get LoginAllConnections to bOk
13536>>>        If not bOk Begin
13538>>>            Get psErrorText to sError
13539>>>            Get piErrorNumber to iError
13540>>>            Send UserError (C_$LoginAllFailedWillAbort + "\n\n" + sError)
13541>>>            Abort
13542>>>>
13542>>>        End
13542>>>>
13542>>>    End_Procedure
13543>>>    
13543>>>    // Standard Auto-connect behavior.
13543>>>    // if pbAutoConnect is T it does a registerAll & LoginAll and aborts if an error occurs
13543>>>    // if pbAutoConnect is F, it does nothing.
13543>>>    // Note that RegisterAll and LoginIn don't do anything if managed connections are not used.
13543>>>    // This is called by cApplication when a workspace is opened.
13543>>>    Procedure AutoConnect
13545>>>        Boolean bAutoConnect
13545>>>        Get pbAutoConnect to bAutoConnect
13546>>>        If bAutoConnect Begin
13548>>>            Send RegisterAllConnections // might abort on failure
13549>>>            Send LoginAll // might abort on failure
13550>>>        End
13550>>>>
13550>>>    End_Procedure
13551>>>    
13551>>>    // This is called by cApplication when a workspace is opened.
13551>>>    Procedure AutoDisconnect
13553>>>        Boolean bAutoConnect
13553>>>        Get pbAutoConnect to bAutoConnect
13554>>>        If bAutoConnect Begin
13556>>>            Send UnRegisterAllConnections
13557>>>        End
13557>>>>
13557>>>    End_Procedure
13558>>>    
13558>>>    // EnumerateConnections:
13558>>>    // List the current registered connection ids.
13558>>>    //
13558>>>    Procedure EnumerateConnections Handle hoCallBack Handle hmGeneric
13560>>>        tConnection[] ConnIds
13560>>>        tConnection[] ConnIds
13561>>>        Integer i iConnIds
13561>>>        String sConnectionsIni
13561>>>        
13561>>>        Get ConnectionIniFile to sConnectionsIni
13562>>>        
13562>>>        Send hmGeneric of hoCallBack C_$ManagedConnections
13563>>>        Send hmGeneric of hoCallBack (SFormat(C_$ManagedConnectionsIniFile, ConnectionIniFile(Self)))
13564>>>        
13564>>>        Get ConnectionIDs to ConnIds
13565>>>        Move (SizeOfArray(ConnIds)) to iConnIds
13566>>>        If (iConnIds=0) Begin
13568>>>            Send hmGeneric of hoCallBack C_$ManagedConnectionsNone
13569>>>        End
13569>>>>
13569>>>        Else Begin
13570>>>            For i from 0 to (iConnIds-1)
13576>>>>
13576>>>                Send hmGeneric of hoCallBack (SFormat(C_$ManagedConnectionsIdLine, ConnIds[i].sId, ConnIds[i].sString, ConnIds[i].sDriver))
13577>>>            Loop
13578>>>>
13578>>>        End
13578>>>>
13578>>>    End_Procedure
13579>>>    
13579>>>End_Class
13580>
13580>// When using Managed Connections with user credentials from 
13580>
13580>Object oApplication is a cApplication
13582>
13582>    Object oConnection is a cConnection
13584>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 25.0\Pkg\LoginEncryption.pkg)
13584>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cLoginEncryption.pkg)
13584>>>>>Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 25.0\Pkg\cCryptographerEx.pkg)
13584>>>>>>>Use VdfBase.pkg
13584>>>>>>>
13584>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 25.0\Pkg\CryptographerConstants.pkg)
13584>>>>>>>>>//   Author  : Ulbe Stellema
13584>>>>>>>>>// Algorithm classes
13584>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
13584>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
13584>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
13584>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
13584>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
13584>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
13584>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
13584>>>>>>>>>
13584>>>>>>>>>// Algorithm types
13584>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
13584>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
13584>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
13584>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
13584>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
13584>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
13584>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
13584>>>>>>>>>
13584>>>>>>>>>// Generic sub-ids
13584>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
13584>>>>>>>>>
13584>>>>>>>>>// RSA sub-ids
13584>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
13584>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
13584>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
13584>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
13584>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
13584>>>>>>>>>
13584>>>>>>>>>// DSS sub-ids
13584>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
13584>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
13584>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
13584>>>>>>>>>
13584>>>>>>>>>// DES sub_ids
13584>>>>>>>>>Define ALG_SID_DES                      for 1
13584>>>>>>>>>Define ALG_SID_3DES                     for 3
13584>>>>>>>>>Define ALG_SID_DESX                     for 4
13584>>>>>>>>>Define ALG_SID_IDEA                     for 5
13584>>>>>>>>>Define ALG_SID_CAST                     for 6
13584>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
13584>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
13584>>>>>>>>>Define ALG_SID_3DES_112                 for 9
13584>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
13584>>>>>>>>>Define ALG_SID_RC5                      for 13
13584>>>>>>>>>Define ALG_SID_AES_128                  for 14
13584>>>>>>>>>Define ALG_SID_AES_192                  for 15
13584>>>>>>>>>Define ALG_SID_AES_256                  for 16
13584>>>>>>>>>Define ALG_SID_AES                      for 17
13584>>>>>>>>>
13584>>>>>>>>>// Fortezza sub-ids
13584>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
13584>>>>>>>>>Define ALG_SID_TEK                      for 11
13584>>>>>>>>>
13584>>>>>>>>>// RC2 sub-ids
13584>>>>>>>>>Define ALG_SID_RC2                      for 2
13584>>>>>>>>>
13584>>>>>>>>>// Stream cipher sub-ids
13584>>>>>>>>>Define ALG_SID_RC4                      for 1
13584>>>>>>>>>Define ALG_SID_SEAL                     for 2
13584>>>>>>>>>
13584>>>>>>>>>// Diffie-Hellman sub-ids
13584>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
13584>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
13584>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
13584>>>>>>>>>Define ALG_SID_KEA                      for 4
13584>>>>>>>>>
13584>>>>>>>>>// Hash sub ids
13584>>>>>>>>>Define ALG_SID_MD2                      for 1
13584>>>>>>>>>Define ALG_SID_MD4                      for 2
13584>>>>>>>>>Define ALG_SID_MD5                      for 3
13584>>>>>>>>>Define ALG_SID_SHA                      for 4
13584>>>>>>>>>Define ALG_SID_SHA1                     for 4
13584>>>>>>>>>Define ALG_SID_MAC                      for 5
13584>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
13584>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
13584>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
13584>>>>>>>>>Define ALG_SID_HMAC                     for 9
13584>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
13584>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
13584>>>>>>>>>Define ALG_SID_SHA_256                  for 12
13584>>>>>>>>>Define ALG_SID_SHA_384                  for 13
13584>>>>>>>>>Define ALG_SID_SHA_512                  for 14
13584>>>>>>>>>
13584>>>>>>>>>// secure channel sub ids
13584>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
13584>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
13584>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
13584>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
13584>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
13584>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
13584>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
13584>>>>>>>>>
13584>>>>>>>>>// algorithm identifier definitions
13584>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
13584>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
13584>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
13584>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
13584>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
13584>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
13584>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
13584>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
13584>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
13584>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
13584>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
13584>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
13584>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
13584>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
13584>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
13584>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
13584>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
13584>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
13584>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
13584>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
13584>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
13584>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
13584>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
13584>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
13584>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
13584>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
13584>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
13584>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
13584>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
13584>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
13584>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
13584>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
13584>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
13584>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
13584>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
13584>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
13584>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
13584>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
13584>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
13584>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
13584>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
13584>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
13584>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
13584>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
13584>>>>>>>>>
13584>>>>>>>>>// Providers
13584>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
13584>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
13584>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
13584>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
13584>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
13584>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
13584>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
13584>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
13584>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
13584>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
13584>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
13584>>>>>>>>>
13584>>>>>>>>>// dwFlags definitions for CryptAcquireContext
13584>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
13584>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
13584>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
13584>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
13584>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
13584>>>>>>>>>
13584>>>>>>>>>// dwFlag definitions for CryptGenKey
13584>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
13584>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
13584>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
13584>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
13584>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
13584>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
13584>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
13584>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
13584>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
13584>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
13584>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
13584>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
13584>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
13584>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
13584>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
13584>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
13584>>>>>>>>>
13584>>>>>>>>>// Provider types
13584>>>>>>>>>Define PROV_RSA_FULL                    for 1
13584>>>>>>>>>Define PROV_RSA_SIG                     for 2
13584>>>>>>>>>Define PROV_DSS                         for 3
13584>>>>>>>>>Define PROV_FORTEZZA                    for 4
13584>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
13584>>>>>>>>>Define PROV_SSL                         for 6
13584>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
13584>>>>>>>>>Define PROV_DSS_DH                      for 13
13584>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
13584>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
13584>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
13584>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
13584>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
13584>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
13584>>>>>>>>>Define PROV_RNG                         for 21
13584>>>>>>>>>Define PROV_INTEL_SEC                   for 22
13584>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
13584>>>>>>>>>Define PROV_RSA_AES                     for 24
13584>>>>>>>>>
13584>>>>>>>>>// KP_MODE
13584>>>>>>>>>// KP_MODE
13584>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
13584>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
13584>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
13584>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
13584>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
13584>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
13584>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
13584>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
13584>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
13584>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
13584>>>>>>>>>
13584>>>>>>>>>// dwParam definitions for CryptGetKeyParam
13584>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
13584>>>>>>>>>Define KP_SALT                          for 2       // Salt value
13584>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
13584>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
13584>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
13584>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
13584>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
13584>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
13584>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
13584>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
13584>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
13584>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
13584>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
13584>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
13584>>>>>>>>>Define KP_Y                             for 15      // Y value
13584>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
13584>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
13584>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
13584>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
13584>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
13584>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
13584>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
13584>>>>>>>>>Define KP_RP                            for 23
13584>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
13584>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
13584>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
13584>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
13584>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
13584>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
13584>>>>>>>>>Define KP_KEYVAL                        for 30
13584>>>>>>>>>Define KP_ADMIN_PIN                     for 31
13584>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
13584>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
13584>>>>>>>>>Define KP_PREHASH                       for 34
13584>>>>>>>>>Define KP_ROUNDS                        for 35
13584>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
13584>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
13584>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
13584>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
13584>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
13584>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
13584>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
13584>>>>>>>>>
13584>>>>>>>>>// dwParam definitions for CryptGetHashParam
13584>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
13584>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
13584>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
13584>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
13584>>>>>>>>>
13584>>>>>>>>>// key BLOB types
13584>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
13584>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
13584>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
13584>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
13584>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
13584>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
13584>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
13584>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
13584>>>>>>>>>
13584>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
13584>>>>>>>>>
13584>>>>>>>>>// KP_PADDING
13584>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
13584>>>>>>>>>Define RANDOM_PADDING                   for 2
13584>>>>>>>>>Define ZERO_PADDING                     for 3
13584>>>>>>>>>
13584>>>>>>>>>//  Structure cryptimportkey
13584>>>>>>>>>Struct PUBLICKEYSTRUC
13584>>>>>>>>>    UChar    bType
13584>>>>>>>>>    UChar    bVersion
13584>>>>>>>>>    UShort   reserved
13584>>>>>>>>>    UInteger aiKeyAlg
13584>>>>>>>>>End_Struct
13584>>>>>>>>>
13584>>>>>>>>>Struct tPLAINTEXTKEYBLOB
13584>>>>>>>>>    PUBLICKEYSTRUC hdr
13584>>>>>>>>>    PUBLICKEYSTRUC hdr
13584>>>>>>>>>    UInteger       dwKeySize
13584>>>>>>>>>//    UChar[]        rgbKeyData
13584>>>>>>>>>End_Struct
13584>>>>>>>>>
13584>>>>>>>>>
13584>>>>>>>>>
13584>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
13584>>>>>>>>>Struct HMAC_INFO
13584>>>>>>>>>    UInteger HashAlgid
13584>>>>>>>>>    Pointer pbInnerString
13584>>>>>>>>>    DWord cbInnerString
13584>>>>>>>>>    Pointer pbOuterString
13584>>>>>>>>>    DWord cbOuterString
13584>>>>>>>>>End_Struct
13584>>>>>>>>>
13584>>>>>>>>>Struct BLOBHEADER
13584>>>>>>>>>    UChar   bType
13584>>>>>>>>>    UChar   bVersion
13584>>>>>>>>>    Short   reserved
13584>>>>>>>>>    Integer aiKeyAlg
13584>>>>>>>>>End_Struct
13584>>>>>>>>>
13584>>>>>>>>>Struct CryptoBlob
13584>>>>>>>>>    BLOBHEADER  header
13584>>>>>>>>>    BLOBHEADER  header
13584>>>>>>>>>    Integer     cbKeySize
13584>>>>>>>>>    UChar[32]   rgbKeyData
13584>>>>>>>>>End_Struct
13584>>>>>>>>>
13584>>>>>>>>>
13584>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
13584>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
13585>>>>>>>>>
13585>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
13585>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
13587>>>>>>>>>    
13587>>>>>>>>>    Boolean bResult
13587>>>>>>>>>    UWide   uwContainer uwProvider
13587>>>>>>>>>    UWide   uwContainer uwProvider
13587>>>>>>>>>
13587>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
13588>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
13589>>>>>>>>>    
13589>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
13590>>>>>>>>>
13590>>>>>>>>>    Function_Return bResult
13591>>>>>>>>>End_Function
13592>>>>>>>>>
13592>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
13593>>>>>>>>>
13593>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
13594>>>>>>>>>
13594>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
13595>>>>>>>>>
13595>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
13596>>>>>>>>>
13596>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13597>>>>>>>>>
13597>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
13598>>>>>>>>>
13598>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
13599>>>>>>>>>
13599>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13600>>>>>>>>>
13600>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
13601>>>>>>>>>    
13601>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
13602>>>>>>>>>
13602>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
13603>>>>>>>>>
13603>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
13604>>>>>>>>>
13604>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
13605>>>>>>>>>    
13605>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
13606>>>>>>>>>    
13606>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13607>>>>>>>>>    
13607>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
13608>>>>>>>
13608>>>>>>>Class cCryptographerEx is a cObject
13609>>>>>>>    
13609>>>>>>>    Procedure Construct_Object
13611>>>>>>>        Forward Send Construct_Object
13613>>>>>>>        
13613>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
13614>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
13615>>>>>>>        Property Integer    piCipher    CALG_RC4
13616>>>>>>>        Property Integer    piHash      CALG_MD5
13617>>>>>>>        
13617>>>>>>>        // Private properties
13617>>>>>>>        Property Handle     Private_phProv
13618>>>>>>>        
13618>>>>>>>        // Block cipher properties
13618>>>>>>>        Property UChar[]    paKey
13619>>>>>>>        Property UChar[]    paIV
13620>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
13621>>>>>>>        Property Integer    piKeyType       CALG_AES_256
13622>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
13623>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
13624>>>>>>>        Property Integer    piBlockSize     16
13625>>>>>>>    End_Procedure
13626>>>>>>>    
13626>>>>>>>    
13626>>>>>>>    // Acquire key container handle
13626>>>>>>>    Function AcquireContext Returns Handle
13628>>>>>>>        Integer iProvider
13628>>>>>>>        WString wProvider
13628>>>>>>>        Handle hProv
13628>>>>>>>        Boolean bOk
13628>>>>>>>        Pointer pProv
13628>>>>>>>        
13628>>>>>>>        Move 0 to hProv
13629>>>>>>>        Get piProvider to iProvider
13630>>>>>>>        Get psProvider to wProvider
13631>>>>>>>        
13631>>>>>>>        //  Determine address to be passed as provider
13631>>>>>>>        If (Trim(wProvider) <> "") Begin
13633>>>>>>>            Move (AddressOf(wProvider)) to pProv
13634>>>>>>>        End
13634>>>>>>>>
13634>>>>>>>        Else Begin
13635>>>>>>>            Move 0 to pProv
13636>>>>>>>        End
13636>>>>>>>>
13636>>>>>>>        
13636>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
13636>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
13637>>>>>>>        If (not(bOk) or hProv = 0) Begin
13639>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
13640>>>>>>>        End
13640>>>>>>>>
13640>>>>>>>        
13640>>>>>>>        If (not(bOk) or hProv = 0) Begin
13642>>>>>>>            // Fallback to original
13642>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
13643>>>>>>>            
13643>>>>>>>            If (not(bOk) or hProv = 0) Begin
13645>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
13646>>>>>>>            End
13646>>>>>>>>
13646>>>>>>>        End
13646>>>>>>>>
13646>>>>>>>        Set Private_phProv to hProv
13647>>>>>>>        
13647>>>>>>>        Function_Return hProv
13648>>>>>>>    End_Function
13649>>>>>>>    
13649>>>>>>>    // Releases key container handle
13649>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
13651>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
13652>>>>>>>    End_Function
13653>>>>>>>    
13653>>>>>>>    // Creates hash object
13653>>>>>>>    Function CreateHash Handle hProv Returns Handle
13655>>>>>>>        Integer iAlgorithm
13655>>>>>>>        Handle hHash
13655>>>>>>>        Boolean bOk
13655>>>>>>>        
13655>>>>>>>        Move 0 to hHash
13656>>>>>>>        Get piHash to iAlgorithm
13657>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
13658>>>>>>>        
13658>>>>>>>        Function_Return hHash
13659>>>>>>>    End_Function
13660>>>>>>>    
13660>>>>>>>    // Destroys the hash object
13660>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
13662>>>>>>>        Function_Return (CryptDestroyHash(hHash))
13663>>>>>>>    End_Function
13664>>>>>>>    
13664>>>>>>>    // Adds data to hash object
13664>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
13666>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
13667>>>>>>>    End_Function
13668>>>>>>>    
13668>>>>>>>    // Generates session key
13668>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
13670>>>>>>>        Integer iAlgorithm
13670>>>>>>>        Handle hKey
13670>>>>>>>        Boolean bOk
13670>>>>>>>        
13670>>>>>>>        Move 0 to hKey
13671>>>>>>>        Get piCipher to iAlgorithm
13672>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
13673>>>>>>>        
13673>>>>>>>        Function_Return hKey
13674>>>>>>>    End_Function
13675>>>>>>>    
13675>>>>>>>    // Imports a plain text key
13675>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
13677>>>>>>>        tPLAINTEXTKEYBLOB blobhead
13677>>>>>>>        tPLAINTEXTKEYBLOB blobhead
13677>>>>>>>        Boolean   bSuccess
13677>>>>>>>        Handle    hKey
13677>>>>>>>        Integer   iHeadSize iKeySize
13677>>>>>>>        UChar[]   ucaKeyblob
13678>>>>>>>        Integer iVoid
13678>>>>>>>        
13678>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
13679>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
13680>>>>>>>        
13680>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
13681>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
13682>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
13683>>>>>>>        Move iKeySize           to blobhead.dwKeySize
13684>>>>>>>        
13684>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
13685>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
13686>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
13687>>>>>>>        
13687>>>>>>>        Move 0 to hKey
13688>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
13689>>>>>>>        If (not(bSuccess)) Begin
13691>>>>>>>            Move (ShowLastError()) to iVoid
13692>>>>>>>        End
13692>>>>>>>>
13692>>>>>>>        
13692>>>>>>>        Function_Return hKey
13693>>>>>>>    End_Function
13694>>>>>>>    
13694>>>>>>>    // Destroys the key
13694>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
13696>>>>>>>        Function_Return (CryptDestroyKey(hKey))
13697>>>>>>>    End_Function
13698>>>>>>>    
13698>>>>>>>    // Retrieves key data
13698>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
13700>>>>>>>        Integer iBuffer iLen
13700>>>>>>>        Boolean bOk
13700>>>>>>>        
13700>>>>>>>        Move (SizeOfType(Integer)) to iLen
13701>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
13702>>>>>>>        Function_Return iBuffer
13703>>>>>>>    End_Function
13704>>>>>>>    
13704>>>>>>>    // Retrieves a hash value
13704>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
13706>>>>>>>        UChar[] ucHash
13707>>>>>>>        Integer liResult
13707>>>>>>>        DWord   dwDataLen
13707>>>>>>>        
13707>>>>>>>        Move 0 to dwDataLen
13708>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
13709>>>>>>>        If (liResult = 0) ;            Function_Return ""
13712>>>>>>>        
13712>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
13713>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
13714>>>>>>>        If (liResult = 0) ;            Function_Return ""
13717>>>>>>>        
13717>>>>>>>        Function_Return ucHash
13718>>>>>>>    End_Function
13719>>>>>>>
13719>>>>>>>    // Encrypts data
13719>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
13721>>>>>>>        Handle hProv hHash hKey
13721>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
13721>>>>>>>        Boolean bOk
13721>>>>>>>        
13721>>>>>>>        Get AcquireContext to hProv
13722>>>>>>>        If (hProv) Begin
13724>>>>>>>            Get CreateHash hProv to hHash
13725>>>>>>>            If (hHash) Begin
13727>>>>>>>                Get HashData hHash ucPassword to bOk
13728>>>>>>>                If (bOk) Begin
13730>>>>>>>                    Get piCipher to iAlgorithm
13731>>>>>>>                    Get DeriveKey hProv hHash to hKey
13732>>>>>>>                End
13732>>>>>>>>
13732>>>>>>>                Get DestroyHash hHash to bOk
13733>>>>>>>            End
13733>>>>>>>>
13733>>>>>>>            
13733>>>>>>>            If (hKey) Begin
13735>>>>>>>                //  First call to determine resulting data size
13735>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
13736>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
13737>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
13738>>>>>>>                
13738>>>>>>>                //  Reserve space in string
13738>>>>>>>                If (iDataLen < iCipherLen) Begin
13740>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
13741>>>>>>>                End
13741>>>>>>>>
13741>>>>>>>                
13741>>>>>>>                //  Call to really decrypt
13741>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
13742>>>>>>>                //If (not(bOk)) Begin
13742>>>>>>>                //Move "" to sData
13742>>>>>>>                //Move (GetLastError()) to iErr
13742>>>>>>>                //End
13742>>>>>>>                
13742>>>>>>>                Get DestroyKey hKey to bOk
13743>>>>>>>            End 
13743>>>>>>>>
13743>>>>>>>            Get ReleaseContext hProv to bOk
13744>>>>>>>        End 
13744>>>>>>>>
13744>>>>>>>        Function_Return ucData
13745>>>>>>>    End_Function
13746>>>>>>>    
13746>>>>>>>    // Decrypts data
13746>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
13748>>>>>>>        Handle hProv hHash hKey
13748>>>>>>>        Integer iAlgorithm iDataLen
13748>>>>>>>        Boolean bOk
13748>>>>>>>        
13748>>>>>>>        Get AcquireContext to hProv
13749>>>>>>>        If (hProv) Begin
13751>>>>>>>            Get CreateHash hProv to hHash
13752>>>>>>>            If (hHash) Begin
13754>>>>>>>                Get HashData hHash ucPassword to bOk
13755>>>>>>>                If (bOk) Begin
13757>>>>>>>                    Get piCipher to iAlgorithm
13758>>>>>>>                    Get DeriveKey hProv hHash to hKey
13759>>>>>>>                End
13759>>>>>>>>
13759>>>>>>>                Get DestroyHash hHash to bOk
13760>>>>>>>            End
13760>>>>>>>>
13760>>>>>>>            
13760>>>>>>>            If (hKey) Begin
13762>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
13763>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
13764>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
13764>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
13766>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
13767>>>>>>>                End
13767>>>>>>>>
13767>>>>>>>                
13767>>>>>>>                Get DestroyKey hKey to bOk
13768>>>>>>>            End
13768>>>>>>>>
13768>>>>>>>            Get ReleaseContext hProv to bOk
13769>>>>>>>        End
13769>>>>>>>>
13769>>>>>>>        Function_Return ucData
13770>>>>>>>    End_Function
13771>>>>>>>    
13771>>>>>>>    // Creates a key
13771>>>>>>>    Function CreateKey Handle hProv Returns Handle
13773>>>>>>>        Integer iAlg iType iByte iLength iSize
13773>>>>>>>        CryptoBlob keyBlob
13773>>>>>>>        CryptoBlob keyBlob
13773>>>>>>>        Boolean bOk
13773>>>>>>>        Handle hKey
13773>>>>>>>        UChar[] aKey
13774>>>>>>>
13774>>>>>>>        Get paKey to aKey
13775>>>>>>>        Get piKeyAlg to iAlg
13776>>>>>>>        Get piKeyType to iType
13777>>>>>>>        Move iAlg                   to keyBlob.header.bType
13778>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
13779>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
13780>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
13781>>>>>>>        
13781>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
13782>>>>>>>        For iByte from 0 to iLength
13788>>>>>>>>
13788>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
13789>>>>>>>        Loop
13790>>>>>>>>
13790>>>>>>>        
13790>>>>>>>        Move 0 to hKey
13791>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
13792>>>>>>>        Function_Return hKey
13793>>>>>>>    End_Function
13794>>>>>>>    
13794>>>>>>>    // Sets the key parameters
13794>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
13796>>>>>>>        Integer iPadding iMode
13796>>>>>>>        Boolean bOk
13796>>>>>>>        UChar[] aIV
13797>>>>>>>        
13797>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
13797>>>>>>>        //For iByte from 0 to iLength
13797>>>>>>>        //    Move iByte to aIV[iByte]
13797>>>>>>>        //Loop
13797>>>>>>>
13797>>>>>>>        // Set initialization vector
13797>>>>>>>        Get paIV to aIV
13798>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
13799>>>>>>>        If (bOk) Begin
13801>>>>>>>            // Set padding
13801>>>>>>>            Get piKeyPadding to iPadding
13802>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
13803>>>>>>>            If (bOk) Begin
13805>>>>>>>                // Set move
13805>>>>>>>                Get piKeyMode to iMode
13806>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
13807>>>>>>>            End
13807>>>>>>>>
13807>>>>>>>        End
13807>>>>>>>>
13807>>>>>>>        Function_Return bOk        
13808>>>>>>>    End_Function
13809>>>>>>>    
13809>>>>>>>    // Encrypts using block cipher
13809>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
13811>>>>>>>        Handle hProv hKey
13811>>>>>>>        Integer iLen iSize iBlocks
13811>>>>>>>        Boolean bOk
13811>>>>>>>        
13811>>>>>>>        Get AcquireContext to hProv
13812>>>>>>>        If (hProv) Begin
13814>>>>>>>            // Create key
13814>>>>>>>            Get CreateKey hProv to hKey
13815>>>>>>>            If (hKey) Begin
13817>>>>>>>                Get SetKeyParameters hKey to bOk
13818>>>>>>>                If (bOk) Begin
13820>>>>>>>                    // Buffer for block ciphers can be up to block length larger
13820>>>>>>>                    Get piBlockSize to iSize
13821>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
13822>>>>>>>                    
13822>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
13823>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
13824>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
13825>>>>>>>                End
13825>>>>>>>>
13825>>>>>>>                Get DestroyKey hKey to bOk
13826>>>>>>>            End
13826>>>>>>>>
13826>>>>>>>            Get ReleaseContext hProv to bOk
13827>>>>>>>        End
13827>>>>>>>>
13827>>>>>>>        Function_Return ucData
13828>>>>>>>    End_Function
13829>>>>>>>    
13829>>>>>>>    // Decrypts using block cipher
13829>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
13831>>>>>>>        Handle hProv hKey
13831>>>>>>>        Integer iLen
13831>>>>>>>        Boolean bOk
13831>>>>>>>        
13831>>>>>>>        Get AcquireContext to hProv
13832>>>>>>>        If (hProv) Begin
13834>>>>>>>            // Create key
13834>>>>>>>            Get CreateKey hProv to hKey
13835>>>>>>>            If (hKey) Begin
13837>>>>>>>                Get SetKeyParameters hKey to bOk
13838>>>>>>>                If (bOk) Begin
13840>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
13841>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
13842>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
13843>>>>>>>                End
13843>>>>>>>>
13843>>>>>>>                Get DestroyKey hKey to bOk
13844>>>>>>>            End
13844>>>>>>>>
13844>>>>>>>            Get ReleaseContext hProv to bOk
13845>>>>>>>        End
13845>>>>>>>>
13845>>>>>>>        Function_Return ucData
13846>>>>>>>    End_Function
13847>>>>>>>    
13847>>>>>>>    
13847>>>>>>>    //  Generates random data.
13847>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
13849>>>>>>>        Handle hProv
13849>>>>>>>        UChar[] uaResult
13850>>>>>>>        Boolean bRes
13850>>>>>>>        
13850>>>>>>>        Get AcquireContext to hProv
13851>>>>>>>        
13851>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
13852>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
13853>>>>>>>        
13853>>>>>>>        Get ReleaseContext hProv to bRes
13854>>>>>>>        
13854>>>>>>>        Function_Return uaResult
13855>>>>>>>    End_Function
13856>>>>>>>    
13856>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
13856>>>>>>>    Function GenerateRandomString Integer iLength Returns String
13858>>>>>>>        String sResult
13858>>>>>>>        UChar[] ucData
13859>>>>>>>        Pointer pBase64
13859>>>>>>>        Integer iVoid
13859>>>>>>>        
13859>>>>>>>        Get GenerateRandom iLength to ucData
13860>>>>>>>        
13860>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
13861>>>>>>>        Move (PointerToString(pBase64)) to sResult
13862>>>>>>>        Move (Free(pBase64)) to iVoid
13863>>>>>>>        
13863>>>>>>>        Function_Return (Left(sResult, iLength))
13864>>>>>>>    End_Function
13865>>>>>>>    
13865>>>>>>>End_Class
13866>>>>>
13866>>>>>Class cLoginEncryption is a cObject
13867>>>>>    
13867>>>>>    Procedure Construct_Object
13869>>>>>        Forward Send Construct_Object
13871>>>>>        // this must be set to a multi (40ish) character random key
13871>>>>>        Property String psEncryptPassword ""
13872>>>>>        
13872>>>>>        Object oDataCrypter is a cCryptographerEx
13874>>>>>            Set piHash to CALG_SHA_256
13875>>>>>            Set piCipher to CALG_AES_256
13876>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
13877>>>>>            Set piProvider to PROV_RSA_AES
13878>>>>>        End_Object
13879>>>>>    End_Procedure
13880>>>>>    
13880>>>>>    // This can be augmented to return a password encryption key using any
13880>>>>>    // hidden mechanism desired.
13880>>>>>    Function GetEncryptionPassword Returns String
13882>>>>>        String sPassword
13882>>>>>        Get psEncryptPassword to sPassword
13883>>>>>        Function_Return sPassword
13884>>>>>    End_Function
13885>>>>>    
13885>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
13885>>>>>    //
13885>>>>>    // Params:
13885>>>>>    //   sPlainText     String to encrypt.
13885>>>>>    // Returns:
13885>>>>>    //   Base64 encoded hash.
13885>>>>>    Function EncryptPassword String sPlainText Returns String
13887>>>>>        String sEncryptPassword sBase64
13887>>>>>        UChar[] ucBinary
13888>>>>>        Pointer pBase64
13888>>>>>        Integer iVoid
13888>>>>>        
13888>>>>>        //  Encrypt Key
13888>>>>>        Get GetEncryptionPassword to sEncryptPassword
13889>>>>>        If (sEncryptPassword = "") Begin
13891>>>>>            Error DFERR_PROGRAM "No encryption password set"
13892>>>>>>
13892>>>>>        End
13892>>>>>>
13892>>>>>        
13892>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
13893>>>>>        
13893>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
13895>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
13896>>>>>>
13896>>>>>            Function_Return ""
13897>>>>>        End
13897>>>>>>
13897>>>>>        
13897>>>>>        //  Encode binary hash to Base64
13897>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
13898>>>>>        Move (PointerToString(pBase64)) to sBase64
13899>>>>>        Move (Free(pBase64)) to iVoid
13900>>>>>        
13900>>>>>        Function_Return sBase64
13901>>>>>    End_Function
13902>>>>>    
13902>>>>>    
13902>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
13902>>>>>    //
13902>>>>>    // Params:
13902>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
13902>>>>>    // Returns:
13902>>>>>    //   Readable plain text password
13902>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
13904>>>>>        String sEncryptPassword
13904>>>>>        UChar[] ucBinary ucPlain
13906>>>>>        Boolean bIsHex
13906>>>>>        Integer iLen iVoid
13906>>>>>        Pointer pBinary
13906>>>>>        
13906>>>>>        If (sBase64EncryptedPassword <> "") Begin
13908>>>>>            //  Decode from Base64
13908>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
13909>>>>>            
13909>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
13910>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
13911>>>>>                        
13911>>>>>            Move (Free(pBinary)) to iVoid
13912>>>>>            
13912>>>>>            //  Encrypted binary hash to string
13912>>>>>            Get GetEncryptionPassword to sEncryptPassword
13913>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
13914>>>>>        End
13914>>>>>>
13914>>>>>        
13914>>>>>        Function_Return (UCharArrayToString(ucPlain))
13915>>>>>    End_Function
13916>>>>>End_Class
13917>>>
13917>>>Object oLoginEncryption is a cLoginEncryption
13919>>>
13919>>>    // this must be created in your appsrc directory and must contain an encryption
13919>>>    // key that is set to psEncryptPassword. It will look something like this
13919>>>    //
13919>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
13919>>>    //  
Including file: LoginEncryptionKey.inc    (C:\DataFlex Projects\Centros\AppSrc\LoginEncryptionKey.inc)
13919>>>>// Studio generated login encryption key
13919>>>>Set psEncryptPassword to "nX,`aCLjN<#ah&V#INur~oy)$^b,#I6q2>P:)4@*"
13920>>>>
13920>>>    
13920>>>    // use this to register this object to your cConnection Object. This object
13920>>>    // must be created after the cConnection object
13920>>>    Move Self to ghoLoginEncryption
13921>>>End_Object
13922>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 25.0\Pkg\DatabaseLoginDialog.dg)
13922>>>
13922>>>Use Windows.pkg
13922>>>Use cConnection.pkg
13922>>>Use dfLine.pkg
Including file: Dfline.pkg    (C:\Program Files\DataFlex 25.0\Pkg\Dfline.pkg)
13922>>>>>Use windows.pkg
13922>>>>>
13922>>>>>//
13922>>>>>// Line Styles
13922>>>>>//
13922>>>>>Enumeration_List
13922>>>>>    Define lnDIP        // grey (Shadow) top line, light bottom (highlight)
13922>>>>>    Define lnBUMP       // light top (highlight), grey (Shadow) bottom
13922>>>>>    Define lnSINGLE     // Single dark line
13922>>>>>    Define lnCUSTOM     // create your own with line_color1 & 2.
13922>>>>>End_Enumeration_List
13922>>>>>
13922>>>>>Class LineControl is a DFBaseLineControl
13923>>>>>    
13923>>>>>    Procedure Construct_Object
13925>>>>>        Forward Send Construct_Object
13927>>>>>        Property Integer Line_Color1  COLOR_BTNSHADOW
13928>>>>>        Property Integer Line_Color2  COLOR_BTNHIGHLIGHT
13929>>>>>        // we do not want control to participate in forward backwards object navigation
13929>>>>>        Set Skip_State to True
13930>>>>>    End_Procedure
13931>>>>>    
13931>>>>>    Procedure Notify Longptr wParam Longptr lParam
13933>>>>>    End_Procedure
13934>>>>>    
13934>>>>>    Procedure Set Line_Color1 Integer theColor
13936>>>>>        Set top_line_color to theColor
13937>>>>>    End_Procedure
13938>>>>>    
13938>>>>>    Procedure Set Line_Color2 Integer theColor
13940>>>>>        Set bottom_line_color to theColor
13941>>>>>    End_Procedure
13942>>>>>    
13942>>>>>    Function Line_Color1 Returns Integer
13944>>>>>        Function_Return (top_line_color(Self))
13945>>>>>    End_Function
13946>>>>>    
13946>>>>>    Function Line_Color2 Returns Integer
13948>>>>>        Function_Return (bottom_line_color(Self))
13949>>>>>    End_Function
13950>>>>>End_Class
13951>>>>>
13951>>>
13951>>>Object oDatabaseLoginDialog is a ModalPanel
13953>>>    Set Label to "Database Login"
13954>>>    Set Location to 2 2
13955>>>    Set Size to 110 211
13956>>>    
13956>>>    Property String psId
13958>>>    Property Boolean pbOk False
13960>>>    Property Boolean pbChanged False
13962>>>    Property Boolean pbAllowRemember True
13964>>>    
13964>>>    // this registers this object with the cConnection object.
13964>>>    Move Self to ghoLoginConnectDialog
13965>>>    
13965>>>    Object oUserIDForm is a Form
13967>>>        Set Label to "User Name"
13968>>>        Set Size to 12 85
13969>>>        Set Location to 34 79
13970>>>        Set Label_Col_Offset to 64
13971>>>        Set peAnchors to anTopLeftRight
13972>>>    End_Object
13973>>>    
13973>>>    Object oPwdForm is a Form
13975>>>        Set Size to 12 85
13976>>>        Set Location to 49 79
13977>>>        Set Label_Col_Offset to 64
13978>>>        Set Password_State to True
13979>>>        Set peAnchors to anTopLeftRight
13980>>>        Set Label to "Password"
13981>>>    End_Object
13982>>>    
13982>>>    Object oTrustedConnection is a CheckBox
13984>>>        Set Size to 10 50
13985>>>        Set Location to 65 79
13986>>>        Set Label to "Trusted Connection"
13987>>>    End_Object
13988>>>    
13988>>>    Object oRemember is a CheckBox
13990>>>        Set Size to 10 50
13991>>>        Set Location to 79 14
13992>>>        Set Label to "Remember and don't ask again"
13993>>>        Set Checked_State to True
13994>>>    End_Object
13995>>>    
13995>>>    Object oLogin_btn is a Button
13997>>>        Set Label to "&Login"
13998>>>        Set Location to 92 102
13999>>>        Set peAnchors to anBottomRight
14000>>>        Set Default_State to True
14001>>>        
14001>>>        Procedure OnClick
14004>>>            Boolean bTrust
14004>>>            String sUser sPwd sConn sErr sId
14004>>>            Integer iError
14004>>>            Get psId to sId
14005>>>            Get Value of oUserIDForm to sUser
14006>>>            Get Value of oPwdForm to sPwd
14007>>>            Get Checked_State of oTrustedConnection to bTrust
14008>>>            
14008>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
14009>>>            If (iError=0) Begin
14011>>>                Set pbOk to True
14012>>>                Set pbChanged to True
14013>>>                Send Close_Panel
14014>>>            End
14014>>>>
14014>>>            Else Begin
14015>>>                Get psErrorText of ghoConnection to sErr
14016>>>                Send UserError sErr "Login Error"
14017>>>            End
14017>>>>
14017>>>        End_Procedure
14018>>>    End_Object
14019>>>    
14019>>>    Object oCancel_btn is a Button
14021>>>        Set Label to "&Cancel"
14022>>>        Set Location to 92 157
14023>>>        Set peAnchors to anBottomRight
14024>>>        
14024>>>        Procedure OnClick
14027>>>            Send Close_Panel
14028>>>        End_Procedure
14029>>>    End_Object
14030>>>    
14030>>>    Object oConnectionIdInfo is a TextBox
14032>>>        Set Size to 10 50
14033>>>        Set Location to 4 14
14034>>>        Set Label to 'Connection Id='
14035>>>    End_Object
14036>>>    
14036>>>    Object oConnectionServerInfo is a TextBox
14038>>>        Set Size to 10 50
14039>>>        Set Location to 16 14
14040>>>        Set Label to 'Server'
14041>>>    End_Object
14042>>>    
14042>>>    Object oLineControl1 is a LineControl
14044>>>        Set Size to 2 202
14045>>>        Set Location to 29 5
14046>>>    End_Object
14047>>>    
14047>>>    Function LoginConnectIdDialog String sId Returns Boolean
14050>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
14050>>>        String sUser sPwd sDescription
14050>>>        tConnection Connect
14050>>>        tConnection Connect
14050>>>        
14050>>>        Get pbAllowRemember to bAllowRemember
14051>>>        
14051>>>        
14051>>>        If not bAllowRemember Begin
14053>>>            Set Enabled_State of oRemember to bRemember
14054>>>            Set Visible_State of oRemember to bRemember
14055>>>        End
14055>>>>
14055>>>        
14055>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
14056>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
14057>>>        Set Value of oConnectionServerInfo to Connect.sString
14058>>>        
14058>>>        Set psId to sId
14059>>>        Set pbOk to False
14060>>>        Set pbChanged to False
14061>>>        Set Value of oUserIDForm to Connect.sUID
14062>>>        Set Value of oPwdForm to ""
14063>>>        
14063>>>        Send Popup
14064>>>        
14064>>>        Get pbOk to bOk
14065>>>        Get pbChanged to bChanged
14066>>>        If (bChanged and bOk) Begin
14068>>>            If bAllowRemember Begin
14070>>>                Get Checked_State of oRemember to bRemember
14071>>>                If bRemember Begin
14073>>>                    Get Checked_State of oTrustedConnection to bTrusted
14074>>>                    If not (bTrusted) Begin
14076>>>                        Get Value of oUserIDForm to sUser
14077>>>                        Get Value of oPwdForm to sPwd
14078>>>                    End
14078>>>>
14078>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
14079>>>                End
14079>>>>
14079>>>            End
14079>>>>
14079>>>        End
14079>>>>
14079>>>        Function_Return bOk
14080>>>    End_Function
14081>>>    
14081>>>    
14081>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
14082>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
14083>>>End_Object
14084>>>
14084>    End_Object
14085>
14085>End_Object
14086>
14086>//Send Info_Box ("The encrypted credentials for projects in this workspace are properly stored in DFConnID.ini. \n \n" + ;
14086>//               "See the 'Using Managed Connections | Defining a Connection' section in the Help for complete information about credentials. \n \n" + ;
14086>//               "You can Open DFConnID.ini (from the Quick Open Toolbar) and confirm the UID, DFPWD and PWD for this managed connection.") "DataFlex Windows Login"
14086>
14086>Send Info_Box ("Las credenciales cifradas para proyectos en este espacio de trabajo se almacenan correctamente en DFConnID.ini. \n \n" + ;               "Consulte la seccin 'Using Managed Connections | Defining a Connection' en la Ayuda para obtener informacin completa sobre las credenciales. \n \n" + ;               "Puede abrir DFConnID.ini (desde la barra de herramientas de apertura rpida) y confirmar el UID, DFPWD y PWD para esta conexin administrada.") "DataFlex Windows Login"
14087>
14087>//********************************* end of ManagedConnectionLoginProject.tpl for Spanish **************
14087>
Summary
Memory Available: 8840974336
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 13204
Total Resources: 0
Total Commands : 14086
Total Windows  : 0
Total Pages    : 0
Static Data    : 170160
Message area   : 73375
Total Blocks   : 7649
